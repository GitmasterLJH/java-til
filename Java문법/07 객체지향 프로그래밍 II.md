## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

---

#### 1.1 상속의 정의와 장점

**상속** 

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
  - 그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
```

**구현 방법**

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 `extends`와 함께 써 주기만하면 된다. 

   - ```java
     class Parent { }
     class Child extends Parent{ }
     ```

     이때 상속해주는 클래스(Parent)를 `조상 클래스` , 상속 받는 클래스(Child)를 `자손 클래스` 라고 한다.

     ```
     조상 클래스	부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
     자손 클래스	자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
     ```

#### 상속 계층도(class hierarchy)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/291dc482-e390-440f-a6c2-21f9d40c3bb2" height="200px" width="200px">

예제

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

```java
class CaptionTvTest {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();    // 자손 클래스의 인스턴스 생성
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel);
        ctv.displayCaption("Hello, World");
        ctv.caption = true;
        ctv.displayCaption("Hello,World");
    }
}

class Tv{
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power()    { power = !power;}
    void channelUp()    { ++channel;}
    void channelDown()  { --channel;}
}
class CaptionTv extends Tv{
    boolean caption;    // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){
            System.out.println(text);
        }
    }
}
```

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/407de19a-1deb-4015-98b7-d430701bad89" height="300px" width="500px">

#### 1.2 클래스간의 관계 - 포함(Composite)관계

-한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

예제1

```java
class Circle{													
	int x;	// 원점의 x좌표								
	int y;	// 원점의 y좌표
	int r;	// 반지름(radius)
}						
class Point{
	int x;	// x좌표
	int y;	// y좌표
}

// Point클래스를 재사용하여 Circle클래스를 작성
class Circle{
	Point c = new Point();	// 원점
	int r;
}
```

예제2

```java
/* Car클래스의 단위구성요소인 Engine, Door와 같은 클래스를 미리 작성해 놓고 이 들을 Car클래스의 멤버변수로
선언하여 포함관계를 맺어주면, 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽다.코드를 관리하는데도 수월
*/

class Car{
	Engine e = new Engine();	// 엔진
	Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
}
```

#### 1.3 클래스간의 관계 결정하기

둘중 성립하는 문장의 관계를 맺어주면됨

```
상속관계 맺어주기	:	~은 ~이다(is-a)
포함관계 맺어주기	:	~은 ~을 가지고 있다(has-a)
```

ex1)

```
예시 1
원(Circle) 과 점(Point)
원은 점이다 보다 원은 점을 가지고 있다가 더 옳기 때문에 포함관계를 맺어준다.

예시 2
Car클래스와 SportsCar클래스
SportsCar는 Car이다. 가 옳기 때문에 이 두클래스는 Car클래스를 조상으로하는 상속관계를 맺어 주어야 한다.

예시 3
Card클래스와 Deck클래스
Deck은 Card를 가지고 있다. 가 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
```

#### 1.4 단일 상속(single inheritance)

자바에서는 다중상속을 허용하지 않고 단일 상속만을 허용한다.

- 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.

#### 1.5 Object클래스 - 모든 클래스의 조상

`다른 클래스로부터 상속받지 않는 모든 클래스`들은 자동적으로 Object클래스로부터 상속받게 한다.(extends가 없는 클래스들)

```java
// 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의
class Tv{
	//...
}
// 위 코드를 컴파일 하면 컴파일러는 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.
class Tv extends Object{
	//...
}
```

모든 클래스들은 Object클래스의 멤버들을 상속 받음 ----> Object클래스에 정의된 멤버들을 사용할 수 있다.

ex) toString() 이나 equals(Object o)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/417f4761-7236-4cff-b8d2-995f99a6b2ca" height="200px" width="200px">

### 2. 오버라이딩(overriding)

---

#### 2.1 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
}
```

#### 2.2 오버라이딩의 조건

```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
	- 이름이 같아야 한다
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
	
즉 메서드 선언부는 조상의 것과 완전히 일치해야 한다.
```

접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

```
	조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 넓은 것에서 좁은 것 순으로 나열 public, protected,(default), private
		 만약 조상 클래스가 protected면 오버라이딩하는 자손 클래스의 메서드는 protected나 public이어야 한다.
		 
	2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

#### Q. static메서드 오버라이딩?

- 부모 클래스와 자식 클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.

- static 메소드는 컴파일시, 메모리에 올라가고 메서드 영역에 존재하며, 실제 객체를 찾는 작업을 시행x 

​       -> 컴파일 시점에 선언된 타입의 메소드 호출

- 오버라이딩은 런타임 시, 사용될 메소드 결정
- staic은 클래스 단위의 성격, 오버라이딩은 객체 단위의 성격을 지님
  따라서 static메소드는 오버라이딩 불가x

#### 2.3 오버로딩 , 오버라이딩

```
오버로딩(overloading)	기존에 없던 새로은 메서드를 정의하는 것(new)
오버라이딩(overriding)	상속받은 메서드의 내용을 변경하는것(change,modify)
```

```java
class Parent{
	void parentMethod(){}
}
class Child extends Parent{
	void parentMethod() {}			// 오버라이딩
	void parentMethod(int i) {}		// 오버로딩
	
	void childMethod() {}
	void childMethod(int i) {}		// 오버로딩
	void childMethod() {}			// 에러, 중복정의
}
```

#### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

- this와 마찬가지로 static메서드에서는 사용불가
- 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우만 사용

예제 1

```java
class SuperTest{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}

/* 실행결과
이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력됨

x=10
this.x=10
super.x=10
*/
```

예제 2

```java
class SuperTest2{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}
/* 실행결과
x=20
this.x=20	// 자손 클래스에 선언된 멤버변수
super.x=10	// 조상 클래스로부터 상속받은 멤버변수 x
*/
```

예제 3(super를 사용해서 조상클래스의 메서드를 포함시킴)

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		// return "x : " + x + ", y : " + y + ", z : " + z;
		   reuturn super.getLocation() + ", z "+ z;	// 조상의 메서드 호출
	}
}
// 이러면 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손클래스의 메서드에 자동적으로 반영됨
```

#### 2.5 super() - 조상 클래스의 생성자

```
Object클래스를 제외한 모든 클래스들의 생성자 첫 줄에 생성자,this() 또는 super(), 를 호출해야 한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
```

예제

```java
class PointTest {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}
class Point{
    int x,y;
    Point(int x, int y){
        // super(); 자동 삽입, super()는 Point의 조상인 Object클래스의 기본생성자인 Object()를 의미
        this.x = x;
        this.y = y;
    }
    String getLocation(){
        return "x : "+x+", y : "+y;
    }
}
class Point3D extends Point{
    int z;
    
    Point3D(int x, int y, int z){
      // 컴파일 에러 생성자인 Point() 를 찾을 수 없다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
    String getLocation(){
        return "x : "+x+", y : "+y+", z : "+z;
    }
}

/* Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 super();를 
 Point3D클래스의 생성자의 첫 줄에 넣는데 이때 super();가 호출 되면서 3D클래스의 조상인 Point클래스의 기본생성자인 Point() 
 가 호출되게 된다. 그러나 Point클래스에 Point()가 정의되어 있지 않기 때문에 에러가난다
 이를 해결하기 위해서는 두가지 방법이 있다.
 1.Point클래스에 생성자 Point()를 추가해준다.
 2.Point3D(int x, int y, int z)의 첫 줄에서 super(x,y);를 집어넣어서 Point(int x, int y)를 호출하도록 변경하면 된다.
 */
```

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 한다.**



### 3. package와 import

---

#### 3.1 패키지(package)

패키지 : 클래스의 묶음

ex) 

- String 클래스의 실제 이름은 java.lang.String이다. java.lang패키지에 속한 String 클래스라는 의미

```
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분잘 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
```

#### 3.2 패키지의 선언

- 패키지명은 대소문자 모두 허용하지만 소문자로 하는 것이 원칙
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다.

```
소스파일의 맨 위에 다음과 같이 한 줄만 적어주면 된다.

package 패키지명;
```

- JVM이 클래스를 찾을수 있게 com.codechobo.book; 이 패키지면 환경변수를 CLASSPATH에다가 패키지 경로를 지정해야한다.
  - 상위 디렉토리가 C:\jdk1.8\work이면 .;C:\jdk1.8\work
  - .; 를 추가한 이우는 현재 디렉토리(.)를 클래스패스에 포함시키기 위해서

#### 3.3 import문

- import문은 컴파일 시에 처리되므 프로그램 성능 영향없음.

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기엔 불편하다.

그래서 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략가능

```
일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
	1. package문
	2. import문
	3. 클래스 선언
	
import문 선언방법
	import 패키지명.클래스명;
			또는
	import 패키지명.*;
	
	
ex)
	import java.util.Calendar;
	import java.util.Date;
	improt java.util.ArrayList;
	
	// 한번에
	import java.util.*;
```

#### 하지만 *은 하위 패키지의 클래스까지 포함하는 것은 아니다.

```java
import java.util.*;
import java.text.*;

// 위의 두 문장 대신 다음과 같이 할 수는 없다.
// import java.* 의 의미는 java패키지의 모든 클래스를 의미한다.(패키지는 포함안됨)
import java.*;
```

예제

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class ImportTest {
    public static void main(String[] args) {
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println("오늘 날짜는 " +date.format(today));
        System.out.println("현재 시간은 "+time.format(today));
    }
}
/* 만약 import문을 지정하지 않았다면 다음과 같이 클래스이름에 패키지명도 적어줘야 했다.

java.util.Date today = new java.util.Date();
java.text.SimpleDateFormat date = new java.text.SimpleDateFormat("yyyy/MM/dd");
java.text.SimpleDateFormat time = new java.time.SimpleDateFormat("hh:mm:ss a");
*/
```

**참고**

- System 과 String 같은 java.lang패키지의 클래스들은 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 다음과 같은 import문이 선언되어 있기 때문이다
  - import java.lang.*;
    - java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 되도록 한 것이다.

#### 3.5 static import 문

- static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```
import static java.lang.Integer.*;		// Integer클래스의 모든 static메소드
import static java.lang.Math.random();	// Math 생략가능
import static java.lang.System.out;		// System.out을 out으로만 참조가능
```

```java
//예제

import static java.lang.System.out;
import static java.lang.Math.*;
class StaticImportEx1 {
    public static void main(String[] args) {
        // System.out.println(Math.random());
        out.println(random());
        // System.out.println("Math.PI : " + Math.PI);
        out.println("Math.PI : "+PI);
    }
}
```

### 4. 제어자(modifier)

---

#### 4.1 제어자란?

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

```
접근 제어자		public, protected, default, private
그	   외	  static, final, abstract, native, transient, synchronized, volatile, strictfp
```

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근 제어자는 한 번에 네 가지중에 하나만 선택해서 사용 가능

#### 4.2 static 

- static은  '클래스의', '공통적인' 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/12648d16-ed1e-4b1a-a740-dcf3973db38b" height="250px" width="700px">

#### 4.3 final

- 마지막의 또는 변경될 수 없는의 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/ec326096-2fa1-45e0-a0b5-2019591b2a29" height="250px" width="700px">

#### 생성자를 이용한 final멤버 변수의 초기화

- 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다. 

  - 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능

  ```java
  class FinalCardTest {
      public static void main(String[] args) {
          Card c = new Card("Heart",10);
  //      c.NUMBER = 5;     에러!! cannot assign a value to final variable NUMBER
          System.out.println(c.KIND);
          System.out.println(c.NUMBER);
          System.out.println(c);  // System.out.println(c.toString());
      }
  }
  class Card{
      final int NUMBER;
      final String KIND;
      static int width = 100;
      static int height = 250;
  
      Card(String kind, int num){			// 매개변수로 넘겨받은값으로 KIND와 NUMBER를 초기화한다.
          KIND = kind;
          NUMBER = num;
      }
      Card(){
          this("Heart",1);
      }
      public String toString(){
          return KIND + " "+ NUMBER; 
      }
  }
  ```

#### 4.4 abstract

- '미완성'의 의미를 가지고 있다.
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

```java
abstract class AbstractTest{		// 추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move();			// 추상 메서드(구현부가 없는 메서드)
}
```

#### 4.5 접근 제어자(access modifier)

- 멤버 또는클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  

```
public			접근 제한이 전혀 없다.
protected 		같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
(default)		같은 패키지 내에서만 접근이 가능하다.
private			같은 클래스 내에서만 접근이 가능하다.
```

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/c97ee524-3c68-4710-8d52-eb7cdc407241" height="220px" width="600px">

- 대상에 따라 사용할 수 있는 접근 제어자

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/20667e4d-56ee-4432-9ada-bc815a343d1c" height="220px" width="600px">

**접근 제어자를 이용한 캡슐화**

- 데이터가 유효한 값을 유지하도록, 또는 외부에서 함부로 변경하지 못하도록 외부로부터 접근을 제한하는 것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 **캡슐화**(encapsulation)에 해당하는 내용이다.

```
접근 제어자를 사용하는 이유
	- 외부로부터 데이터를 보호하기 위해서
	- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
```

**예시**

시간을 표시하기 위한 클래스 Time이 다음과 같이 정의되어 있을 때

```java
public class Time{
	public int hour;
	public int minute;
	public int second;
}
```

이 클래스의 인스턴스를 생성한 다음, 멤버변수에 직접 접근하여 값을 변경할 수 있을 것이다.

멤버변수 hour은 0<= hour < 24 의 범위를 가져야 하지만 아래 코드처럼 잘못된 값을 지정한다고해도 막을 방법이 없다.

```java
Time t = new Time();
t.hour = 25;
```

이런 경우 멤버변수를 private이나 protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다.

```java
public class Time{
	private int hour;
	private int minute;
	private int second;
	
	public int getHour()	{ return hour; }
	public void setHour(int hour){
		if(hour < 0 || hour > 23) return;
		this.hour = hour;
	}
	public int getMinute(){ return minute; }
	public void setMinute(int minute){
		if(minute < 0 || minute > 59) return;
		this.minute = minute;
	}
	public int getSecond(){ return second; }
	public void setSecond(int second){
		if(second < 0 || second > 59) return;
		this.second = second;
	}
}

// Time클래스의 모든 멤버변수의 접근 제어자를 private로 하고, 이들을 다루기 위한 public메서드를 추가했다.
// t.hour = 13; 과 같이 멤버변수로의 직접적인 접근은 허가되지 않고 메서드를 통한 접근만이 허용된다.
```

- getter
  - get으로 시작하는 메서드
  - 멤버변수의 값을 반환
  - 예시 )  
    - public int getHour()	{ return hour; }
- setter
  - set으로 시작하는 메서드
  - 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경함
  - 예시 ) 
    - public void setHour(int hour){
      		if(hour < 0 || hour > 23)   return;
        		this.hour = hour;
        	}

**생성자의 접근 제어자**

#### Singleton 패턴(객체의 인스턴스가 오직 1개만 생성)

생성자의 접근 제어자를 private으로 지정하면 외부에서 생성자에 접근할 수 없으므로 인트스턴스를 생성할 수 없게 된다.

그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```
class Singleton{
	private Singleton(){
		...
	}
	...
}
```

대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할 수 있다.

이 메서드는 public인 동시에 static이어야한다.

```java
class Singleton{
	...
	// getInstance()에서 사용될 수있도록 인스턴스가 미리 생성되어야 하므로 static 이어야 한다.
	private static Singleton s = new Singleton();	
													
	private Singleton(){		// 생성자  private
		...
	}
	
	// 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다.
	public static Singleton getInstance(){
		return s;
	}
}
```

또 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 왜냐하면 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래에서 호출하는 것이 불가능하기 때문이다.

그래서 클래스 앞에 `final`을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.



#### 4.6 제어자(modifier)의 조합

| 대상     | 사용가능한 제어자                         |
| -------- | ----------------------------------------- |
| 클래스   | public, (default), final, abstract        |
| 메서드   | 모든 접근 제어자, final, abstract, static |
| 멤버변수 | 모든 접근 제어자, final, static           |
| 지역변수 | final                                     |

주의사항!!!

```
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
	static 메서드는 구현된 내용이 있어야 하며, 추상 메서드는 구현 내용이 없어야 한다.
	
2. 클래스에 abstract와 final을 동시에 사용할 수 없다..
	클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야
	한다는 의미이므로 서로 모순되기 때문이다.
	
3. abstract메서드의 접근 제어자가 private일 수 없다.
	abstract메서드는 자손클래스에서 구현해줘야 하는데 접근 제어자가 private이면, 
	자손클래스에서 접근할 수 없기 때문이다.
	
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
	접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.
```

### 5. 다형성(polymorphism)

---

#### 5.1 다형성이란?

객체지향개념에서 다형성	:	여러 가지 형태를 가질 수 있는 능력

자바에서는 **한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함**으로써 다형성을 프로그램적으로 구현했다.

-> **조상클래스 타입의 참조변수로 자손클래스 인스턴스를 참조할 수 있도록 함**

예제

```java
class Tv{
	boolean power;		// 전원상태(on/off)
	int channel;		// 채널
	
	void power()	 {	power = !power;	}
	void channelUp	 {	++channel;	}
	void channelDown {	--channel;	}
}

class CaptionTv extends Tv{
	String text;	// 캡션을 보여주기 위한 문자열
	void caption(){	/* 내용 생략 */ }
}
```

클래스 Tv와 CaptionTv는 서로 상속관계에 있다

다음과 같이 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능

```java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();	// 조상 타입의 참조변수로 자손 인스턴스를 참조
```

**참조변수 t는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있다.** 

따라서 생성된 CaptionTv인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 멤버, text, caption()은 참조변수 t로 사용 불가능



반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능

```java
CaptionTv c = new Tv();
```

실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문에 에러

CaptionTv클래스에는 text와 caption()이 정의되어 있으므로 참조변수 c로는 c.text, c.catpion()과 같은 방식으로 c가 참조하고 있는 인스턴스에서 text와 caption()을 사용하려 할 수있다. 하지만 c가 참조하고 있는 인스턴스는 Tv타입이고, Tv타입의 인스턴스에는 text와 caption()이 존재하지 않기 때문에 문제가 발생. 

자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용x

**참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.**

```
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.

|참고| 모든 참조변수는 null 또는 4 byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.
```

#### 5.2 참조변수의 형변환

```
	자손타입 -> 조상타입(Up-casting)	: 형변환 생략가능
	조상타입 -> 자손타입(Down-casting)	: 형변환 생략불가
```

- 상속관계가 아닌 클래스간의 형변환 불가
- 자식타입 참조변수에서 조상타입 참조변수로 형변환 하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 형변환 생략 가능 
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 떄문에 인스턴스에 아무런 영향을 미치지 않는다.
  - 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.

예제

```java
//Car클래스가 FireEngine 과 Amulance 클래스의 조상일때

class Car{}
class FireEngine extends Car{
      void water(){
        System.out.println("water!!!");
    }
}
class Ambulance extends Car{}

FireEngine f;
Ambulance  a;
a = (Ambulance)f;	// 에러. 상속관계가 아닌 클래스간의 형변환 불가
f = (FireEngine)a;  // 에러. 상속관계가 아닌 클래스간의 형변환 불가

Car car = null;
FireEngine fe  = new FireEngine();
FireEngine fe2 = null;

/* 참조변수 fe가 참조하고 있는 인스턴스를 참조변수 car가 참조하도록 한다. fe의 값이(fe가 참조하고 있는 인스턴스의 주소)
이 car에 저장된다. 이때 car = (Car)fe; 에서 형변환 생략됨, Up-casting 이제는 참조변수 car를 통해서도 
FireEngine인스터스를 사용할 수 있지만 fe와 달리 car는 Car타입이므로 Car클래스 멤버가아닌 water()는 사용할 수 없다.
*/
car = fe;

/*
	참조변수 car가 참조하고 있는 인스턴스를 참조변수 fe2가 참조하도록 한다. 이때 두 참조변수의 타입이 다르므로 참조변수
	car 를 형변환하였다. car에는 FireEngine인스턴스의 주소가 저장되어 있으므로 fe2에도 FireEngine인스턴스의 주소가
	저장된다. 이제는 참조변수 fe2를 통해서도 FireEngine인스턴스를 사용할 수 있지만, car와는 달리, fe2는 
	FireEngine타입이므로 FireEngine 인스턴스의 모든 멤버들을 사용할 수 있다.
*/
fe2 = (FireEngine)car
```

예제2

```java
class CastingTest2 {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;

        car.drive();
        fe = (FireEngine)car;	// 컴파일 에러 부분
        fe.drive();
        car2 = fe;
        car2.drive();
    }
}
/* 컴파일 에러 
	캐스트 연산자를 이용해서 조상타입의 참조변수를 자손타입의 참조변수로 형변환한 것이기 때문에 문제가 없어 보이지만
	문제는 참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스라는데 있다. 조상타입의 인스턴스를 자손타입의 
	참조변수로 참조하는 것은 허용되지 않는다.
	컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다.
	그래서 컴파일 시에는 문제가 없었지만, 실행 시에는 에러가 발생
	
	Car car = new FireEngine(); 으로 바꾸면 에러가 발생하지 않을것이다.
*/
```

```
서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나,
참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
```

#### 5.3 instanceof연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알수 있음
- instanceof 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다. 그리고 true or false를 반환. 

```java
class InstanceofTest {
    public static void main(String[] args) {
        FireEngine fe =new FireEngine();

        if(fe instanceof FireEngine){
            System.out.println("This is a FireEngine instance.");
        }
        if(fe instanceof Car){
            System.out.println("This is a Car instance.");
        }
        if(fe instanceof Object) {
            System.out.println("This is an Object instance");
        }
        System.out.println(fe.getClass().getName());    // 클래스의 이름을 출력
    }
}
/* 생성된 인스턴스는 FireEngine타입인데도, Object, Car타입의 instanceof연산에서도 true를 결과로 얻었다.
	그 이유는 FireEngine클래스는 Object클래스와 Car클래스의 자손 클래스이므로 조상의 멤버들을 상속받았기 때문에,
	FireEngine인스턴스는 Object인스턴스와 Car인스턴스를 포함하고 있는 셈이기 때문이다.
*/
```

```
어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
```

#### 5.4 참조변수와 인스턴스의 연결

- 조상클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을때  조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고,  자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.
- 메서드의 경우 조상 클래스의 메서드를 자손클래스에서 오버라이딩한 경우에는 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출됨
- static 메서드는 static 변수처럼  참조변수의 타입에 영향을 받는다. 참조변수에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. 그래서 반드시 참조변수가 아닌 `클래스이름.메서드()`로 호출 해야한다.
-  `Parent p = new Child();`만약 up-casting을 하지않고 그냥 new Parent();를 한다면 오버라이딩이 일어나지 않아서 p.method를 호출할시 Parent클래스의 메서드가 직접호출된다. 즉 이는 다형성을 활용하지 않고 Parent클래스의 인스턴스에 직접 접근하는 것이다.

```java
class BindingTest2 {
    public static void main(String[] args) {
        Parent p = new Child();			// up-casting으로 p.method()는 오버라이딩한 Child의 method()가 호출됨		
        Child c = new Child();

        System.out.println("p.x = "+p.x);
        p.method();
        System.out.println();

        System.out.println("c.x = "+c.x);
        c.method();
    }
}
class Parent{
    static int x = 100;
    void method(){
        System.out.println("Parent Method");
    }
}

class Child extends Parent{

    int x = 200;

    void method(){
        System.out.println("x="+x);				// this.x와 같다.
        System.out.println("super.x="+super.x); // 조상클래스인 Parent에 선언된 인스턴스변수 x
        System.out.println("this.x="+this.x);	// Child클래스의 인스턴스변수 x
    }
}
/* 결과
p.x = 100
x=200
super.x=100
this.x=200

c.x = 200
x=200
super.x=100
this.x=200

*/
```

#### 5.5 매개변수의 다형성

```java
class Product{
	int price;		// 제품의 가격
	int bonusPoint	// 제품구매 시 제공하는 보너스 점수
}
class Tv  		extends Product{}
class Computer 	extends Product{}
class Audio		extends Product{}

class Buyer{					// 고객, 물건을 사는 사람					
	int money = 1000;			// 소유금액
	int bonusPoint	= 100;		// 보너스 점수
}
```

Product클래스는 Tv,Audio,Computer 클래스의 조상이며, Buyer 클래스는 제품을 구입하는 사람

Tv를 살 수 있도록 매개변수를 Tv타입으로 하면

```java
void buy(Tv t){
	// Buyer가 가진돈(money)에서 제품의 가격(t.price)만큼 뺀다.
	money = money - t.price;
	
	// Buyer의 보너스점수(bonusPoint)에 제품의 보너스점수(t.bonusPoint)를 더한다.
	bonusPoint = bonusPoint + t.bonusPoint;
}
```

그런데 void buy(Tv t)로는 Tv밖에 살 수 없기 떄문에 다른 제품들도 구입할 수 있는 메서드가 추가로 필요

```java
void buy(Computer c){
	money = money - t.price;     
    bonusPoint = bonusPoint + t.bonusPoint;
}

void buy(Audio a){
	money = money - t.price;     
    bonusPoint = bonusPoint + t.bonusPoint;
}
```

이렇게되면, 제품의 종류가 늘어날 때마다 Buyer클래스에는 새로운 buy메서드를 추가해주어야한다.

그러나 메서드의 매개변수에 다형성을 적용하면 하나의 메서드로 간단히 처리가능(**매개변수가 조상타입의 참조변수**)

```java
void buy(Product p){
	money = money - p.price;
	bonusPoint = bonusPoint + p.bonusPoint;
	}
```

이제 매개변수가 Product타입의 참조변수 이므로 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다.

Product클래스에 price와 bonusPoint가 선언되어 있기에 참조변수 p로 인스턴스의 price와 bonusPoint를 사용가능

```java
Buyer b = new Buyer();
Tv t = new Tv();
Computer c = new Computer();
b.buy(t);
b.buy(c);
```

예제

```java
class PolyArgumentTest {
    public static void main(String[] args) {
        Buyer b = new Buyer();

        b.buy(new Tv());
        b.buy(new Computer());

        System.out.println("현재남은 돈은 "+b.money+"만원입니다.");
        System.out.println("현재 보너스 점수는 "+b.bonusPoint+"점입니다.");
    }
}

class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price=price;
        bonusPoint = (int)(price/10.0);
    }
}
class Tv extends Product{
    Tv(){
        super(100);
    }
    // Object클래스의 toString()을 오버라이딩한다.
    public  String toString(){ return "Tv";}
}
class Computer extends Product{
    Computer(){ super(200);}

    public String toString() { return "Computer";}
}
class Buyer{
    int money = 1000;
    int bonusPoint = 0;

    void buy(Product p){
        if(money < p.price){
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }
        money -= p.price;
        bonusPoint +=p.bonusPoint;
        System.out.println(p+"을/를 구입하셨습니다.");
    }
}

/* 결과
Tv을/를 구입하셨습니다.
Computer을/를 구입하셨습니다.
현재남은 돈은 700만원입니다.
현재 보너스 점수는 30점입니다.
*/		
```

#### 5.6 여러 종류의 객체를 배열로 다루기

```java
Product p1 = new Tv();
Product p2 = new Computer();
Product p3 = new Audio();

// Proudct 타입의 참조변수 배열
Product [] p = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

만약 Product [] p = new Product[10]이면 배열의 크기를 10으로 했기 때문에 11개 이상의 제품을 구입할 수 없는데 그렇다고 배열의 크기를 무조건 크게 설정할 수만도 없다.

이런경우, Vector클래스를 사용하면된다. Vector클래스는 내부적으로 Object타입의 배열을 가지고 있어서, 이 배열에 객체를  추가하거나 제거할 수 있게 작성되어 있다.

동적으로 관리되는 객체 배열

```java
public class Vector exntends AbstractList
			  implements List, Cloneable, java.io.Serializable{
		  protected Object elementData[];''		 
	 }
```

| 메서드/생성자            | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Vector()                 | 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다. |
| boolean add(Object o)    | Vector에 객체를 추가한다. 추가에 성공하면 true, 실패하면 false를 반환 |
| booelan remove(Object O) | Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환 |
| boolean isEmpty()        | Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환 |
| Object get(int index)    | 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로 형변환이 필요 |
| int size()               | Vector에 저장된 객체의 수를 반환한다.                        |

예제

```java
import java.util.*;     // Vector클래스를 사용하기 위해서 추가해줌
class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price=price;
        bonusPoint = (int)(price/10.0);
    }
    Product() {}
}
class Tv extends Product{
    Tv(){
        super(100);
    }
    // Object클래스의 toString()을 오버라이딩한다.
    public  String toString(){ return "Tv";}
}
class Computer extends Product{
    Computer(){ super(200);}

    public String toString() { return "Computer";}
}
class Audio extends Product{
    Audio() {super(50);}
    public String toString() {return "Audio";}
}
class Buyer{
    int money = 1000;
    int bonusPoint = 0;
    //  Product[] item = new Product[10];  이 배열 대신 Vector()사용
    Vector item = new Vector();  // 구입한 제품을 저장하는데 사용될 Vector객체
    void buy(Product p){
        if(money < p.price){
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }
        money -= p.price;
        bonusPoint +=p.bonusPoint;
        item.add(p);
        System.out.println(p+"을/를 구입하셨습니다.");
    }
    void refund(Product p){     // 환불
        if(item.remove(p)){
            money +=p.price;
            bonusPoint -=p.bonusPoint;
            System.out.println(p+"을/를 반품하셨습니다.");
        }else{  // 제거에 실패한 경우
            System.out.println("구입하신 제품 중 해당 제품이 없습니다.");
        }
    }
    void summary(){
        int sum = 0;
        String itemList = "";
        if(item.isEmpty()){
            System.out.println("구입하신 제품이 없습니다.");
            return;
        }

        for(int i=0; i<item.size();i++){
            Product p = (Product)item.get(i);
            sum += p.price;
            itemList += (i==0) ? "" + p :  "," + p;
        }
        System.out.println("구입하신 물픔의 총금액은 "+ sum+"만원입니다.");
        System.out.println("구입하신 제품은 "+itemList+"입니다.");
    }
}


class PolyArgumentTest3 {
    public static void main(String[] args) {
        Buyer b= new Buyer();
        Tv tv = new Tv();
        Computer com = new Computer();
        Audio audio = new Audio();

        b.buy(tv);
        b.buy(com);
        b.buy(audio);
        b.summary();
        System.out.println();
        b.refund(com);
        b.summary();
    }
}
```

### 6. 추상클래스(abstract class)

---

#### 6.1 추상클래스란?

클래스 : 설계도 

추상클래스 : 미완성 설계도(추상메서드를 포함하고 있다는 의미)

추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 가진다. 새로운 클래스를 작성할 때 아무 것도 없는 상태에서 시작하는 것보다는 완전하지는 못하더라도 어느 정도 틀을 갖춘상태에서  시작하는 것이 나을 것이다.

실생활 예) 같은 크기의 TV라도 기능의 차이에 따라 여러 종류의 모델이 있지만 이들의 설계도는 90퍼센트 정도 동일할 것이다. 서로 다른 세 개의 설계도를 따로 그리는 것보다는 공통부분만을 그린 미완성 설계도를 만들어 놓고, 이 미완성 설계도를 이용해서 각각의 설계도를 완성하는 것이 훨씬 효율적이다.

추상 클래스 선언법 : `abstract class 클래스이름{ }` 

#### 6.2 추상메서드(abstract method)

```
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
abstract 리턴타입 메서드이름();
```

메서드를 미완성 상태로 남겨 놓는 이유는 상속받는 클래스에 따라 메서드의 내용이 달라질 수 있기 때문에 주석과 함께 어떤 기능을 수행할 목적으로 작성되었는지 알려주고 실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것이다.



추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야한다.

만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.

```java
abstract class Player{	// 추상클래스
	abstract void play(int pos);	// 추상메서드
	abstract void stop();			// 추상메서드
}

class AudioPlayer extends Player{
	void play(int pos){	/* 내용 생략 */ }	// 추상메서드를 구현
	void stop()	{ /* 내용 생략 */ }			// 추상메서드를 구현
}
abstract class AbstractPlayer extends Player{
	void play(int pos) { /* 내용 생략 */ }  // 추상메서드를 구현
}
```

메서드를 사용하는 쪽에서는 메서드가 실제로 어떻게 구현되어있는지 몰라도 메서드의 이름과 매개변수,리턴타입, 즉 선언부만 알고 있으면 되므로 내용이 없을 지라도 추상메서드를 사용하는 코드를 작성하는 것이 가능하며, 실제로는 자손클래스에 구현된 완성된 메서드가 호출되도록 할 수 있다.

#### 6.3 추상클래스의 작성

```
추상의 정의 : 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용
```

```
추상화	: 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
```

Player 클래스는 VCR이나 Audio같은 재생 가능한 기기를 클래스로 작성할때, 이들의 조상으로 사용될 수 있을 것이다.

```java
abstract class Player{
	boolean pause;		// 일시정지 상태를 저장하기 위한 변수
	int currentPos;		// 현제 Play되고 있는 위치를 저장하기 위한 변수
    
    Player(){			// 추상클래스도 생성자가 있어야 한다.
    	pause = false;
    	currentPos = 0;
    }
    /* 지정된 위치에서 재생을 시작하는 기능이 수행하도록 작성 되어야 한다.*/
    abstract void play(int pos);	// 추상메서드
    /* 재생을 즉시 멈추는 기능을 수행하도록 작성되어야 한다.*/
    abstract void stop();			// 추상메서드
    
    void play(){
    	play(currentPos);		// 추상메서드 사용가능
    }
    void pause(){
    	if(pause){				// pause가 true일때(정지상태) 
    		pause = false;		// pause의 상태를 false로 바꾸고,
    		play(currentPos);	// 현재의 위치에서 play
    	}
    	else{					// pause가 false일때
    		pause = true;		// pause 상태를 true로 바꾸고,
    		stop();				// play를 멈춘다.			
    	}
    }
}
```

Player클래스를 조상으로 하는 CDPlayer클래스

```java
class CDPlayer extends Player{
	void play(int currentPos){
		/* 조상의 추상메서드를 구현. 내용생략 */
	}
	void stop(){
		/* 조상의 추상메서드를 구현. 내용생략*/
	}
	
	// CDPlayer클래스에 추가로 정의된 멤버
	int currentTrack;	// 현재 재생 중인 트랙
	
	void nextTrack(){
		currentTrack++;
			...
	}
	void preTrack(){
		if(currentTrack>1){
			currentTrack--;
		}
		...
	}
}
```

어차피 자손 클래스에서 오버라이딩하여 자신의 클래스에 맞게 구현할 테니 추상메서드로 선언하는 것과 내용없는 빈 몸통만 만들어 놓는 것 이나(예시 : `void play(int pos)  { }`) 별 차이가 없어보이지만 굳이 abstract를 붙여서 추상메서드로 선언하는 이유는 

**자손 클래스에서 반드시 구현하도록 강요하기 위해서이다.**

추상메서드가아닌 빈몸통만 가지도록 정의되어 있다면 상속받는 자손 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있어서



공통 부분 뽑아내서 추상클래스 만드는 예제

```java
class Marine{		// 보병
	int x,y;		// 현재 위치
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void stop()				{ /* 현재 위치에 정지 */  	 }
	void stimPack()			{ /* 스팀팩을 사용한다.*/	}
}
class Tank{			// 탱크
	int x,y;		// 현재 위치
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void stop()				{ /* 현재 위치에 정지 */  	 }
	void changeMode()		{ /* 공격모드를 변환한다.*/  }
}
class DropShip{		// 수송선
	int x,y;		// 현재 위치
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void stop()				{ /* 현재 위치에 정지 */  	 }
	void load()				{ /* 선택된 대상을 태운다.*/ }
	void unload()			{ /* 선택된 대상을 내린다.*/ }
}
```

공통부분을 뽑아내어 Unit클래스로부터  상속받도록 변경

이 Unit 클래스는 다른 유닛을 위한 클래스를 작성하는데 재활용될 수 있을 것이다.

```java
abstract class Unit{
	int x,y;		// 현재 위치
	abstract void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void stop()				{ /* 현재 위치에 정지 */  	 }
}
class Marine extends Unit{
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void stimPack()			{ /* 스팀팩을 사용한다.*/	}
}
class Tank extends Unit{
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void changeMode()		{ /* 공격모드를 변환한다.*/  }
}
class Dropship extends Unit{
	void move(int x, int y)	{ /* 지정된 위치로 이동 */  }
	void load()				{ /* 선택된 대상을 태운다.*/ }
	void unload()			{ /* 선택된 대상을 내린다.*/ }
}
```

stop메서드는 선언부와 구현부 모두 공통적이지만, Marine, Tank는 지상유닛이고 Dropship은 공중유닛이기 때문에 이동하는 방법이 서로 달라서 move메서드의 실제 구현 내용이 다를 것이다. 그래도 move메서드의 선언부는 같기 때문에 추상메서드로 정의할 수 있다.

최대한 공통 부분을 뽑아내기 위한 것이기도 하지만, 모든 유닛은 이동할 수 있어야 하므로 Unit클래스에는 move메서드가 반드시 필요한 것이기 때문이다. 

```
따라서 move메서드가 추상메서드로 선언된 것에는, 앞으로 Unit클래스를 상속받아서 작성되는 클래스는 mvoe메서드를 자신의 클래스에 알맞게 반드시 구현해야 한다는 의미가 담겨있다.
```

``` java
/* 
Unit클래스에 move메서드가 비록 추상메서드로 정의되어 있다 하더라도 이처럼 Unit클래스 타입의 참조변수로
move메서드를 호출하는 것이 가능하다. 메서드는 참조 변수의 타입에 관계없이 실제 인스턴스에 구현된 것이 호출되기 때문이다.
*/

Unit [] group = new Unit[4];	// 다형성 : 조상 클래스타입의 참조변수로 자손클래스의 인스턴스를 참조하는것이 가능
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Marine();
group[3] = new Dropship();

for(int i=0;i<group.length;i++){
	group[i].move(100,200);	// Unit배열의 모든 유닛을 좌표(100,200)의 위치로 이동한다.
}
```

모든 클래스의 조상인 Object클래스 타입의 배열로도 서로 다른 종류의 인스턴스를 하나의 묶음으로 다룰 수 있지만, Object클래스에는 move메서드가 정의되어 있지 않기 때문에 move메서드를 호출하는 부분에서 에러가 발생한다.

```
Object[] group = new Object[4];
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Marine();
group[3] = new Dropship();
```



### 7. 인터페이스(interface)

---

#### 7.1 인터페이스란?

일종의 추상클래스, 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있다.

인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려저 있는 `기본 설계도`이다. (추상클래스는 부분적으로 완성된 `미완성 설계도`)

#### 7.2 인터페이스의 작성

```
interface 인터페이스이름{
	public static final 타입 상수이름 = 값;
	public abstract 메서드이름(매개변수목록);
}
```

-제약사항

```
- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
  단, static메서드와 디폴트 메서드는 예외(JDK1.8부터)
```

예시

```java
interface PlayingCard{
	public static final int SPADE = 4;
	final int DIAMOND = 3;	// public static final int DIAMOND = 3;
	static int HEART = 2;  // public static final int HEART = 2;
	int CLOVER = 1; 		// publi static final int CLOVER = 1;
	
	public abstract String getCardNum();
	String getCardKind();	// public abstract String getCardKind();
}
```

원래 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK 1.8 부터 인터페이스에 static메서드와 디폴트 메서드(default method)의 추가를 허용하는 방향으로 변경됨

#### 7.3 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을수 있다.
- 클래스와 달리 다중상속 허용

```java
interface Movable{
	/* 지정된 위치(x,y)로 이동하는 기능의 메서드 */
	void move(int x, int y);
}
interface Attackable{
	/* 지정된 대상(u)을 공격하는 기능의 메서드 */
	void attack(Unit u);
}
interface Fightable extends Movalbe, Attackable{}
```

자손 인터페이스 Fightable은 조상 인터페이스에 정의된 멤버를 모두 상속받는다.

#### 7.4 인터페이스의 구현

- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성 할 수 없으며 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다.



이때 Fighter 클래스는 Fightable인터페이스를 구현한다 라고한다.

```java
class 클래스이름 implements 인터페이스이름{
	// 인터페이스에 정의된 추상메서드를 구현해야 한다.
}
class Fighter implements Fightalbe{
	public void move(int x, int y){	/* 내용 생략 */ }
	public void attack(Unit U)	  { /* 내용 생략 */ }
}
```

만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstarct를 붙여서 추상클래스로 선언해야한다.

```java
abstract class Fighter implements Fightalbe{
	public void move(int x, int y){	/* 내용 생략 */ }
}
```

다음과 같이 상속과 구현을 동시에 할 수도 있다.

```java
class Fighter extends Unit implements Figtalbe{
	public void move(int x, int y){	/* 내용 생략 */ }
	public void attack(Unit U)	  { /* 내용 생략 */ }
    /* 오버라이딩 할 때 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 하므로 인터페이스가 Public abstract이니
      반드시 Fighter 클래스에서 제어자를 public으로 해야 한다.
    */
}
```

참고

```
인터페이스의 이름에는 주로 Fightable과 같이 ~을 할 수 있는의 의미인 able로 끝나는 것들이 많은데, 그이유는 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다. 또한 그 인터페이스를 구현한 클래스는 ~를 할 수 있는 능력을 갖추었다는 의미이기도 하다. 
그러나 모든 인터페이스의 이름이 able로 끝나야 하는 것은 아님
```

#### 7.5 인터페이스르 이용한 다중상속

자바에서는 다중상속을 허용 하지는 않지만 C++에서는 허용하므로 단점 부각되는 것에 대한 대응으로 <u>인터페이스를 이용하면 다중상속이 가능하다</u>라고 하는 것일뿐 거의 다중상속을 구현하지 않는다.



만일 두 개의 클래스로부터 상속을 받아야 할 상황이라면, 두 조상클래스 중에서 비중이 높은 쪽을 선택하고 다른 한쪽은 클래스 내부에 멤버로 포함시키는 방식으로 처리하거나 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현하도록 한다.

예를들어, Tv,VCR클래스가 있을때, TVCR클래스를 작성하기위해 두 클래스로부터 상속을 받을 수만 있으면 좋겠지만 허용하지 않으므로 한쪽만 선택하여 상속받고 나머지 한 쪽은 클래스 내에 포함시켜서 내부적으로 인스턴스를 생성해서 사용하도록 한다.

```java
public class Tv{
	protected booelan power;
	protected int channel;
	protected int volume;
	
	public void power()		 {power = !power;}
	public void channelUp()  {channel++;}
	public void channelDown(){channel--;}
	public void volumeUp()   {volume++;}
	public void volumeDown() {volume--;}
}
public class VCR{
	protected int counter;
	public void play(){ // 테이프를 재생한다.}
	public void stop(){ // 재생을 멈춘다.}
	public void reset(){ counter = 0;}
	public int getCounter(){ reuturn counter;}
	public void setCounter(int c){ counter = c; }
}
```

VCR클래스에 정의된 메서드와 일치하는 추상메서드를 갖는 인터페이스를 작성한다.

```java
public interface IVCR{
	public void play();
	public void stop();
	public void reset();
	public int getCounter();
	public void setCounter(int c);
```

이제 IVCR엔터페이스를 구현하고 Tv클래스로부터 상속받는 TVCR클래스 작성

VCR클래스 타입의 참조변수를 멤버변수로 선언하여 IVCR인터페이스의 추상메서드를 구현하는데 사용

```java
public class TVCR extends Tv implements IVCR{
	VCR vcr = new VCR();	
	public void play(){
		vcr.play();
	}
	public void stop(){
		vcr.stop();
	}
	public void reset(){
		vcr.reset();
	}
	public int getCounter(){
		return vcr.getCounter();
	}
	public void setCounter(int c){
		vcr.setCounter(c);
	}
}
```

이처럼 VCR클래스의 인스턴스를 사용하면 손쉽게 다중상속을 구현할 수 있다. 또한 VCR클래스의 내용이 변경되어도 변경된 내용이 TVCR클래스에도 자동적으로 반영됨.

사실 인터페이스를 새로 작성하지 않고 VCR클래스를 TVCR클래스에 포함시키는 것만으로도 충분하지만, 인터페이스를 이용하면 다형적 특성을 이용할 수 있다.

#### 7.6 인터페이스를 이용한 다형성

인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능

```java
interface Fightable{}
class Fighter implements Fightable{}

// 다음과 같이 참조가능

Fightable f = (Fightable)new Fighter();
			또는
Fightable f = new Fighter();
```

- 매개변수 타입으로 인터페이스를 사용

  - 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다.

  ```java
  void attack(Fightable f){
  	// ..
  }
  
  // attack(new Figther())와 같이 매개변수로 Fighter(Fightalbe 인터페이스를 구현한 클래스)인스턴스를 넘겨 줄 수있다.
  ```

- 메서드 리턴타입으로 인터페이스를 사용

  - 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미

  ```java
  Fightable method(){
  	...
  	Fighter f = new Fighter();
  	return f;
  	// return new Fighter();
  }
  ```

예제

```java
interface Parsealbe{		// 구문분석을 수행하는 기능을 구현할 목적으로 만들어짐
    // 구문 분석작업을 수행한다
    public abstract void parse(String fileName);
}
class ParserManger{			// 매개변수의 type의 값에 따라 XMLParser인스턴스 또는 HTMLParser인스턴스를 반환
    // 리턴타입이 Parseable인터페이스이다.
    public static Parsealbe getParser(String type){
            if(type.equals("XML")){
                 return new XMLParser();
        }else{
            return new HTMLParser();
        }
    }
}
class XMLParser implements Parsealbe{			// Parsealbe인터페이스를 구현
    public void parse(String fileName){
        System.out.println(fileName+"-XML parsing completed.");
    }
}
class HTMLParser implements Parsealbe{			// Parsealbe인터페이스를 구현
    public void parse(String fileName){
        System.out.println(fileName+"-HTML parsing completed.");
    }
}
class ParseTest{
    public static void main(String[] args) {
        Parsealbe parser = ParserManger.getParser("XML");
        parser.parse("document.xml");
        parser = ParserManger.getParser("HTML");
        parser.parse("document2.html");
    }
}
```

만일 나중에 새로운 종류의 XML구문분석기 NewXMLPaser클래스가 나와도 ParserTest클래스는 변경할 필요 없이 ParserManger클래스의 getParser메서드에서 `return new XMLParser();` 대신 `return new NewXMLParser();`로 변경하기만 하면 된다.

#### 7.7 인터페이스의 장점

1. 개발시간을 단축시킬 수 있다.
   - 일단 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 하면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다. 
2. 표준화가 가능하다
   - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
   - 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
4. 독립적인 프로그래밍이 가능하다.
   - 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그램이 가능하다.

---

#### 인터페이스의 장점 예시1

한데이터베이스 회사가 제공하는 특정 데이터베이스를 사용하는데 필요한 클래스를 사용해서 프로그램을 작성했다면 이 프로그램은 다른 종류의 데이터베이스를 사용하기 위해서는 전체 프로그램중에서 데이터베이스 관련된 부분은 모두 변경해야할 것이다.

그러나 데이터베이스 관련 인터페이스를 정의하고 이를 이용해서 프로그램을 작성하면, 데이터베이스의 종류가 변경되더라도 프로그램을 변경하지 않도록 할 수 있다. 단 , 데이터베이스 회사에서 제공하는 클래스도 인터페이스를 구현하도록 요구해야 한다. 데이터베이스 회사에서는 인터페이스를 구현한 클래스를 작성해서 제공해야한다.

#### 인터페이스의 장점 예시2

게임에 나오는 유닛을 클래스로 표현하고 이들의 관계를 상속계층도로 표현해봤다.



<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/af7ce338-bf7b-45b5-9c5d-8e1cc0ce37f6" height="300px" width="500px">

SCV에게 Tank와 Dropship같은 기계화 유닛을 수리할 수 있는 기능을 제공하기 위해 repair메서드를 정의한다면 다음과 같을 것이다.

```java
void repair(Tank t){
	// Tank를 수리한다.
}
void repair(Dropship d){
	// Dropship을 수리한다.
}
```

이런 식으로 수리가 가능한 유닛의 개수만큼 다른 버전의 오버로딩된 메서드를 정의해야 할 것이다. 이것을 피하기 위해 매개변수의 타입을 이 들의 공통 조상으로 하면 좋겠지만 Dropship은 공통조상이 다르기 때문에 공통조상의 타입으로 메서드를 정의한다고 해도 최소한 2개의 메서드가 필요할 것이다.

```java
void repair(GroundUnit gu){
	// 매개변수로 넘겨진 지상유닛을 수리한다.
}
void repair(AirUnit au){
	// 매개변수로 넘겨진 공중유닛을 수리한다.
}
```

그리고 GroundUnit의 자손중에는 Marine과 같이 기계화 유닛이 아닌 클래스도 포함될 수 있기 때문에 repair메서드의 매개변수 타입으로 GroundUnit은 부적합하다. 현재의 상속관계에서는 이들의 공통점이 없기에 이 때 인터페이스를 이용하면 기존의 상속체계를 유지하면서 이들 기계화 유닛에 공통점을 부여할 수 있다.

다음과 같이 Repairable이라는 인터페이스를 정의하고 수리가 가능한 기계화 유닛에게 인터페이스를 구현하도록 하면된다.

```java
interface Repairable {}

class SCV extends GroundUnit implements Repairalbe{
	//...
}
class Tank extends GroundUnit implements Repairalbe{
	//...
}
class Dropship extends AirUnit implements Repairalbe{
	//...
}
```

이제 같은 인터페이스를 구현했다는 공통점이 생김. 인터페이스에 정의된 것은 아무것도 없고, 단지 인스턴스의 타입 체크에만 사용

그리고 repair메서드의 매개변수의 타입을 Repairable로 선언하면, 이 메서드의 매개변수로 Repairable인터페이스를 구현한 클래스의 인스턴스만 받아들여질 것이다.

```java
void repair(Repairable r){
	// 매개변수로 넘겨받은 유닛을 수리한다.
}
```

#### 인터페이스 장점 예시3

게임에 나오는 건물들을 클래스로 표현하고 이들의 관계를 상속계층도로 표현하였다.

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/14d224ab-33a2-41ce-8e51-88e188fe9514" height="300px" width="500px">

이때 Barrack클래스와 Factory클래에 건물을 이동시킬 수 있는 새로운 메서드를 추가하고자 한다.

```java
void liftOff()				{ /* 내용생략 */ }
void move(int x, int y)		{ /* 내용생략 */ }
void stop()					{ /* 내용생략 */ }
void land()					{ /* 내용생략 */ }
```

위 코드를 두클래스에 모두 적어주면 되지만, 코드가 중복된다는 단점이 있다. 그렇다고 해서 조상클래스인 Building클래스에 코드를 추가해주면 Academy와 Bunker클래스도 추가된 코드를 상속받으므로 안된다.

이런경우에도 인터페이스를 이용해서 해결한다.

```java
interface Liftable{
	/** 건물을 들어 올린다. */
	void liftOff();
	/** 건물을 이동한다. */
	void move(int x, int y);
	/** 건물을 정지시킨다. */
	void stop();
	/** 건물을 착륙시킨다. */
	void land();
}

class LiftalbeImpl implements Liftable{
	public void liftOff()				{ /* 내용생략 */ }
	public void move(int x, int y)		{ /* 내용생략 */ }
	public void stop()					{ /* 내용생략 */ }
	public void land()					{ /* 내용생략 */ }
}
```

Barrack클래스가 Lifatable인터페이스를 구현하도록 하고, 인터페이스를 구현한 LiftableImpl클래스를 Barrack클래스에 포함시켜서 내부적으로 호출해서 사용하도록 한다. 이렇게 함으로써 같은 내용의 코드를 Barrack클래스와 Factory클래스에서 각각 작성하지 않고 LiftableImpl클래스 한 곳에서 관리할 수 있다. 그리고 작성된 Liftable인터페이스와 이를 구현한 LiftableImpl클래스는 후에 다시 재사용될 수 있을 것이다.

```java
class Barrack extends Building implements Liftable{
	LiftableImpl 1 = new LiftableImpl();
	void liftOff()				{ 1.liftOff(); }
	void move(int x, int y)		{ 1.move(x,y); }
	void stop()					{ 1.stop(); }
	void land()					{ 1.land(); }
	void trainMarine()			{/* 내용생략 */}
}
class Factory extends Building implements Liftable{
	LiftableImpl 1 = new LiftableImpl();
	void liftOff()				{ 1.liftOff(); }
	void move(int x, int y)		{ 1.move(x,y); }
	void stop()					{ 1.stop(); }
	void land()					{ 1.land(); }
	void makeTank()				{ /* 내용생략 */ }
}
```

#### 7.8 인터페이스의 이해

인터페이스를 이해하기 위해서는 다음의 두 가지 사항을 반드시 염두해야한다.

```
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.(내용은 몰라도 된다.)
```

```java
class A{
	public void methodA(B b){
		b.method();
	}
}
class B{
	public void methodB(){
		System.out.println("methodB()");
	}
}
class InterfaceTest{
	public static void main(String [] args){
		A a = new A();
		a.methodA(new B());
	}
}
```

다음과 같이 A,B클래스가 있을때 클래스 A(User)는 클래스 B(Provider)의 인스턴스를 생성하고 메서드를 호출한다. 이 두클래스는 서로 직접적인 관계에있다. 이 경우 클래스 A를 작성하려면 클래스 B가 이미 작성되어 있어야 한다. 그리고 클래스B의 methodB()의 선언부가 변경되면, 이를 사용하는 클래스 A도 변경되어야 한다. 이와 같이 직접적인 관계의 두 클래스는 한쪽이 변경되면 다른 한쪽도 변경되어야 한다는 단점이있다. 그러나 클래스 A가 클래스 B를 직접 호출하지 않고 인터페이스를 매개체로 해서 클래스A가 인터페이스를 통해서 클래스 B의 메서드에 접근하도록 하면, 클래스 B에 변경사항이 생기거나 클래스 B와 같은 기능의 다른 클래스로 대체 되어도 클래스 A는 전혀 영향을 받지 않도록 하는 것이 가능하다. 두클래스간의 관계를 간접적으로 변경하기 위해서는 먼저 인터페이스를 이용해서 클래스B(Provider)의 선언과 구현을 분리해야한다.

```java
interface I{
	public abstract void methodB();
}
class B implements I{
	public void methodB(){
		System.out.println("methodB in B class");
	}
}
```

이제 A는 클래스 B대신 인터페이스 I를 사용해서 작성 가능

```java
class A{
	public void method(I i){
		i.methodB();
	}
}
```

클래스 A를 작성하는데 클래스B가 사용되지 않았다. 이제 A-B 직접적인 관계에서 A-I-B의 간접적인 관계로 바뀌었다 클래스 A는 클래스 B의 변경에 영향을 받지 않는다. 이제 클래스A는 인터페이스를 통해 실제로 사용하는 클래스의 이름을 몰라도되고 실제로 구현된 클래스가 존재하지 않아도 문제x 클래스A는 오직 인터페이스I의 영향만 받음

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/0a4612b2-78ca-49d8-827b-7271b81205b1" height="300px" width="500px">

#### 매개변수를 통해서 인터페이스  I를 구현한 클래스의 인스턴스를 동적으로 제공받는 예제

클래스 Thread의 생성자인 Thread(Runnable target)이 이런 방식으로 되어 있다.

```java
class A{
    void autoPlay(I i){
        i.play();
    }
}
interface I{
    public abstract void play();
}
class B implements I{
    public void play(){
        System.out.println("play in B class");
    }
}
class C implements  I{
    public void play(){
        System.out.println("play in C class");
    }
}

class InterfaceTest2{
    public static void main(String[] args) {
        A a =new A();
        a.autoPlay(new B());    // void autoPlay(I i)호출
        a.autoPlay(new C());    // void autoPlay(I i)호출
    }
}
```

#### 제 3의 클래스를 통해서 제공받는 예제

JDBC의 DriverManager클래스가 이런 방식으로 되어있다.

```java
class IntefaceTest3 {
    public static void main(String[] args) {
        A a =new A();
        a.methodA();
    }
}
class A{
    void methodA(){
        I i = InstanceManger.getInstance();
        i.methodB();
        System.out.println(i.toString());
    }
}
interface I{
    public abstract void methodB();
}
class B implements I{
    public void methodB(){
        System.out.println("methodB in B class");
    }
    public  String toString(){return "class B";}
}
class InstanceManger{
    public static I getInstance(){
        return new B();
    }
}
```

인스턴스를 직접 생성하지 않고, getInstance()메서드를 통해 제공받는다. 이렇게 하면, 나중에 다른 클래스의 인스턴스로 변경되어도 A클래스의 변경없이 getInstance()만 변경하면 된다.

```java
class InstanceManger{
    public static I getInstance(){
        return new B();			// 다른 인스턴스로 바꾸려면 여기만 변경하면 됨
    }
}
```

그리고 인터페이스 I타입의 참조변수 i로도 Object클래스에 정의된 메서드들을 호출 할 수 있다. i에 toString()이 정의되어 있지 않지만, 모든 객체는 Object클래스에 정의된 메서드를 가지고 있을 것이기에 허용한다.

```java
class A{
    void methodA(){
        I i = InstanceManger.getInstance();
        i.methodB();
        System.out.println(i.toString());		// i로도 Object의 메서드 호출가능, 인터페이스도 객체이다
    }
}
```

#### 7.9 디폴트 메서드와 static메서드

원래는 인터페이스에 추상 메서드만 선언할 수 있는데,  JDK1.8부터 디폴트 메서드와 static메서드도 추가할 수 있게 됨

**static메서드**

- 접근 제어자가 항상 public이며, 생략할 수 있다.

**디폴트 메서드**

- 인터페이스가 변경되지 않으면 좋지만, 아무리 설계를 잘해도 언젠가 변경은 발생함. 인터페이스에 메서드를 추가하는것은 추상 메서드를 추가한다는 것이고, 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야한다. 그래서 default메서드를 고안함

- 추상메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 <u>디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.</u>

- 앞에 키워드 default를 붙이며, 추상메서드와 달리 일반 메서드처럼 몸통{ }이 있어야한다. 접근제어자는 public이며 생략가능

  ```java
  interface Myinterface{
  	void method();
  	default void newMethod(){}	// default 메서드 추가(Myinterface를 구현한 클래스를 변경하지 않아도됨)
  }
  ```

  새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우가 발생. 이 충돌을 해결하는 규칙

  ```
  1. 여러 인터페이스의 디폴트 메서드 간의 충돌
  	- 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
  2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
  	- 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
  ```

  예제

  ```java
  class DefaultMethodTest {
      public static void main(String[] args) {
          Child c = new Child();					
          c.method1();									
          c.method2();  // 규칙2에 의해 조상Parent클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
          Myinterface.staticMethod();
          Myinterface2.staticMethod();
      }
  }
  class Child extends Parent implements Myinterface,Myinterface2{
      /* Myinterface와 Myinterface2의 디폴트 메서드 간의 충돌을 해결하기 위해 인터페이스를 구현한 Child
   	  클래스에서 디폴트 메서드(method1())을 오버라이딩 함
   	 */
      public void method1() {						
          System.out.println("method1() in Child");
      }
  }
  class Parent{
      public void method2(){			// 디폴트 메서드와 겹침
          System.out.println("method2() in Parent");
      }
  }
  
  interface Myinterface{
      default void method1(){
          System.out.println("method()1 int Myinteface");
      }
      default void method2(){						// 조상메서드와 겹침
          System.out.println("method()2 int Myinteface");
      }
      static void staticMethod(){
          System.out.println("staticMethod() in Myinterface");
      }
  }
  interface Myinterface2{
      default void method1(){
          System.out.println("method()1 int Myinteface2");
      }
      static void staticMethod(){
          System.out.println("staticMethod() in Myinterface2");
      }
  }
  /* 결과
  method1() in Child
  method2() in Parent				규칙2 결과물
  staticMethod() in Myinterface
  staticMethod() in Myinterface2
  */
  ```


### 8. 내부 클래스(inner class)

---

#### 8.1 내부 클래스란?

클래스 내에 선언된 클래스. 클래스에 다른 클래스를 선어하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

```
내부 클래스의 장점
- 내부 클래스에서 외부 클래스의 멤버를 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다.(캡슐화)
```

```java
class A{
	int i;
    B b = new B();
}
// B클래스에서 A클래스의 멤버를 사용하려면 객체를 만들어야함
class B{
	void method(){
        A a = new A();
        System.out.print(a.i);
    }
}
class C{
    B b =new B();
}
public class InnerTest{
    public static void main(String[] args){
     	B b = new B();
   		b.method();  
    }
}
```

내부 클래스인 B는 외부 클래스 A를 제외하고는 다른 클래스에서 잘 사용되지 않는 것이어야 한다.

```java
class A{		// A는 B의 외부 클래스
	int i;
    B b = new B();
    
    // B클래스가 A클래스 안에서만 쓰이면 안에 넣는게 좋음(캡슐화)
    class B{		// B는 A의 내부 클래스
		void method(){
     //  	A a = new A();
     //   	System.out.print(a.i);
            System.out.print(i);	// 객체 생성없이 외부 클래스멤버에 접근가능
    }
}
class C{
    
//  B b =new B();  에러, B클래스는 A의 클래스안에서만 사용가능(물론 방법이있긴함)
}
public class InnerTest{
    public static void main(String[] args){
     // B b = new B();
     // b.method();   불가능
        A a = new A();	// B의 외부 클래스 A의 객체를 생성하고 사용가능
    }
}
```

#### 8.2 내부 클래스의 종류와 특징

| 내부 클래스                     | 특징                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 인스턴스 클래스(instance class) | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다. |
| 스태틱 클래스(static class)     | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다. |
| 지역 클래스(local class)        | 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다. |
| 익명 클래스(annoymous class)    | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용) |

#### 8.3 내부 클래스의 선언

```java
class Outer{
	class InstanceInner{}		// 인스턴스 클래스
	static class StaticInner{}	// static 클래스
	
	void myMethod(){
		class LocalInner{}		// 지역 클래스
	}
}
```

#### 8.4 내부 클래스의 제어자와 접근성

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/2d0d2c19-eff8-4d96-be95-6dd1409facc7" height="300px" width="600px">

static class가아니면 객체를 생성해야 멤버들을 사용할수 있는데, 그 class안에 static 멤버들은 객체 생성없이 사용할 수있는데 여기서 모순이 발생한다. <u>그래서 static 클래스만 static멤버를 가질 수 있다</u>.

단, final static 의 경우 static 이긴 하지만 모든 외부 객체가 가지는 내부객체에 존재하는 final static 필드가 동일한 값을 가지게 된다는 보장이 있고, 그렇게 된다면 <u>개</u><u>념적으로는 메모리상에 단 하나만 존재하는 것과 같은 효과를 낼 수 있다. 그래서 final static 만 허용한다.</u>

<참고>자바 16부터는 내부 클래스에서 정적 멤버를 선언할 수 있습니다

```java
class InnerEx1 {
    class InstanceInner{    // 인스턴스 내부 클래스
        int iv = 100;
        //  static int cv = 100;    
        final static int CONST = 100;   // fianl static은 상수이므로 허용
    }
    static class StaticInner{       // static 내부 클래스
        int iv = 200;
        static int cv =200;         // static 내부 클래스만 static멤버를 정의할 수 있다.
    }
    void myMethod(){
        class LocalInner{           // 지역 클래스
            int iv =300;
         //   static int cv = 300;       
            final static int CONST = 300;       // final static은 상수이므로 허용
        }
        int i = LocalInner.CONST;   // 가능
    }

    public static void main(String[] args) {
        System.out.println(InstanceInner.CONST);
        System.out.println(StaticInner.cv);
      //System.out.println(LocalInner.CONST)   에러, 지역 내부 클래스는 그 메서드 안에서만 사용가능
    }
}
```

```java
class InnerEx2 {
    class InstatnceInner{}
    static class StaticInner{}

    // 인스턴스멤버는 같은 클래스에 있는 인스턴스멤버와 static멤버 모두 직접 접근이 가능하다.
    InstatnceInner iv = new InstatnceInner();
    StaticInner iv2 = new StaticInner();
    
    // static 멤버는 static멤버 간에만 서로 직접 접근이 가능하다.
    static StaticInner cv = new StaticInner();
 // static InstatnceInner cv2 = new InstatnceInner();  에러, static멤버에서 instance멤버 접근
    
    static void staticMethod(){
        // static멤버는 인스턴스멤버에 접근할 수 없다.
     // InstatnceInner oj1 = new InstatnceInner();
        StaticInner obj2 = new StaticInner();

        // 굳이 접근하려면 아래와 같이 객체를 생성해야 한다.
        // 인스턴스클래스는 외부 클래스를 먼저 생성해야만 생성할 수 있다.
        InnerEx2 outer = new InnerEx2();
        InstatnceInner obj1 = outer.new InstatnceInner();
    }
    void instanceMethod(){
        // 인스턴스메서드에서는 인스턴스멤버와 static멤버 모두 접근 가능하다.
        InstatnceInner obj1 = new InstatnceInner();
        StaticInner obj2 = new StaticInner();
        // 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근할 수 없다.
     // LocalInner lv = new LocalInner();

    }
    void myMethod(){
        class LocalInner{}
        LocalInner lv = new LocalInner();
    }
}

```

```java
class InnerEx3 {
    private int outerIv = 0;
    static  int outerCv = 0;

    class InstanceInner{
        /* private는 같은 클래스 내에서만 접근가능하지만, private 변수가 선언된 외부클래스(InnerEx3)안에
        있는것과 똑같이 내부클래스도 외부 클래스(InnerEx3)안에 있기에 접근제어자가 private여도 사용가능
        */
        int iiv  = outerIv;  // 외부 클래스의 private멤버도 접근가능하다.
        int iiv2 = outerCv;
    }
    static class StaticInner{
        //  static클래스는 외부 클래스의 인스턴스 멤버에 접근 불가
        // int siv = outerIv;
        static int scv= outerCv;
    }
    void myMethod(){
        int lv = 0;
        final int Lv = 0; // JDK 1.8부터 final 생략 가능

        class LocalInner{	// 지역 내부 클래스를 감싸고 있는 메서드의 상수만 사용이 가능
            
            /* 이유는 메서드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가 
            소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 떄문이다. */
            
            int liv = outerIv;
            int liv2 = outerCv;
            
            // 외부클래스의 지역변수는 fianl이 붙은 변수(상수)만 접근이가능
            int liv3 = lv;// 에러!(JDK1.8부터 에러가 아님, 왜냐하면 lv의 값이 변하지 않았기에 final이 생략된것으로 침)
            int liv4 = Lv;//OK
            
            /* 참고
            JDK1.8부터 지역 클래스에서 접근하는 지역 변수 앞에 fianl을 생략할 수 있게 바뀌었다. 
            컴파일러가 자동으로 붙여줌, 만약 해당 변수의 값이 바뀌는 문장이 있으면 컴파일 에러가 발생
            */
        }
    }
}
```

외부 클래스가 아닌 다른클래스에서 내부 클래스를 생성하고 내부 클래스의 멤버에 접근하는 예제. 실제로 이런경우가 발생했다는 것은 내부 클래스로 선언해서는 안 되는 클래스를 내부 클래스로 선언한것!! 참고용으로만 보자

```java
class Outer{
    class InstanceInner{
        int iv = 100;
    }
    static class StaticInner{
        int iv =200;
        static int cv = 300;
    }
    void myMethod(){
        class LocalInner{
            int iv =400;
        }
    }
}


class InnerEx4 {
    public static void main(String[] args) {
        // 인스턴스클래스의 인스턴스를 생성하려면 외부 클래스의 인스턴스를 먼저 생성해야 한다.
        Outer oc = new Outer();
        Outer.InstanceInner ii = oc.new InstanceInner();

        System.out.println("ii.iv = "+ii.iv);
        System.out.println("Outer.StaticInner.cv : "+Outer.StaticInner.cv);

        // 스태틱 내부 클래스의 인스턴스는 외부 클래스를 먼저 생성하지 않아도 된다.
        Outer.StaticInner si = new Outer.StaticInner();
        System.out.println("si.iv : "+si.iv);

    }
}
```

-컴파일 시 생성되는 클래스 파일

- InnerEx4.class
- Outer.class
- Outer$InstanceInner.class
- Outer$StaticInner.class
- Outer$1LocalInner.class

파일명 :  `외부 클래스명$내부 클래스명.class`

서로 다른 메서드 내에서는 같은 이름의 지역변수를 사용하는 것이 가능한 것처럼, 지역내부 클래스는 다른 메서드에 같은 이름의 내부 클래스가 존재할 수 있기 때문에 클래스명에 숫자가 붙는다.

```java
class Outer{
	void myMethod(){
		int lv = 0;
	}
	void myMethod2(){
		int lv
	}
}
```

​																												|

​																												|

```java
class Outer{
	void myMethod(){
		class LocalInner{}
	}
	
	void myMethod2(){
		class LocalInner{}
	}
}
```

위의 코드를 컴파일하면 다음과 같은 클래스파일이 생성됨

- Outer.class
- Outer$1LocalInner.class
- Outer$2LocalInner.class 

내부클래스와 외부클래스의 선언된 변수의 이름이 같을때

```java
class Outer{
    int value = 10; // Outer.this.value

    class Inner{
        int value = 20; // this.value;

        void method1(){
            int value = 30;
            System.out.println("           value : "+ value);
            System.out.println("      this.value : "+ this.value);
            System.out.println("Outer.this.value : "+ Outer.this.value);
        }
    }
}
class InnerEx5 {
    public static void main(String[] args) {
        Outer outer = new Outer();  // 외부 클래스의 인스턴스를 먼저 생성
        Outer.Inner inner = outer.new Inner();
        inner.method1();
    }
}

```

#### 8.5 익명 클래스(anonymous class)

- 이름이 없는 일회용 클래스, 정의와 생성을 동시에 한다.
- 이름이 없기에 생성자를 가질 수 없다.
- 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

```
new 조상클래스이름(){
	// 멤버 선언
}

	또는

new 구현인터페이스이름(){
	// 멤버선언
}
```

익명 클래스의 사용 예제

```java
class InnerEx6 {
    Object iv = new Object(){void method(){}};
    static Object cv = new Object(){void method(){}};
    void myMethod(){
        Object lv = new Object(){void method(){}};
    }
}
/* 컴파일시 다음과 같은 4개의 클래스파일이 생성됨
	`외부 클래스명$숫자.class`
	InnerEx6.class
	InnerEx6$1.class
	InnerEx6$2.class
	InnerEx6$3.class
*/
```

다음과  같은 클래스가 있는데

```java
import java.awt.*;
import java.awt.event.*;
import java.beans.EventHandler;


class InnerEx7 {
    public static void main(String[] args) {
        Button b = new Button("Start");
        b.addActionListener(new EventHandler());
    }
}
class EventHandler implements ActionListener{
    public void actionPerformed(ActionEvent e){
        System.out.println("ActionEvent occurred!!!");
    }
}
```

다음과 같이 익명클래스로 변환 할 수 있다.

```java
import java.awt.*;
import java.awt.event.*;


class InnerEx8 {
    public static void main(String[] args) {
        Button b = new Button("Start");
        b.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("ActionEvent occurred!!!");
            }
        }
    }
}

```
