## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

---

#### 1.1 상속의 정의와 장점

**상속** 

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
  - 그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
```

**구현 방법**

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 `extends`와 함께 써 주기만하면 된다. 

   - ```java
     class Parent { }
     class Child extends Parent{ }
     ```

     이때 상속해주는 클래스(Parent)를 `조상 클래스` , 상속 받는 클래스(Child)를 `자손 클래스` 라고 한다.

     ```
     조상 클래스	부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
     자손 클래스	자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
     ```

#### 상속 계층도(class hierarchy)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/291dc482-e390-440f-a6c2-21f9d40c3bb2" height="200px" width="200px">

예제

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

```java
class CaptionTvTest {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();    // 자손 클래스의 인스턴스 생성
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel);
        ctv.displayCaption("Hello, World");
        ctv.caption = true;
        ctv.displayCaption("Hello,World");
    }
}

class Tv{
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power()    { power = !power;}
    void channelUp()    { ++channel;}
    void channelDown()  { --channel;}
}
class CaptionTv extends Tv{
    boolean caption;    // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){
            System.out.println(text);
        }
    }
}
```

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/407de19a-1deb-4015-98b7-d430701bad89" height="300px" width="500px">

#### 1.2 클래스간의 관계 - 포함(Composite)관계

-한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

예제1

```java
class Circle{													
	int x;	// 원점의 x좌표								
	int y;	// 원점의 y좌표
	int r;	// 반지름(radius)
}						
class Point{
	int x;	// x좌표
	int y;	// y좌표
}

// Point클래스를 재사용하여 Circle클래스를 작성
class Circle{
	Point c = new Point();	// 원점
	int r;
}
```

예제2

```java
/* Car클래스의 단위구성요소인 Engine, Door와 같은 클래스를 미리 작성해 놓고 이 들을 Car클래스의 멤버변수로
선언하여 포함관계를 맺어주면, 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽다.코드를 관리하는데도 수월
*/

class Car{
	Engine e = new Engine();	// 엔진
	Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
}
```

#### 1.3 클래스간의 관계 결정하기

둘중 성립하는 문장의 관계를 맺어주면됨

```
상속관계 맺어주기	:	~은 ~이다(is-a)
포함관계 맺어주기	:	~은 ~을 가지고 있다(has-a)
```

ex1)

```
예시 1
원(Circle) 과 점(Point)
원은 점이다 보다 원은 점을 가지고 있다가 더 옳기 때문에 포함관계를 맺어준다.

예시 2
Car클래스와 SportsCar클래스
SportsCar는 Car이다. 가 옳기 때문에 이 두클래스는 Car클래스를 조상으로하는 상속관계를 맺어 주어야 한다.

예시 3
Card클래스와 Deck클래스
Deck은 Card를 가지고 있다. 가 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
```

#### 1.4 단일 상속(single inheritance)

자바에서는 다중상속을 허용하지 않고 단일 상속만을 허용한다.

- 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.

#### 1.5 Object클래스 - 모든 클래스의 조상

`다른 클래스로부터 상속받지 않는 모든 클래스`들은 자동적으로 Object클래스로부터 상속받게 한다.(extends가 없는 클래스들)

```java
// 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의
class Tv{
	//...
}
// 위 코드를 컴파일 하면 컴파일러는 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.
class Tv extends Object{
	//...
}
```

모든 클래스들은 Object클래스의 멤버들을 상속 받음 ----> Object클래스에 정의된 멤버들을 사용할 수 있다.

ex) toString() 이나 equals(Object o)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/417f4761-7236-4cff-b8d2-995f99a6b2ca" height="200px" width="200px">

### 2. 오버라이딩(overriding)

---

#### 2.1 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
}
```

#### 2.2 오버라이딩의 조건

```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
	- 이름이 같아야 한다
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
	
즉 메서드 선언부는 조상의 것과 완전히 일치해야 한다.
```

접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

```
	조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 넓은 것에서 좁은 것 순으로 나열 public, protected,(default), private
		 만약 조상 클래스가 protected면 오버라이딩하는 자손 클래스의 메서드는 protected나 public이어야 한다.
		 
	2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

#### Q. static메서드 오버라이딩?

- 부모 클래스와 자식 클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.

- static 메소드는 컴파일시, 메모리에 올라가고 메서드 영역에 존재하며, 실제 객체를 찾는 작업을 시행x 

​       -> 컴파일 시점에 선언된 타입의 메소드 호출

- 오버라이딩은 런타임 시, 사용될 메소드 결정
- staic은 클래스 단위의 성격, 오버라이딩은 객체 단위의 성격을 지님
  따라서 static메소드는 오버라이딩 불가x

#### 2.3 오버로딩 , 오버라이딩

```
오버로딩(overloading)	기존에 없던 새로은 메서드를 정의하는 것(new)
오버라이딩(overriding)	상속받은 메서드의 내용을 변경하는것(change,modify)
```

```java
class Parent{
	void parentMethod(){}
}
class Child extends Parent{
	void parentMethod() {}			// 오버라이딩
	void parentMethod(int i) {}		// 오버로딩
	
	void childMethod() {}
	void childMethod(int i) {}		// 오버로딩
	void childMethod() {}			// 에러, 중복정의
}
```

#### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

- this와 마찬가지로 static메서드에서는 사용불가
- 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우만 사용

예제 1

```java
class SuperTest{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}

/* 실행결과
이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력됨

x=10
this.x=10
super.x=10
*/
```

예제 2

```java
class SuperTest2{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}
/* 실행결과
x=20
this.x=20	// 자손 클래스에 선언된 멤버변수
super.x=10	// 조상 클래스로부터 상속받은 멤버변수 x
*/
```

예제 3(super를 사용해서 조상클래스의 메서드를 포함시킴)

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		// return "x : " + x + ", y : " + y + ", z : " + z;
		   reuturn super.getLocation() + ", z "+ z;	// 조상의 메서드 호출
	}
}
// 이러면 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손클래스의 메서드에 자동적으로 반영됨
```

#### 2.5 super() - 조상 클래스의 생성자

```
Object클래스를 제외한 모든 클래스들의 생성자 첫 줄에 생성자,this() 또는 super(), 를 호출해야 한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
```

예제

```java
class PointTest {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}
class Point{
    int x,y;
    Point(int x, int y){
        // super(); 자동 삽입, super()는 Point의 조상인 Object클래스의 기본생성자인 Object()를 의미
        this.x = x;
        this.y = y;
    }
    String getLocation(){
        return "x : "+x+", y : "+y;
    }
}
class Point3D extends Point{
    int z;
    
    Point3D(int x, int y, int z){
      // 컴파일 에러 생성자인 Point() 를 찾을 수 없다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
    String getLocation(){
        return "x : "+x+", y : "+y+", z : "+z;
    }
}

/* Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 super();를 
 Point3D클래스의 생성자의 첫 줄에 넣는데 이때 super();가 호출 되면서 3D클래스의 조상인 Point클래스의 기본생성자인 Point() 
 가 호출되게 된다. 그러나 Point클래스에 Point()가 정의되어 있지 않기 때문에 에러가난다
 이를 해결하기 위해서는 두가지 방법이 있다.
 1.Point클래스에 생성자 Point()를 추가해준다.
 2.Point3D(int x, int y, int z)의 첫 줄에서 super(x,y);를 집어넣어서 Point(int x, int y)를 호출하도록 변경하면 된다.
 */
```

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 한다.**



### 3. package와 import

---

#### 3.1 패키지(package)

패키지 : 클래스의 묶음

ex) 

- String 클래스의 실제 이름은 java.lang.String이다. java.lang패키지에 속한 String 클래스라는 의미

```
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분잘 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
```

#### 3.2 패키지의 선언

- 패키지명은 대소문자 모두 허용하지만 소문자로 하는 것이 원칙
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다.

```
소스파일의 맨 위에 다음과 같이 한 줄만 적어주면 된다.

package 패키지명;
```

- JVM이 클래스를 찾을수 있게 com.codechobo.book; 이 패키지면 환경변수를 CLASSPATH에다가 패키지 경로를 지정해야한다.
  - 상위 디렉토리가 C:\jdk1.8\work이면 .;C:\jdk1.8\work
  - .; 를 추가한 이우는 현재 디렉토리(.)를 클래스패스에 포함시키기 위해서

#### 3.3 import문

- import문은 컴파일 시에 처리되므 프로그램 성능 영향없음.

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기엔 불편하다.

그래서 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략가능

```
일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
	1. package문
	2. import문
	3. 클래스 선언
	
import문 선언방법
	import 패키지명.클래스명;
			또는
	import 패키지명.*;
	
	
ex)
	import java.util.Calendar;
	import java.util.Date;
	improt java.util.ArrayList;
	
	// 한번에
	import java.util.*;
```

#### 하지만 *은 하위 패키지의 클래스까지 포함하는 것은 아니다.

```java
import java.util.*;
import java.text.*;

// 위의 두 문장 대신 다음과 같이 할 수는 없다.
// import java.* 의 의미는 java패키지의 모든 클래스를 의미한다.(패키지는 포함안됨)
import java.*;
```

예제

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class ImportTest {
    public static void main(String[] args) {
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println("오늘 날짜는 " +date.format(today));
        System.out.println("현재 시간은 "+time.format(today));
    }
}
/* 만약 import문을 지정하지 않았다면 다음과 같이 클래스이름에 패키지명도 적어줘야 했다.

java.util.Date today = new java.util.Date();
java.text.SimpleDateFormat date = new java.text.SimpleDateFormat("yyyy/MM/dd");
java.text.SimpleDateFormat time = new java.time.SimpleDateFormat("hh:mm:ss a");
*/
```

**참고**

- System 과 String 같은 java.lang패키지의 클래스들은 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 다음과 같은 import문이 선언되어 있기 때문이다
  - import java.lang.*;
    - java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 되도록 한 것이다.

#### 3.5 static import 문

- static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```
import static java.lang.Integer.*;		// Integer클래스의 모든 static메소드
import static java.lang.Math.random();	// Math 생략가능
import static java.lang.System.out;		// System.out을 out으로만 참조가능
```

```java
//예제

import static java.lang.System.out;
import static java.lang.Math.*;
class StaticImportEx1 {
    public static void main(String[] args) {
        // System.out.println(Math.random());
        out.println(random());
        // System.out.println("Math.PI : " + Math.PI);
        out.println("Math.PI : "+PI);
    }
}
```

### 4. 제어자(modifier)

---

#### 4.1 제어자란?

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

```
접근 제어자		public, protected, default, private
그	   외	  static, final, abstract, native, transient, synchronized, volatile, strictfp
```

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근 제어자는 한 번에 네 가지중에 하나만 선택해서 사용 가능

#### 4.2 static 

- static은  '클래스의', '공통적인' 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/12648d16-ed1e-4b1a-a740-dcf3973db38b" height="250px" width="700px">

#### 4.3 final

- 마지막의 또는 변경될 수 없는의 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/ec326096-2fa1-45e0-a0b5-2019591b2a29" height="250px" width="700px">

#### 생성자를 이용한 final멤버 변수의 초기화

- 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다. 

  - 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능

  ```java
  class FinalCardTest {
      public static void main(String[] args) {
          Card c = new Card("Heart",10);
  //      c.NUMBER = 5;     에러!! cannot assign a value to final variable NUMBER
          System.out.println(c.KIND);
          System.out.println(c.NUMBER);
          System.out.println(c);  // System.out.println(c.toString());
      }
  }
  class Card{
      final int NUMBER;
      final String KIND;
      static int width = 100;
      static int height = 250;
  
      Card(String kind, int num){			// 매개변수로 넘겨받은값으로 KIND와 NUMBER를 초기화한다.
          KIND = kind;
          NUMBER = num;
      }
      Card(){
          this("Heart",1);
      }
      public String toString(){
          return KIND + " "+ NUMBER; 
      }
  }
  ```

#### 4.4 abstract

- '미완성'의 의미를 가지고 있다.
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

```java
abstract class AbstractTest{		// 추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move();			// 추상 메서드(구현부가 없는 메서드)
}
```

#### 4.5 접근 제어자(access modifier)

- 멤버 또는클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  

```
public			접근 제한이 전혀 없다.
protected 		같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
(default)		같은 패키지 내에서만 접근이 가능하다.
private			같은 클래스 내에서만 접근이 가능하다.
```

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/c97ee524-3c68-4710-8d52-eb7cdc407241" height="220px" width="600px">

- 대상에 따라 사용할 수 있는 접근 제어자

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/20667e4d-56ee-4432-9ada-bc815a343d1c" height="220px" width="600px">

**접근 제어자를 이용한 캡슐화**

- 데이터가 유효한 값을 유지하도록, 또는 외부에서 함부로 변경하지 못하도록 외부로부터 접근을 제한하는 것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 **캡슐화**(encapsulation)에 해당하는 내용이다.

```
접근 제어자를 사용하는 이유
	- 외부로부터 데이터를 보호하기 위해서
	- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
```

**예시**

시간을 표시하기 위한 클래스 Time이 다음과 같이 정의되어 있을 때

```java
public class Time{
	public int hour;
	public int minute;
	public int second;
}
```

이 클래스의 인스턴스를 생성한 다음, 멤버변수에 직접 접근하여 값을 변경할 수 있을 것이다.

멤버변수 hour은 0<= hour < 24 의 범위를 가져야 하지만 아래 코드처럼 잘못된 값을 지정한다고해도 막을 방법이 없다.

```java
Time t = new Time();
t.hour = 25;
```

이런 경우 멤버변수를 private이나 protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다.

```java
public class Time{
	private int hour;
	private int minute;
	private int second;
	
	public int getHour()	{ return hour; }
	public void setHour(int hour){
		if(hour < 0 || hour > 23) return;
		this.hour = hour;
	}
	public int getMinute(){ return minute; }
	public void setMinute(int minute){
		if(minute < 0 || minute > 59) return;
		this.minute = minute;
	}
	public int getSecond(){ return second; }
	public void setSecond(int second){
		if(second < 0 || second > 59) return;
		this.second = second;
	}
}

// Time클래스의 모든 멤버변수의 접근 제어자를 private로 하고, 이들을 다루기 위한 public메서드를 추가했다.
// t.hour = 13; 과 같이 멤버변수로의 직접적인 접근은 허가되지 않고 메서드를 통한 접근만이 허용된다.
```

- getter
  - get으로 시작하는 메서드
  - 멤버변수의 값을 반환
  - 예시 )  
    - public int getHour()	{ return hour; }
- setter
  - set으로 시작하는 메서드
  - 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경함
  - 예시 ) 
    - public void setHour(int hour){
      		if(hour < 0 || hour > 23)   return;
        		this.hour = hour;
        	}

**생성자의 접근 제어자**

#### Singleton 패턴(객체의 인스턴스가 오직 1개만 생성)

생성자의 접근 제어자를 private으로 지정하면 외부에서 생성자에 접근할 수 없으므로 인트스턴스를 생성할 수 없게 된다.

그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```
class Singleton{
	private Singleton(){
		...
	}
	...
}
```

대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할 수 있다.

이 메서드는 public인 동시에 static이어야한다.

```java
class Singleton{
	...
	// getInstance()에서 사용될 수있도록 인스턴스가 미리 생성되어야 하므로 static 이어야 한다.
	private static Singleton s = new Singleton();	
													
	private Singleton(){		// 생성자  private
		...
	}
	
	// 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다.
	public static Singleton getInstance(){
		return s;
	}
}
```

또 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 왜냐하면 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래에서 호출하는 것이 불가능하기 때문이다.

그래서 클래스 앞에 `final`을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.



#### 4.6 제어자(modifier)의 조합

| 대상     | 사용가능한 제어자                         |
| -------- | ----------------------------------------- |
| 클래스   | public, (default), final, abstract        |
| 메서드   | 모든 접근 제어자, final, abstract, static |
| 멤버변수 | 모든 접근 제어자, final, static           |
| 지역변수 | final                                     |

주의사항!!!

```
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
	static 메서드는 구현된 내용이 있어야 하며, 추상 메서드는 구현 내용이 없어야 한다.
	
2. 클래스에 abstract와 final을 동시에 사용할 수 없다..
	클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야
	한다는 의미이므로 서로 모순되기 때문이다.
	
3. abstract메서드의 접근 제어자가 private일 수 없다.
	abstract메서드는 자손클래스에서 구현해줘야 하는데 접근 제어자가 private이면, 
	자손클래스에서 접근할 수 없기 때문이다.
	
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
	접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.
```

### 5. 다형성(polymorphism)

---

#### 5.1 다형성이란?

객체지향개념에서 다형성	:	여러 가지 형태를 가질 수 있는 능력

자바에서는 **한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함**으로써 다형성을 프로그램적으로 구현했다.

-> **조상클래스 타입의 참조변수로 자손클래스 인스턴스를 참조할 수 있도록 함**

예제

```java
class Tv{
	boolean power;		// 전원상태(on/off)
	int channel;		// 채널
	
	void power()	 {	power = !power;	}
	void channelUp	 {	++channel;	}
	void channelDown {	--channel;	}
}

class CaptionTv extends Tv{
	String text;	// 캡션을 보여주기 위한 문자열
	void caption(){	/* 내용 생략 */ }
}
```

클래스 Tv와 CaptionTv는 서로 상속관계에 있다

다음과 같이 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능

```java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();	// 조상 타입의 참조변수로 자손 인스턴스를 참조
```

**참조변수 t는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있다.** 

따라서 생성된 CaptionTv인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 멤버, text, caption()은 참조변수 t로 사용 불가능



반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능

```java
CaptionTv c = new Tv();
```

실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문에 에러

CaptionTv클래스에는 text와 caption()이 정의되어 있으므로 참조변수 c로는 c.text, c.catpion()과 같은 방식으로 c가 참조하고 있는 인스턴스에서 text와 caption()을 사용하려 할 수있다. 하지만 c가 참조하고 있는 인스턴스는 Tv타입이고, Tv타입의 인스턴스에는 text와 caption()이 존재하지 않기 때문에 문제가 발생. 

자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용x

**참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.**

```
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.

|참고| 모든 참조변수는 null 또는 4 byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.
```

#### 5.2 참조변수의 형변환

```
	자손타입 -> 조상타입(Up-casting)	: 형변환 생략가능
	조상타입 -> 자손타입(Down-casting)	: 형변환 생략불가
```

- 상속관계가 아닌 클래스간의 형변환 불가
- 자식타입 참조변수에서 조상타입 참조변수로 형변환 하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 형변환 생략 가능 
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 떄문에 인스턴스에 아무런 영향을 미치지 않는다.
  - 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.

예제

```java
//Car클래스가 FireEngine 과 Amulance 클래스의 조상일때

class Car{}
class FireEngine extends Car{
      void water(){
        System.out.println("water!!!");
    }
}
class Ambulance extends Car{}

FireEngine f;
Ambulance  a;
a = (Ambulance)f;	// 에러. 상속관계가 아닌 클래스간의 형변환 불가
f = (FireEngine)a;  // 에러. 상속관계가 아닌 클래스간의 형변환 불가

Car car = null;
FireEngine fe  = new FireEngine();
FireEngine fe2 = null;

/* 참조변수 fe가 참조하고 있는 인스턴스를 참조변수 car가 참조하도록 한다. fe의 값이(fe가 참조하고 있는 인스턴스의 주소)
이 car에 저장된다. 이때 car = (Car)fe; 에서 형변환 생략됨, Up-casting 이제는 참조변수 car를 통해서도 
FireEngine인스터스를 사용할 수 있지만 fe와 달리 car는 Car타입이므로 Car클래스 멤버가아닌 water()는 사용할 수 없다.
*/
car = fe;

/*
	참조변수 car가 참조하고 있는 인스턴스를 참조변수 fe2가 참조하도록 한다. 이때 두 참조변수의 타입이 다르므로 참조변수
	car 를 형변환하였다. car에는 FireEngine인스턴스의 주소가 저장되어 있으므로 fe2에도 FireEngine인스턴스의 주소가
	저장된다. 이제는 참조변수 fe2를 통해서도 FireEngine인스턴스를 사용할 수 있지만, car와는 달리, fe2는 
	FireEngine타입이므로 FireEngine 인스턴스의 모든 멤버들을 사용할 수 있다.
*/
fe2 = (FireEngine)car
```

예제2

```java
class CastingTest2 {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;

        car.drive();
        fe = (FireEngine)car;	// 컴파일 에러 부분
        fe.drive();
        car2 = fe;
        car2.drive();
    }
}
/* 컴파일 에러 
	캐스트 연산자를 이용해서 조상타입의 참조변수를 자손타입의 참조변수로 형변환한 것이기 때문에 문제가 없어 보이지만
	문제는 참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스라는데 있다. 조상타입의 인스턴스를 자손타입의 
	참조변수로 참조하는 것은 허용되지 않는다.
	컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생서될 인스턴스의 타입에 대해서는 전혀 알지 못한다.
	그래서 컴파일 시에는 문제가 없었지만, 실행 시에는 에러가 발생
	
	Car car = new FireEngine(); 으로 바꾸면 에러가 발생하지 않을것이다.
*/
```

```
서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나,
참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
```

#### 5.3 instanceof연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알수 있음
- instanceof 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다. 그리고 true or false를 반환. 

```java
class InstanceofTest {
    public static void main(String[] args) {
        FireEngine fe =new FireEngine();

        if(fe instanceof FireEngine){
            System.out.println("This is a FireEngine instance.");
        }
        if(fe instanceof Car){
            System.out.println("This is a Car instance.");
        }
        if(fe instanceof Object) {
            System.out.println("This is an Object instance");
        }
        System.out.println(fe.getClass().getName());    // 클래스의 이름을 출력
    }
}
/* 생성된 인스턴스는 FireEngine타입인데도, Object, Car타입의 instanceof연산에서도 true를 결과로 얻었다.
	그 이유는 FireEngine클래스는 Object클래스와 Car클래스의 자손 클래스이므로 조상의 멤버들을 상속받았기 때문에,
	FireEngine인스턴스는 Object인스턴스와 Car인스턴스를 포함하고 있는 셈이기 때문이다.
*/
```

```
어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
```

#### 5.4 참조변수와 인스턴스의 연결

- 조상클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을때  조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고,  자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.
- 메서드의 경우 조상 클래스의 메서드를 자손클래스에서 오버라이딩한 경우에는 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출됨
- static 메서드는 static 변수처럼  참조변수의 타입에 영향을 받는다. 참조변수에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. 그래서 반드시 참조변수가 아닌 `클래스이름.메서드()`로 호출 해야한다.
-  `Parent p = new Child();`만약 up-casting을 하지않고 그냥 new Parent();를 한다면 오버라이딩이 일어나지 않아서 p.method를 호출할시 Parent클래스의 메서드가 직접호출된다. 즉이는 다형성을 활용하지 않고 Parent클래스의 인스턴스에 직접 접근하는 것이다.

```java
class BindingTest2 {
    public static void main(String[] args) {
        Parent p = new Child();			// up-casting으로 p.method()는 오버라이딩한 Child의 method()가 호출됨		
        Child c = new Child();

        System.out.println("p.x = "+p.x);
        p.method();
        System.out.println();

        System.out.println("c.x = "+c.x);
        c.method();
    }
}
class Parent{
    static int x = 100;
    void method(){
        System.out.println("Parent Method");
    }
}

class Child extends Parent{

    int x = 200;

    void method(){
        System.out.println("x="+x);				// this.x와 같다.
        System.out.println("super.x="+super.x); // 조상클래스인 Parent에 선언된 인스턴스변수 x
        System.out.println("this.x="+this.x);	// Child클래스의 인스턴스변수 x
    }
}
/* 결과
p.x = 100
x=200
super.x=100
this.x=200

c.x = 200
x=200
super.x=100
this.x=200

*/
```

#### 5.5 매개변수의 다형성

```java
class Product{
	int price;		// 제품의 가격
	int bonusPoint	// 제품구매 시 제공하는 보너스 점수
}
class Tv  		extends Product{}
class Computer 	extends Product{}
class Audio		extends Product{}

class Buyer{					// 고객, 물건을 사는 사람					
	int money = 1000;			// 소유금액
	int bonusPoint	= 100;		// 보너스 점수
}
```

Product클래스는 Tv,Audio,Computer 클래스의 조상이며, Buyer 클래스는 제품을 구입하는 사람

Tv를 살 수 있도록 매개변수를 Tv타입으로 하면

```java
void buy(Tv t){
	// Buyer가 가진돈(money)에서 제품의 가격(t.price)만큼 뺀다.
	money = money - t.price;
	
	// Buyer의 보너스점수(bonusPoint)에 제품의 보너스점수(t.bonusPoint)를 더한다.
	bonusPoint = bonusPoint + t.bonusPoint;
}
```

그런데 void buy(Tv t)로는 Tv밖에 살 수 없기 떄문에 다른 제품들도 구입할 수 있는 메서드가 추가로 필요

```java
void buy(Computer c){
	money = money - t.price;     
    bonusPoint = bonusPoint + t.bonusPoint;
}

void buy(Audio a){
	money = money - t.price;     
    bonusPoint = bonusPoint + t.bonusPoint;
}
```

이렇게되면, 제품의 종류가 늘어날 때마다 Buyer클래스에는 새로운 buy메서드를 추가해주어야한다.

그러나 메서드의 매개변수에 다형성을 적용하면 하나의 메서드로 간단히 처리가능(**매개변수가 조상타입의 참조변수**)

```java
void buy(Product p){
	money = money - p.price;
	bonusPoint = bonusPoint + p.bonusPoint;
	}
```

이제 매개변수가 Product타입의 참조변수 이므로 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다.

Product클래스에 price와 bonusPoint가 선언되어 있기에 참조변수 p로 인스턴스의 price와 bonusPoint를 사용가능

```java
Buyer b = new Buyer();
Tv t = new Tv();
Computer c = new Computer();
b.buy(t);
b.buy(c);
```

예제

```java
class PolyArgumentTest {
    public static void main(String[] args) {
        Buyer b = new Buyer();

        b.buy(new Tv());
        b.buy(new Computer());

        System.out.println("현재남은 돈은 "+b.money+"만원입니다.");
        System.out.println("현재 보너스 점수는 "+b.bonusPoint+"점입니다.");
    }
}

class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price=price;
        bonusPoint = (int)(price/10.0);
    }
}
class Tv extends Product{
    Tv(){
        super(100);
    }
    // Object클래스의 toString()을 오버라이딩한다.
    public  String toString(){ return "Tv";}
}
class Computer extends Product{
    Computer(){ super(200);}

    public String toString() { return "Computer";}
}
class Buyer{
    int money = 1000;
    int bonusPoint = 0;

    void buy(Product p){
        if(money < p.price){
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }
        money -= p.price;
        bonusPoint +=p.bonusPoint;
        System.out.println(p+"을/를 구입하셨습니다.");
    }
}

/* 결과
Tv을/를 구입하셨습니다.
Computer을/를 구입하셨습니다.
현재남은 돈은 700만원입니다.
현재 보너스 점수는 30점입니다.
*/		
```

#### 5.6 여러 종류의 객체를 배열로 다루기

```java
Product p1 = new Tv();
Product p2 = new Computer();
Product p3 = new Audio();

// Proudct 타입의 참조변수 배열
Product [] p = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

만약 Product [] p = new Product[10]이면 배열의 크기를 10으로 했기 때문에 11개 이상의 제품을 구입할 수 없는데 그렇다고 배열의 크기를 무조건 크게 설정할 수만도 없다.

이런경우, Vector클래스를 사용하면된다. Vector클래스는 내부적으로 Object타입의 배열을 가지고 있어서, 이 배열에 객체를  추가하거나 제거할 수 있게 작성되어 있다.

동적으로 관리되는 객체 배열

```java
public class Vector exntends AbstractList
			  implements List, Cloneable, java.io.Serializable{
		  protected Object elementData[];''		 
	 }
```

| 메서드/생성자            | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Vector()                 | 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다. |
| boolean add(Object o)    | Vector에 객체를 추가한다. 추가에 성공하면 true, 실패하면 false를 반환 |
| booelan remove(Object O) | Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환 |
| boolean isEmpty()        | Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환 |
| Object get(int index)    | 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로 형변환이 필요 |
| int size()               | Vector에 저장된 객체의 수를 반환한다.                        |

예제

```java
import java.util.*;     // Vector클래스를 사용하기 위해서 추가해줌
class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price=price;
        bonusPoint = (int)(price/10.0);
    }
    Product() {}
}
class Tv extends Product{
    Tv(){
        super(100);
    }
    // Object클래스의 toString()을 오버라이딩한다.
    public  String toString(){ return "Tv";}
}
class Computer extends Product{
    Computer(){ super(200);}

    public String toString() { return "Computer";}
}
class Audio extends Product{
    Audio() {super(50);}
    public String toString() {return "Audio";}
}
class Buyer{
    int money = 1000;
    int bonusPoint = 0;
    //  Product[] item = new Product[10];  이 배열 대신 Vector()사용
    Vector item = new Vector();  // 구입한 제품을 저장하는데 사용될 Vector객체
    void buy(Product p){
        if(money < p.price){
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }
        money -= p.price;
        bonusPoint +=p.bonusPoint;
        item.add(p);
        System.out.println(p+"을/를 구입하셨습니다.");
    }
    void refund(Product p){     // 환불
        if(item.remove(p)){
            money +=p.price;
            bonusPoint -=p.bonusPoint;
            System.out.println(p+"을/를 반품하셨습니다.");
        }else{  // 제거에 실패한 경우
            System.out.println("구입하신 제품 중 해당 제품이 없습니다.");
        }
    }
    void summary(){
        int sum = 0;
        String itemList = "";
        if(item.isEmpty()){
            System.out.println("구입하신 제품이 없습니다.");
            return;
        }

        for(int i=0; i<item.size();i++){
            Product p = (Product)item.get(i);
            sum += p.price;
            itemList += (i==0) ? "" + p :  "," + p;
        }
        System.out.println("구입하신 물픔의 총금액은 "+ sum+"만원입니다.");
        System.out.println("구입하신 제품은 "+itemList+"입니다.");
    }
}


class PolyArgumentTest3 {
    public static void main(String[] args) {
        Buyer b= new Buyer();
        Tv tv = new Tv();
        Computer com = new Computer();
        Audio audio = new Audio();

        b.buy(tv);
        b.buy(com);
        b.buy(audio);
        b.summary();
        System.out.println();
        b.refund(com);
        b.summary();
    }
}
```

