## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

---

#### 1.1 상속의 정의와 장점

**상속** 

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
  - 그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
```

**구현 방법**

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 `extends`와 함께 써 주기만하면 된다. 

   - ```java
     class Parent { }
     class Child extends Parent{ }
     ```

     이때 상속해주는 클래스(Parent)를 `조상 클래스` , 상속 받는 클래스(Child)를 `자손 클래스` 라고 한다.

     ```
     조상 클래스	부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
     자손 클래스	자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
     ```

#### 상속 계층도(class hierarchy)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/291dc482-e390-440f-a6c2-21f9d40c3bb2" height="200px" width="200px">

예제

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

```java
class CaptionTvTest {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();    // 자손 클래스의 인스턴스 생성
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel);
        ctv.displayCaption("Hello, World");
        ctv.caption = true;
        ctv.displayCaption("Hello,World");
    }
}

class Tv{
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power()    { power = !power;}
    void channelUp()    { ++channel;}
    void channelDown()  { --channel;}
}
class CaptionTv extends Tv{
    boolean caption;    // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){
            System.out.println(text);
        }
    }
}
```

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/407de19a-1deb-4015-98b7-d430701bad89" height="300px" width="500px">

#### 1.2 클래스간의 관계 - 포함(Composite)관계

-한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

예제1

```java
class Circle{													
	int x;	// 원점의 x좌표								
	int y;	// 원점의 y좌표
	int r;	// 반지름(radius)
}						
class Point{
	int x;	// x좌표
	int y;	// y좌표
}

// Point클래스를 재사용하여 Circle클래스를 작성
class Circle{
	Point c = new Point();	// 원점
	int r;
}
```

예제2

```java
/* Car클래스의 단위구성요소인 Engine, Door와 같은 클래스를 미리 작성해 놓고 이 들을 Car클래스의 멤버변수로
선언하여 포함관계를 맺어주면, 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽다.코드를 관리하는데도 수월
*/

class Car{
	Engine e = new Engine();	// 엔진
	Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
}
```

#### 1.3 클래스간의 관계 결정하기

둘중 성립하는 문장의 관계를 맺어주면됨

```
상속관계 맺어주기	:	~은 ~이다(is-a)
포함관계 맺어주기	:	~은 ~을 가지고 있다(has-a)
```

ex1)

```
예시 1
원(Circle) 과 점(Point)
원은 점이다 보다 원은 점을 가지고 있다가 더 옳기 때문에 포함관계를 맺어준다.

예시 2
Car클래스와 SportsCar클래스
SportsCar는 Car이다. 가 옳기 때문에 이 두클래스는 Car클래스를 조상으로하는 상속관계를 맺어 주어야 한다.

예시 3
Card클래스와 Deck클래스
Deck은 Card를 가지고 있다. 가 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
```

#### 1.4 단일 상속(single inheritance)

자바에서는 다중상속을 허용하지 않고 단일 상속만을 허용한다.

- 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.

#### 1.5 Object클래스 - 모든 클래스의 조상

`다른 클래스로부터 상속받지 않는 모든 클래스`들은 자동적으로 Object클래스로부터 상속받게 한다.(extends가 없는 클래스들)

```java
// 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의
class Tv{
	//...
}
// 위 코드를 컴파일 하면 컴파일러는 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.
class Tv extends Object{
	//...
}
```

모든 클래스들은 Object클래스의 멤버들을 상속 받음 ----> Object클래스에 정의된 멤버들을 사용할 수 있다.

ex) toString() 이나 equals(Object o)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/417f4761-7236-4cff-b8d2-995f99a6b2ca" height="200px" width="200px">

### 2. 오버라이딩(overriding)

---

#### 2.1 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
}
```

#### 2.2 오버라이딩의 조건

```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
	- 이름이 같아야 한다
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
	
즉 메서드 선언부는 조상의 것과 완전히 일치해야 한다.
```

접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

```
	조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 넓은 것에서 좁은 것 순으로 나열 public, protected,(default), private
		 만약 조상 클래스가 protected면 오버라이딩하는 자손 클래스의 메서드는 protected나 public이어야 한다.
		 
	2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

#### Q. static메서드 오버라이딩?

- 부모 클래스와 자식 클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.

- static 메소드는 컴파일시, 메모리에 올라가고 메서드 영역에 존재하며, 실제 객체를 찾는 작업을 시행x 

​       -> 컴파일 시점에 선언된 타입의 메소드 호출

- 오버라이딩은 런타임 시, 사용될 메소드 결정
- staic은 클래스 단위의 성격, 오버라이딩은 객체 단위의 성격을 지님
  따라서 static메소드는 오버라이딩 불가x

#### 2.3 오버로딩 , 오버라이딩

```
오버로딩(overloading)	기존에 없던 새로은 메서드를 정의하는 것(new)
오버라이딩(overriding)	상속받은 메서드의 내용을 변경하는것(change,modify)
```

```java
class Parent{
	void parentMethod(){}
}
class Child extends Parent{
	void parentMethod() {}			// 오버라이딩
	void parentMethod(int i) {}		// 오버로딩
	
	void childMethod() {}
	void childMethod(int i) {}		// 오버로딩
	void childMethod() {}			// 에러, 중복정의
}
```

#### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

- this와 마찬가지로 static메서드에서는 사용불가
- 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우만 사용

예제 1

```java
class SuperTest{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}

/* 실행결과
이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력됨

x=10
this.x=10
super.x=10
*/
```

예제 2

```java
class SuperTest2{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}
/* 실행결과
x=20
this.x=20	// 자손 클래스에 선언된 멤버변수
super.x=10	// 조상 클래스로부터 상속받은 멤버변수 x
*/
```

예제 3(super를 사용해서 조상클래스의 메서드를 포함시킴)

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		// return "x : " + x + ", y : " + y + ", z : " + z;
		   reuturn super.getLocation() + ", z "+ z;	// 조상의 메서드 호출
	}
}
// 이러면 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손클래스의 메서드에 자동적으로 반영됨
```

#### 2.5 super() - 조상 클래스의 생성자

```
Object클래스를 제외한 모든 클래스들의 생성자 첫 줄에 생성자,this() 또는 super(), 를 호출해야 한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
```

예제

```java
class PointTest {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}
class Point{
    int x,y;
    Point(int x, int y){
        // super(); 자동 삽입, super()는 Point의 조상인 Object클래스의 기본생성자인 Object()를 의미
        this.x = x;
        this.y = y;
    }
    String getLocation(){
        return "x : "+x+", y : "+y;
    }
}
class Point3D extends Point{
    int z;
    
    Point3D(int x, int y, int z){
      // 컴파일 에러 생성자인 Point() 를 찾을 수 없다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
    String getLocation(){
        return "x : "+x+", y : "+y+", z : "+z;
    }
}

/* Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 super();를 
 Point3D클래스의 생성자의 첫 줄에 넣는데 이때 super();가 호출 되면서 3D클래스의 조상인 Point클래스의 기본생성자인 Point()   가 호출되게 된다. 그러나 Point클래스에 Point()가 정의되어 있지 않기 때문에 에러가난다
 이를 해결하기 위해서는 두가지 방법이 있다.
 1.Point클래스에 생성자 Point()를 추가해준다.
 2.Point3D(int x, int y, int z)의 첫 줄에서 super(x,y);를 집어넣어서 Point(int x, int y)를 호출하도록 변경하면 된다.
```

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 한다.**
