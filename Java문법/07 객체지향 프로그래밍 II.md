## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

---

#### 1.1 상속의 정의와 장점

**상속** 

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
  - 그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
```

**구현 방법**

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 `extends`와 함께 써 주기만하면 된다. 

   - ```java
     class Parent { }
     class Child extends Parent{ }
     ```

     이때 상속해주는 클래스(Parent)를 `조상 클래스` , 상속 받는 클래스(Child)를 `자손 클래스` 라고 한다.

     ```
     조상 클래스	부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
     자손 클래스	자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
     ```

#### 상속 계층도(class hierarchy)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/291dc482-e390-440f-a6c2-21f9d40c3bb2" height="200px" width="200px">

예제

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

```java
class CaptionTvTest {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();    // 자손 클래스의 인스턴스 생성
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel);
        ctv.displayCaption("Hello, World");
        ctv.caption = true;
        ctv.displayCaption("Hello,World");
    }
}

class Tv{
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power()    { power = !power;}
    void channelUp()    { ++channel;}
    void channelDown()  { --channel;}
}
class CaptionTv extends Tv{
    boolean caption;    // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){
            System.out.println(text);
        }
    }
}
```

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/407de19a-1deb-4015-98b7-d430701bad89" height="300px" width="500px">

#### 1.2 클래스간의 관계 - 포함(Composite)관계

-한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

예제1

```java
class Circle{													
	int x;	// 원점의 x좌표								
	int y;	// 원점의 y좌표
	int r;	// 반지름(radius)
}						
class Point{
	int x;	// x좌표
	int y;	// y좌표
}

// Point클래스를 재사용하여 Circle클래스를 작성
class Circle{
	Point c = new Point();	// 원점
	int r;
}
```

예제2

```java
/* Car클래스의 단위구성요소인 Engine, Door와 같은 클래스를 미리 작성해 놓고 이 들을 Car클래스의 멤버변수로
선언하여 포함관계를 맺어주면, 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽다.코드를 관리하는데도 수월
*/

class Car{
	Engine e = new Engine();	// 엔진
	Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
}
```

#### 1.3 클래스간의 관계 결정하기

둘중 성립하는 문장의 관계를 맺어주면됨

```
상속관계 맺어주기	:	~은 ~이다(is-a)
포함관계 맺어주기	:	~은 ~을 가지고 있다(has-a)
```

ex1)

```
예시 1
원(Circle) 과 점(Point)
원은 점이다 보다 원은 점을 가지고 있다가 더 옳기 때문에 포함관계를 맺어준다.

예시 2
Car클래스와 SportsCar클래스
SportsCar는 Car이다. 가 옳기 때문에 이 두클래스는 Car클래스를 조상으로하는 상속관계를 맺어 주어야 한다.

예시 3
Card클래스와 Deck클래스
Deck은 Card를 가지고 있다. 가 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
```

#### 1.4 단일 상속(single inheritance)

자바에서는 다중상속을 허용하지 않고 단일 상속만을 허용한다.

- 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.

#### 1.5 Object클래스 - 모든 클래스의 조상

`다른 클래스로부터 상속받지 않는 모든 클래스`들은 자동적으로 Object클래스로부터 상속받게 한다.(extends가 없는 클래스들)

```java
// 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의
class Tv{
	//...
}
// 위 코드를 컴파일 하면 컴파일러는 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.
class Tv extends Object{
	//...
}
```

모든 클래스들은 Object클래스의 멤버들을 상속 받음 ----> Object클래스에 정의된 멤버들을 사용할 수 있다.

ex) toString() 이나 equals(Object o)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/417f4761-7236-4cff-b8d2-995f99a6b2ca" height="200px" width="200px">

### 2. 오버라이딩(overriding)

---

#### 2.1 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
}
```

#### 2.2 오버라이딩의 조건

```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
	- 이름이 같아야 한다
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
	
즉 메서드 선언부는 조상의 것과 완전히 일치해야 한다.
```

접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

```
	조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 넓은 것에서 좁은 것 순으로 나열 public, protected,(default), private
		 만약 조상 클래스가 protected면 오버라이딩하는 자손 클래스의 메서드는 protected나 public이어야 한다.
		 
	2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

#### Q. static메서드 오버라이딩?

- 부모 클래스와 자식 클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.

- static 메소드는 컴파일시, 메모리에 올라가고 메서드 영역에 존재하며, 실제 객체를 찾는 작업을 시행x 

​       -> 컴파일 시점에 선언된 타입의 메소드 호출

- 오버라이딩은 런타임 시, 사용될 메소드 결정
- staic은 클래스 단위의 성격, 오버라이딩은 객체 단위의 성격을 지님
  따라서 static메소드는 오버라이딩 불가x

#### 2.3 오버로딩 , 오버라이딩

```
오버로딩(overloading)	기존에 없던 새로은 메서드를 정의하는 것(new)
오버라이딩(overriding)	상속받은 메서드의 내용을 변경하는것(change,modify)
```

```java
class Parent{
	void parentMethod(){}
}
class Child extends Parent{
	void parentMethod() {}			// 오버라이딩
	void parentMethod(int i) {}		// 오버로딩
	
	void childMethod() {}
	void childMethod(int i) {}		// 오버로딩
	void childMethod() {}			// 에러, 중복정의
}
```

#### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

- this와 마찬가지로 static메서드에서는 사용불가
- 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우만 사용

예제 1

```java
class SuperTest{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}

/* 실행결과
이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력됨

x=10
this.x=10
super.x=10
*/
```

예제 2

```java
class SuperTest2{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}
/* 실행결과
x=20
this.x=20	// 자손 클래스에 선언된 멤버변수
super.x=10	// 조상 클래스로부터 상속받은 멤버변수 x
*/
```

예제 3(super를 사용해서 조상클래스의 메서드를 포함시킴)

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		// return "x : " + x + ", y : " + y + ", z : " + z;
		   reuturn super.getLocation() + ", z "+ z;	// 조상의 메서드 호출
	}
}
// 이러면 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손클래스의 메서드에 자동적으로 반영됨
```

#### 2.5 super() - 조상 클래스의 생성자

```
Object클래스를 제외한 모든 클래스들의 생성자 첫 줄에 생성자,this() 또는 super(), 를 호출해야 한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
```

예제

```java
class PointTest {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}
class Point{
    int x,y;
    Point(int x, int y){
        // super(); 자동 삽입, super()는 Point의 조상인 Object클래스의 기본생성자인 Object()를 의미
        this.x = x;
        this.y = y;
    }
    String getLocation(){
        return "x : "+x+", y : "+y;
    }
}
class Point3D extends Point{
    int z;
    
    Point3D(int x, int y, int z){
      // 컴파일 에러 생성자인 Point() 를 찾을 수 없다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
    String getLocation(){
        return "x : "+x+", y : "+y+", z : "+z;
    }
}

/* Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 super();를 
 Point3D클래스의 생성자의 첫 줄에 넣는데 이때 super();가 호출 되면서 3D클래스의 조상인 Point클래스의 기본생성자인 Point() 
 가 호출되게 된다. 그러나 Point클래스에 Point()가 정의되어 있지 않기 때문에 에러가난다
 이를 해결하기 위해서는 두가지 방법이 있다.
 1.Point클래스에 생성자 Point()를 추가해준다.
 2.Point3D(int x, int y, int z)의 첫 줄에서 super(x,y);를 집어넣어서 Point(int x, int y)를 호출하도록 변경하면 된다.
 */
```

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 한다.**



### 3. package와 import

---

#### 3.1 패키지(package)

패키지 : 클래스의 묶음

ex) 

- String 클래스의 실제 이름은 java.lang.String이다. java.lang패키지에 속한 String 클래스라는 의미

```
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분잘 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
```

#### 3.2 패키지의 선언

- 패키지명은 대소문자 모두 허용하지만 소문자로 하는 것이 원칙
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다.

```
소스파일의 맨 위에 다음과 같이 한 줄만 적어주면 된다.

package 패키지명;
```

- JVM이 클래스를 찾을수 있게 com.codechobo.book; 이 패키지면 환경변수를 CLASSPATH에다가 패키지 경로를 지정해야한다.
  - 상위 디렉토리가 C:\jdk1.8\work이면 .;C:\jdk1.8\work
  - .; 를 추가한 이우는 현재 디렉토리(.)를 클래스패스에 포함시키기 위해서

#### 3.3 import문

- import문은 컴파일 시에 처리되므 프로그램 성능 영향없음.

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기엔 불편하다.

그래서 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략가능

```
일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
	1. package문
	2. import문
	3. 클래스 선언
	
import문 선언방법
	import 패키지명.클래스명;
			또는
	import 패키지명.*;
	
	
ex)
	import java.util.Calendar;
	import java.util.Date;
	improt java.util.ArrayList;
	
	// 한번에
	import java.util.*;
```

#### 하지만 *은 하위 패키지의 클래스까지 포함하는 것은 아니다.

```java
import java.util.*;
import java.text.*;

// 위의 두 문장 대신 다음과 같이 할 수는 없다.
// import java.* 의 의미는 java패키지의 모든 클래스를 의미한다.(패키지는 포함안됨)
import java.*;
```

예제

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class ImportTest {
    public static void main(String[] args) {
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println("오늘 날짜는 " +date.format(today));
        System.out.println("현재 시간은 "+time.format(today));
    }
}
/* 만약 import문을 지정하지 않았다면 다음과 같이 클래스이름에 패키지명도 적어줘야 했다.

java.util.Date today = new java.util.Date();
java.text.SimpleDateFormat date = new java.text.SimpleDateFormat("yyyy/MM/dd");
java.text.SimpleDateFormat time = new java.time.SimpleDateFormat("hh:mm:ss a");
*/
```

**참고**

- System 과 String 같은 java.lang패키지의 클래스들은 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 다음과 같은 import문이 선언되어 있기 때문이다
  - import java.lang.*;
    - java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 되도록 한 것이다.

#### 3.5 static import 문

- static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```
import static java.lang.Integer.*;		// Integer클래스의 모든 static메소드
import static java.lang.Math.random();	// Math 생략가능
import static java.lang.System.out;		// System.out을 out으로만 참조가능
```

```java
//예제

import static java.lang.System.out;
import static java.lang.Math.*;
class StaticImportEx1 {
    public static void main(String[] args) {
        // System.out.println(Math.random());
        out.println(random());
        // System.out.println("Math.PI : " + Math.PI);
        out.println("Math.PI : "+PI);
    }
}
```

### 4. 제어자(modifier)

---

#### 4.1 제어자란?

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

```
접근 제어자		public, protected, default, private
그	   외	  static, final, abstract, native, transient, synchronized, volatile, strictfp
```

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근 제어자는 한 번에 네 가지중에 하나만 선택해서 사용 가능

#### 4.2 static 

- static은  '클래스의', '공통적인' 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/12648d16-ed1e-4b1a-a740-dcf3973db38b" height="250px" width="700px">

#### 4.3 final

- 마지막의 또는 변경될 수 없는의 의미를 가지고 있다.

  <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/ec326096-2fa1-45e0-a0b5-2019591b2a29" height="250px" width="700px">

#### 생성자를 이용한 final멤버 변수의 초기화

- 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다. 

  - 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능

  ```java
  class FinalCardTest {
      public static void main(String[] args) {
          Card c = new Card("Heart",10);
  //      c.NUMBER = 5;     에러!! cannot assign a value to final variable NUMBER
          System.out.println(c.KIND);
          System.out.println(c.NUMBER);
          System.out.println(c);  // System.out.println(c.toString());
      }
  }
  class Card{
      final int NUMBER;
      final String KIND;
      static int width = 100;
      static int height = 250;
  
      Card(String kind, int num){			// 매개변수로 넘겨받은값으로 KIND와 NUMBER를 초기화한다.
          KIND = kind;
          NUMBER = num;
      }
      Card(){
          this("Heart",1);
      }
      public String toString(){
          return KIND + " "+ NUMBER; 
      }
  }
  ```

#### 4.4 abstract

- '미완성'의 의미를 가지고 있다.
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

```java
abstract class AbstractTest{		// 추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move();			// 추상 메서드(구현부가 없는 메서드)
}
```

#### 4.5 접근 제어자(access modifier)

- 멤버 또는클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  

```
public			접근 제한이 전혀 없다.
protected 		같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
(default)		같은 패키지 내에서만 접근이 가능하다.
private			같은 클래스 내에서만 접근이 가능하다.
```

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/c97ee524-3c68-4710-8d52-eb7cdc407241" height="220px" width="600px">

- 대상에 따라 사용할 수 있는 접근 제어자

 <img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/20667e4d-56ee-4432-9ada-bc815a343d1c" height="220px" width="600px">

**접근 제어자를 이용한 캡슐화**

- 데이터가 유효한 값을 유지하도록, 또는 외부에서 함부로 변경하지 못하도록 외부로부터 접근을 제한하는 것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 **캡슐화**(encapsulation)에 해당하는 내용이다.

```
접근 제어자를 사용하는 이유
	- 외부로부터 데이터를 보호하기 위해서
	- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
```

**예시**

시간을 표시하기 위한 클래스 Time이 다음과 같이 정의되어 있을 때

```java
public class Time{
	public int hour;
	public int minute;
	public int second;
}
```

이 클래스의 인스턴스를 생성한 다음, 멤버변수에 직접 접근하여 값을 변경할 수 있을 것이다.

멤버변수 hour은 0<= hour < 24 의 범위를 가져야 하지만 아래 코드처럼 잘못된 값을 지정한다고해도 막을 방법이 없다.

```java
Time t = new Time();
t.hour = 25;
```

이런 경우 멤버변수를 private이나 protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다.

```java
public class Time{
	private int hour;
	private int minute;
	private int second;
	
	public int getHour()	{ return hour; }
	public void setHour(int hour){
		if(hour < 0 || hour > 23) return;
		this.hour = hour;
	}
	public int getMinute(){ return minute; }
	public void setMinute(int minute){
		if(minute < 0 || minute > 59) return;
		this.minute = minute;
	}
	public int getSecond(){ return second; }
	public void setSecond(int second){
		if(second < 0 || second > 59) return;
		this.second = second;
	}
}

// Time클래스의 모든 멤버변수의 접근 제어자를 private로 하고, 이들을 다루기 위한 public메서드를 추가했다.
// t.hour = 13; 과 같이 멤버변수로의 직접적인 접근은 허가되지 않고 메서드를 통한 접근만이 허용된다.
```

- getter
  - get으로 시작하는 메서드
  - 멤버변수의 값을 반환
  - 예시 )  
    - public int getHour()	{ return hour; }
- setter
  - set으로 시작하는 메서드
  - 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경함
  - 예시 ) 
    - public void setHour(int hour){
      		if(hour < 0 || hour > 23)   return;
        		this.hour = hour;
        	}

**생성자의 접근 제어자**

#### Singleton 패턴(객체의 인스턴스가 오직 1개만 생성)

생성자의 접근 제어자를 private으로 지정하면 외부에서 생성자에 접근할 수 없으므로 인트스턴스를 생성할 수 없게 된다.

그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```
class Singleton{
	private Singleton(){
		...
	}
	...
}
```

대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할 수 있다.

이 메서드는 public인 동시에 static이어야한다.

```java
class Singleton{
	...
	// getInstance()에서 사용될 수있도록 인스턴스가 미리 생성되어야 하므로 static 이어야 한다.
	private static Singleton s = new Singleton();	
													
	private Singleton(){		// 생성자  private
		...
	}
	
	// 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다.
	public static Singleton getInstance(){
		return s;
	}
}
```

또 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 왜냐하면 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래에서 호출하는 것이 불가능하기 때문이다.

그래서 클래스 앞에 `final`을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.



#### 4.6 제어자(modifier)의 조합

| 대상     | 사용가능한 제어자                         |
| -------- | ----------------------------------------- |
| 클래스   | public, (default), final, abstract        |
| 메서드   | 모든 접근 제어자, final, abstract, static |
| 멤버변수 | 모든 접근 제어자, final, static           |
| 지역변수 | final                                     |

주의사항!!!

```
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
	static 메서드는 구현된 내용이 있어야 하며, 추상 메서드는 구현 내용이 없어야 한다.
	
2. 클래스에 abstract와 final을 동시에 사용할 수 없다..
	클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야
	한다는 의미이므로 서로 모순되기 때문이다.
	
3. abstract메서드의 접근 제어자가 private일 수 없다.
	abstract메서드는 자손클래스에서 구현해줘야 하는데 접근 제어자가 private이면, 
	자손클래스에서 접근할 수 없기 때문이다.
	
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
	접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.
```

