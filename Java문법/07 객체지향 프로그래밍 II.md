## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

---

#### 1.1 상속의 정의와 장점

**상속** 

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
  - 그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
```

**구현 방법**

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 `extends`와 함께 써 주기만하면 된다. 

   - ```java
     class Parent { }
     class Child extends Parent{ }
     ```

     이때 상속해주는 클래스(Parent)를 `조상 클래스` , 상속 받는 클래스(Child)를 `자손 클래스` 라고 한다.

     ```
     조상 클래스	부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
     자손 클래스	자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
     ```

#### 상속 계층도(class hierarchy)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/291dc482-e390-440f-a6c2-21f9d40c3bb2" height="200px" width="200px">

예제

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

```java
class CaptionTvTest {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();    // 자손 클래스의 인스턴스 생성
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel);
        ctv.displayCaption("Hello, World");
        ctv.caption = true;
        ctv.displayCaption("Hello,World");
    }
}

class Tv{
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power()    { power = !power;}
    void channelUp()    { ++channel;}
    void channelDown()  { --channel;}
}
class CaptionTv extends Tv{
    boolean caption;    // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){
            System.out.println(text);
        }
    }
}
```

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/407de19a-1deb-4015-98b7-d430701bad89" height="300px" width="500px">

#### 1.2 클래스간의 관계 - 포함(Composite)관계

-한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

예제1

```java
class Circle{													
	int x;	// 원점의 x좌표								
	int y;	// 원점의 y좌표
	int r;	// 반지름(radius)
}						
class Point{
	int x;	// x좌표
	int y;	// y좌표
}

// Point클래스를 재사용하여 Circle클래스를 작성
class Circle{
	Point c = new Point();	// 원점
	int r;
}
```

예제2

```java
/* Car클래스의 단위구성요소인 Engine, Door와 같은 클래스를 미리 작성해 놓고 이 들을 Car클래스의 멤버변수로
선언하여 포함관계를 맺어주면, 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽다.코드를 관리하는데도 수월
*/

class Car{
	Engine e = new Engine();	// 엔진
	Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
}
```

#### 1.3 클래스간의 관계 결정하기

둘중 성립하는 문장의 관계를 맺어주면됨

```
상속관계 맺어주기	:	~은 ~이다(is-a)
포함관계 맺어주기	:	~은 ~을 가지고 있다(has-a)
```

ex1)

```
예시 1
원(Circle) 과 점(Point)
원은 점이다 보다 원은 점을 가지고 있다가 더 옳기 때문에 포함관계를 맺어준다.

예시 2
Car클래스와 SportsCar클래스
SportsCar는 Car이다. 가 옳기 때문에 이 두클래스는 Car클래스를 조상으로하는 상속관계를 맺어 주어야 한다.

예시 3
Card클래스와 Deck클래스
Deck은 Card를 가지고 있다. 가 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
```

#### 1.4 단일 상속(single inheritance)

자바에서는 다중상속을 허용하지 않고 단일 상속만을 허용한다.

- 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.

#### 1.5 Object클래스 - 모든 클래스의 조상

`다른 클래스로부터 상속받지 않는 모든 클래스`들은 자동적으로 Object클래스로부터 상속받게 한다.(extends가 없는 클래스들)

```java
// 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의
class Tv{
	//...
}
// 위 코드를 컴파일 하면 컴파일러는 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.
class Tv extends Object{
	//...
}
```

모든 클래스들은 Object클래스의 멤버들을 상속 받음 ----> Object클래스에 정의된 멤버들을 사용할 수 있다.

ex) toString() 이나 equals(Object o)

<img src ="https://github.com/GitmasterLJH/java-til/assets/129172593/417f4761-7236-4cff-b8d2-995f99a6b2ca" height="200px" width="200px">

### 2. 오버라이딩(overriding)

---

#### 2.1 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
}
```

#### 2.2 오버라이딩의 조건

```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
	- 이름이 같아야 한다
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
	
즉 메서드 선언부는 조상의 것과 완전히 일치해야 한다.
```

접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

```
	조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 넓은 것에서 좁은 것 순으로 나열 public, protected,(default), private
		 만약 조상 클래스가 protected면 오버라이딩하는 자손 클래스의 메서드는 protected나 public이어야 한다.
		 
	2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

#### Q. static메서드 오버라이딩?

- 부모 클래스와 자식 클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.

- static 메소드는 컴파일시, 메모리에 올라가고 메서드 영역에 존재하며, 실제 객체를 찾는 작업을 시행x 

​       -> 컴파일 시점에 선언된 타입의 메소드 호출

- 오버라이딩은 런타임 시, 사용될 메소드 결정
- staic은 클래스 단위의 성격, 오버라이딩은 객체 단위의 성격을 지님
  따라서 static메소드는 오버라이딩 불가x

#### 2.3 오버로딩 , 오버라이딩

```
오버로딩(overloading)	기존에 없던 새로은 메서드를 정의하는 것(new)
오버라이딩(overriding)	상속받은 메서드의 내용을 변경하는것(change,modify)
```

```java
class Parent{
	void parentMethod(){}
}
class Child extends Parent{
	void parentMethod() {}			// 오버라이딩
	void parentMethod(int i) {}		// 오버로딩
	
	void childMethod() {}
	void childMethod(int i) {}		// 오버로딩
	void childMethod() {}			// 에러, 중복정의
}
```

#### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

- this와 마찬가지로 static메서드에서는 사용불가
- 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우만 사용

예제 1

```java
class SuperTest{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}

/* 실행결과
이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력됨

x=10
this.x=10
super.x=10
*/
```

예제 2

```java
class SuperTest2{
	public static void main(String [] args){
		Child c = new Child();
		c.method();
	}
}
class Parent{
	int x = 10;
}
class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x=" +x);
		System.out.println("this.x="+this.x);
		System.out.println("super.x="+super.x);
	}
}
/* 실행결과
x=20
this.x=20	// 자손 클래스에 선언된 멤버변수
super.x=10	// 조상 클래스로부터 상속받은 멤버변수 x
*/
```

예제 3(super를 사용해서 조상클래스의 메서드를 포함시킴)

```java
class Point{
	int x;
	int y;
	
	String getLocation(){
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point{
	int z;
	
	String getLocation(){		// 오버라이딩
		// return "x : " + x + ", y : " + y + ", z : " + z;
		   reuturn super.getLocation() + ", z "+ z;	// 조상의 메서드 호출
	}
}
// 이러면 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손클래스의 메서드에 자동적으로 반영됨
```

#### 2.5 super() - 조상 클래스의 생성자

```
Object클래스를 제외한 모든 클래스들의 생성자 첫 줄에 생성자,this() 또는 super(), 를 호출해야 한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
```

예제

```java
class PointTest {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}
class Point{
    int x,y;
    Point(int x, int y){
        // super(); 자동 삽입, super()는 Point의 조상인 Object클래스의 기본생성자인 Object()를 의미
        this.x = x;
        this.y = y;
    }
    String getLocation(){
        return "x : "+x+", y : "+y;
    }
}
class Point3D extends Point{
    int z;
    
    Point3D(int x, int y, int z){
      // 컴파일 에러 생성자인 Point() 를 찾을 수 없다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
    String getLocation(){
        return "x : "+x+", y : "+y+", z : "+z;
    }
}

/* Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 super();를 
 Point3D클래스의 생성자의 첫 줄에 넣는데 이때 super();가 호출 되면서 3D클래스의 조상인 Point클래스의 기본생성자인 Point() 
 가 호출되게 된다. 그러나 Point클래스에 Point()가 정의되어 있지 않기 때문에 에러가난다
 이를 해결하기 위해서는 두가지 방법이 있다.
 1.Point클래스에 생성자 Point()를 추가해준다.
 2.Point3D(int x, int y, int z)의 첫 줄에서 super(x,y);를 집어넣어서 Point(int x, int y)를 호출하도록 변경하면 된다.
 */
```

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 한다.**



### 3. package와 import

---

#### 3.1 패키지(package)

패키지 : 클래스의 묶음

ex) 

- String 클래스의 실제 이름은 java.lang.String이다. java.lang패키지에 속한 String 클래스라는 의미

```
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분잘 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
```

#### 3.2 패키지의 선언

- 패키지명은 대소문자 모두 허용하지만 소문자로 하는 것이 원칙
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다.

```
소스파일의 맨 위에 다음과 같이 한 줄만 적어주면 된다.

package 패키지명;
```

- JVM이 클래스를 찾을수 있게 com.codechobo.book; 이 패키지면 환경변수를 CLASSPATH에다가 패키지 경로를 지정해야한다.
  - 상위 디렉토리가 C:\jdk1.8\work이면 .;C:\jdk1.8\work
  - .; 를 추가한 이우는 현재 디렉토리(.)를 클래스패스에 포함시키기 위해서

#### 3.3 import문

- import문은 컴파일 시에 처리되므 프로그램 성능 영향없음.

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기엔 불편하다.

그래서 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략가능

```
일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
	1. package문
	2. import문
	3. 클래스 선언
	
import문 선언방법
	import 패키지명.클래스명;
			또는
	import 패키지명.*;
	
	
ex)
	import java.util.Calendar;
	import java.util.Date;
	improt java.util.ArrayList;
	
	// 한번에
	import java.util.*;
```

#### 하지만 *은 하위 패키지의 클래스까지 포함하는 것은 아니다.

```java
import java.util.*;
import java.text.*;

// 위의 두 문장 대신 다음과 같이 할 수는 없다.
// import java.* 의 의미는 java패키지의 모든 클래스를 의미한다.(패키지는 포함안됨)
import java.*;
```

예제

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class ImportTest {
    public static void main(String[] args) {
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println("오늘 날짜는 " +date.format(today));
        System.out.println("현재 시간은 "+time.format(today));
    }
}
/* 만약 import문을 지정하지 않았다면 다음과 같이 클래스이름에 패키지명도 적어줘야 했다.

java.util.Date today = new java.util.Date();
java.text.SimpleDateFormat date = new java.text.SimpleDateFormat("yyyy/MM/dd");
java.text.SimpleDateFormat time = new java.time.SimpleDateFormat("hh:mm:ss a");
*/
```

**참고**

- System 과 String 같은 java.lang패키지의 클래스들은 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 다음과 같은 import문이 선언되어 있기 때문이다
  - import java.lang.*;
    - java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 되도록 한 것이다.

#### 3.5 static import 문

- static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```
import static java.lang.Integer.*;		// Integer클래스의 모든 static메소드
import static java.lang.Math.random();	// Math 생략가능
import static java.lang.System.out;		// System.out을 out으로만 참조가능
```

```java
//예제

import static java.lang.System.out;
import static java.lang.Math.*;
class StaticImportEx1 {
    public static void main(String[] args) {
        // System.out.println(Math.random());
        out.println(random());
        // System.out.println("Math.PI : " + Math.PI);
        out.println("Math.PI : "+PI);
    }
}
```

