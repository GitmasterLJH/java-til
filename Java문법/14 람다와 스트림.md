# Chapter14 람다와 스트림

## 1. 람다식(Lambda expression)

람다식(lambda expression)은 JDK1.8부터 추가되었다.

람다식의 도입으로 인해, 자바는 **객체지향언어인 동시에 함수형 언어**가 되었다.

<br/>

<br/>

<br/>

## 1.1 람다식이란?

**람다식** : 메서드를 하나의 식으로 표현한 것

- 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, **익명 함수**(anonymous function)이라고도 함
- 메서드를 사용하기 위해서는 클래스, 객체 생성을 해야만 호출 가능, 그러나 람다식은 이 과정이 불필요하다.

<br/>

> 메서드 : 객체의 행위나 동작을 의미 
>
> - 메서드는 함수와 같은 의미이지만, 특정 클래스에 반드시 속해야 한다는 제약이 있기 때문에 기존의 함수와 같은 의미의 다른 용어를 선택해서 사용한 것이다.
> - 이제 람다식을 통해 메서드가 하나의 독립적인 기능을 하기에 함수라는 용어를 사용함

<br/>

<br/>

<br/>

## 1.2 람다식 작성하기

```
반환 타입 메서드이름(매개변수 선언){
	문장들
}


메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 `->`를 추가한다.


(매개변수) -> {
	문장들
}
```

<br/>

메서드 max를 람다식으로 변환

```java
int max(int a, int b){
    return a > b ? a : b;
}

// 람다식 변환
(int a, int b) ->{
    return a > b ? a : b;
}
```

<br/>

반환값이 있는 메서드의 경우, return문 대신 식으로 대신 할 수있다.(단일 표현식인 경우)

식의 연산결과가 자동적으로 반환값이 된다. 이때 문장(statement)이 아닌 식이므로 끝에 `;`를 붙이지 않는다.

```java
(int a, int b) -> { return a > b ? a : b; }

// 아래와 같이 가능
(int a, int b) -> a > b ? a : b 
```

<br/>

람다식에 선언된 매개변수의 타입이 추론 가능한 경우 생략할 수 있다. 대부분의 경우 생략 가능

```java
(a, b) -> a > b ? a : b
```

> `(int a,b) -> a > b ? a: b`와 같이 두 매개변수 중 어느 하나의 타입만 생략하는 것은 불가능

<br/>

선언된 매개변수가 하나뿐인 경우에는 괄호() 생략할 수 있다. 단, 매개변수의 타입이 있으면 생략 불가

```java
(a) -> a * a
(int a) -> a * a
----------------------
a -> a * a	// OK
int a -> a * a	// 에러
```

<br/>

괄호{} 안의 문장이 하나일 때는 괄호{}를 생략할 수있다. 이때 문장 끝에 `;` 붙이면 안됨

```java
(String name, int i) -> {
    System.out.println(name+"="+i);
}
-----------------------
(String name, int i) -> System.out.println(name+"="+i)
```

<br/>

<br/>

#### 메서드를 람다식으로 변환하기!

```java
int max(int a, int b){
	return a > b ? a : b;
}
```

- `(int a, int b) -> { return a > b ? a : b; }`
- `(int a, int b) -> a > b ? a : b`
- `(a, b) -> a > b ? a : b`

<br/>

<br/>

```java
int square(int x){
    return x * x;
}
```

- `(int x) -> { return x *x; }`
- `(x) -> x * x`
- `x -> x * x`

<br/>

<br/>

```java
void printVar(String name, int i){
    System.out.println(name+"="+i);
}
```

- `(String name, int i) -> { System.out.println(name+"="+i); }`
- `(name, i) -> { System.out.println(name+"="+i); }`
- `(name, i) -> System.out.println(name+"="+i)`

<br/>

<br/>

```java
int roll(){
    return (int) (Math.random()*6);
}
```

- `() -> { return (int) (Math.random()*6); }`
- `() -> (int) (Math.random()*6)`

<br/>

<br/>

```java
int sumArr(int[] arr){
    int sum = 0;
    for(int i : arr)
        sum += i;
    return sum;
}
```

- `(int[] arr) -> {
      int sum = 0;
      for(int i : arr)
          sum += i;
      return sum;
  }`

<br/>

<br/>

<br/>

## 1.3 함수형 인터페이스(Functional Interface)

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데,  람다식은 **익명 클래스의 객체**와 동등하다.

```java
(int a, int b) -> a > b ? a : b		
    
------------------------------
    
new Object(){
    int max(int a, int b){
        return a > b ? a : b;
    }
}
```

<br/>

람다식으로 정의된 익명 객체의 메서드를 호출하기 위해서 람다식과 동등한 메서드가 정의되어 있는 참조변수로 익명 객체(람다식)의 메서드를 호출해야 한다.

<br/>

람다식을 다루기 위한 인터페이스를 **함수형 인터페이스**(Functional Interface)라고 한다.

```java
@FunctionalInterface
interface MyFunction{	// 함수형 인터페이스 MyFunction을 정의
    public abstract int max(int a, int b);
}
```

이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성 가능

```java
MyFunction f = new MyFunction(){
    public int max(int a, int b){
        return a > b ? a : b;
    }
};
```

<br/>

MyFunction인터페이스에 정의된 메서드 max()는 람다식과 메서드의 선언부가 일치하는 것을 볼 수 있다.

그래서 위 코드의 익명 객체를 람다식으로 아래와 같이 대체 가능

- 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다.

```java
MyFunction f = (int a, int b) -> a > b ? a : b;	// 익명 객체를 람다식으로 대체
int big = f.max(5,3) // 익명 객체의 메서드를 호출
```

<br/>

<br/>

### 함수형 인터페이스 규칙

- 오직 하나의 추상 메서드만 정의되어 있어야한다.
  - 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기에
- static메서드와 default메서드의 개수에는 제약이 없음

<br/>

<br/>

#### Collections.sort()에서 람다식

```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");

Collections.sort(list, new Comparator<String>(){
   public int compare(String s1, String s2){
       return s2.compareTo(s1);
   } 
});
```

위 코드를 아래와 같이 람다식으로 간단히 할 수 있음

```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");
Collections.sort(list, (s1,s2) -> s2.compareTo(s1));
```

<br/>

<br/>

### 함수형 인터페이스 타입의 매개변수와 반환타입

```java
@FunctionalInterface
interface MyFunction{
	void myMethod();
}
```

위와 같이 함수형 인터페이스(MyFunction)가 정의되어 있을때 메서드의 매개변수가 MyFunction타입이면, 이 메서드를 호출할 때 **람다식을 참조하는 참조변수를 지정**해야한다는 뜻이다.

```java
void aMethod(MyFunction f){	// 매개변수의 타입이 함수형 인터페이스
    f.myMethod();	// MyFunction에 정의된 메서드 호출
}

MyFunction f = () -> System.out.println("myMethod()");
aMethod(f);
```

또는 참주변수 없이 아래와 같이 직접 람다식을 매개변수로 지정하는 것도 가능

```java
aMethod( () -> System.out.println("myMethod()") ); // 람다식을 매개변수로 지정
```

람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 즉, 변수처럼 메서드를 주고받는것이 가능해진다. 사실상 메서드가 아니라 객체를 주고받는 것이라 근본적으로 달라진 것은 없지만, 람다식 덕분에 코드가 더 간결해짐

<br/>

<br/>

#### 예제

``` java
@FunctionalInterface
interface MyFunction{
    void run(); // public abstract void run();
}

public class LambdaEx1 {
    static void execute(MyFunction f){  // 매개변수 타입이 MyFunction인 메서드
        f.run();
    }

    static MyFunction getMyFunction() { // 반환 타입이 MyFunction인 메서드
        MyFunction f = () -> System.out.println("f3.run()");
        return f;
    }

    public static void main(String[] args) {
        // 람다식으로 MyFunction의 run()을 구현
        MyFunction f1 = () -> System.out.println("f1.run()");

        MyFunction f2 = new MyFunction() {      // 익명 클래스로 run()을 구현
            @Override
            public void run() {
                System.out.println("f2.run()");
            }
        };
        MyFunction f3 = getMyFunction();

        f1.run();	// f1.run()
        f2.run();	// f2.run()
        f3.run();	// f3.run()

        
        // 참조변수 f1을 메서드에 전달
        execute(f1);	// f1.run()
        
        // 람다식을 직접 매개변수로 전달
        execute(() -> System.out.println("run()"));	// run()

    }
}
```

<br/>

<br/>

### 람다식의 타입과 형변환

함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다.

람다식은 익명 객체이고 익명 객체는 타입이 없다.(정확히는 타입은 있지만 컴파일러가 임의로 이름을 정하기에 알 수 없는 것)

그래서 대입 연산자의 양변의 타입을 일치시키기 위해 아래와 같이 형변환이 필요함

```java
MyFunction f = (MyFunction) (()-> {});	// 양변의 타입이 다르므로 형변환 필요
```

람다식은 MyFunction인터페이스를 직접 구현하지 않았지만, 이 인터페이스를 구현한 클래스의 객체와 완전히 동일하기 때문에 위와 같은 형변환을 허용한다. 그리고 이 **형변환은 생략가능**

<br/>

<br/>

람다식은 이름이 없을 뿐 분명히 객체인데도, Object타입으로는 형변환 할 수없다. 오직 함수형 인터페이스로만 형변환 가능

```java
Object obj = (Object) (()->{});	// 에러

// 굳이 형변환 하고 싶으면 먼저 함수형 인터페이스로 변환해야함
Object obj = (Object)(MyFunction)(()->{});
String str = ((Object)(MyFunction)(()->{})).toString();
```

<br/>

#### 예제

컴파일러가 람다식의 타입을 어떤 형식으로 만들어내는지 알아보는 예제

람다식의 타입 : **외부클래스이름$$Lambda** 같은 형식으로 되어있음

```java
@FunctionalInterface
interface MyFunction{
    void run(); // public abstract void run();
}

public class LambdaEx2 {
    public static void main(String[] args) {
        MyFunction f = () -> {};    // MyFunction f = (MyFunction) (()->{});
        Object obj = (MyFunction) (()->{}); // Object타입으로 형변환이 생략됨
        String str = ((Object)(MyFunction)(()->{})).toString();

        System.out.println(f);		// LambdaEx2$$Lambda/0x000001fe64003bf8@7291c18f
        System.out.println(obj);	// LambdaEx2$$Lambda/0x000001fe64003400@34a245ab
        System.out.println(str);	// LambdaEx2$$Lambda/0x000001fe64004000@1d81eb93

   //   System.out.println(()->{}); 에러. 람다식은 Object타입으로 형변환 x
        
        System.out.println((MyFunction)(()->{}));	// LambdaEx2$$Lambda/0x000001fe64004218@6e8cf4c6
  
   //   System.out.println((MyFunction)(()->{}).toString());     에러
        
        
         // LambdaEx2$$Lambda/0x000001fe64004430@34c45dca
        System.out.println(((Object)(MyFunction)(()->{})).toString());	
      
    }
}
```

<br/>

<br/>

### 외부 변수를 참조하는 람다식

람다식도 익명 객체, 즉 **익명 클래스의 인스턴스**이므로 람다식에서 외부에 선언된 변수에 접근하는 규칙은 익명 클래스와 동일하다.

- **인스턴스 변수**나 **지역 변수**에 접근할 수 있다.
- 지역변수는 **`final` 또는 `effectively final`이어야**만 한다.

```java
@FunctionalInterface
interface MyFunction{
    void myMethod();
}
class Outer{
    int val= 10; // Outer.this.val

    class Inner{
        int val = 20; // this.val

        void method(int i){     //  void method(final int i)
            int val = 30;       // final int val=30;
        //    i = 10; 에러 상수값 변경 불가

            MyFunction f = () -> {
                System.out.println("i : "+ i);
                System.out.println("val : "+val);
                System.out.println("this.val : "+ ++this.val);
                System.out.println("Outer.this.val : "+ ++Outer.this.val);
            };
            f.myMethod();
        }
    }
}

public class LambdaEx3 {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.method(100);
    }

}
/*결과
i : 100
val : 30
this.val : 21
Outer.this.val : 11
*/
```

<br/>

또한 외부 지역 변수와 같은 이름의 람다식 매개변수는 허용되지 않는다.

```java
void method(int i){
    int val = 30;
    
    MyFunction f = (int val) -> {	// 에러 외부 지역변수의 이름이 중복됨
        System.out.println("ABCD");
    };
    
    MyFunction f = (int i) ->{	// 에러 외부 매개변수와 이름이 중복
        System.out.println("ABCD");
    };
}
```

<br/>

<br/>

<br/>

## 1.4 java.util.function 패키지

java.util.function패키지에 일반적으로 **자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의**해 놓았다.

![Image](https://github.com/user-attachments/assets/70499b75-1dc1-40fd-99e7-80df2a541c89)

<br/>

```java
Supplier<Integer> f = () -> (int)(Math.radnom()*100)+1;
Consumer<Integer> f = i -> System.out.print(i+", ");
Predicate<Integer>f = i -> i%2==0;
Function<Integer,Integer> f = i -> i/10*10;
```

<br/>

<br/>

#### 조건식의 표현에 사용되는 Predicate

Predicate는 Function에 변형으로, 반환타입이 boolean이라는 것만 다르다.

> 수학에서 결과로 true 또는 false를 반환하는 함수를 predicate라고 한다.

```java
Predicate<String> isEmptyStr = s -> s.length() == 0;
String s = "";

if(isEmptyStr.test(s))
    System.out.println("This is an empty String.");
```

<br/>

<br/>

### 매개변수가 2개인 함수형 인터페이스

이름 앞에 접두사 `Bi`가 붙는다.

![Image](https://github.com/user-attachments/assets/9b7b8004-a793-4aa2-91b2-6a91633a7cf6)

> Supplier는 매개변수는 없고 반환값만 존재하는데, 메서드는 두 개의 값을 반환할 수 없으므로 BiSupplier가 없는 것이다.

<br/>

매개변수가 3개인 함수형 인터페이스가 필요하다면 다음과 같이 직접 만들어 써야한다.

```java
@FunctionalInterface
interface TriFunction<T,U,V,R>{
    R apply(T t, U u, V v);
}
```

<br/>

<br/>

### 매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스

Function의 또 다른 변형으로 UnaryOperator와 BinaryOperator가 있다.

```java
public interface UnaryOperator<T> extends Function<T, T> 

public interface BinaryOperator<T> extends BiFunction<T,T,T>
```

![Image](https://github.com/user-attachments/assets/d4820704-159c-4bc3-9faa-75ef319cd61f)

<br/>

<br/>

### 컬렉션 프레임웍과 함수형 인터페이스

컬렉션 프레임웍의 인터페이스에 다수의 디폴트 메서드들이 추가되었는데, 그 중 일부는 함수형 인터페이스를 사용한다.

![Image](https://github.com/user-attachments/assets/61b78c0f-2792-41c3-9210-e70eba704293)

Map인터페이스에 있는 compute로 시작하는 메서드들은 맵의 value를 변환하는 일을 한다.

<br/>

#### 예제1

위 메서드의 기본적인 사용법

```java
import java.util.*;

public class LambdaEx4 {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < 10; i++)
            list.add(i);

        list.forEach(i -> System.out.print(i + ","));	// 0,1,2,3,4,5,6,7,8,9,
        System.out.println();
.
        list.removeIf(x -> x % 2 == 0 || x % 3 == 0);
        System.out.println(list);	// [1, 5, 7]

        list.replaceAll(i -> i * 10); 
        System.out.println(list);		// [10, 50, 70]

        Map<String, String> map = new HashMap<>();
        map.put("1", "1");
        map.put("2", "2");
        map.put("3", "3");
        map.put("4", "4");

        map.forEach((k, v) -> System.out.print("{" + k + "," + v + "},"));	// {1,1},{2,2},{3,3},{4,4},
    }
}
```

<br/>

<br/>

#### 예제2

java.util.function 함수형 인터페이스들 사용법

```java
import java.util.function.*;
import java.util.*;

public class LambdaEx5 {
    public static void main(String[] args) {
        Supplier<Integer> s = () -> (int) (Math.random() * 100) + 1;
        Consumer<Integer> c = i -> System.out.print(i + ", ");
        Predicate<Integer> p = i -> i % 2 == 0;
        Function<Integer, Integer> f = i -> i / 10 * 10; // 일의자리 없애기, = UnaryOperator<Integer>

        List<Integer> list = new ArrayList<>();
        makeRandomList(s,list);
        System.out.println(list);	// [48, 46, 69, 66, 37, 78, 72, 3, 85, 32]
        	

        printEvenNum(p,c,list);		// [48, 46, 66, 78, 72, 32, ]

        List<Integer> newList = doSomething(f,list);
        System.out.println(newList);		// [40, 40, 60, 60, 30, 70, 70, 0, 80, 30]
    }

    static <T> List<T> doSomething(Function<T, T> f, List<T> list) {
        List<T> newList = new ArrayList<>(list.size());

        for (T i : list)
            newList.add(f.apply(i));
        return newList;
    }

    static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
        System.out.print("[");
        for (T i : list) {
            if (p.test(i))
                c.accept(i);
        }
        System.out.println("]");
    }

    static <T> void makeRandomList(Supplier<T> s, List<T> list){
        for(int i=0; i<10; i++)
            list.add(s.get());
    }
}
```

<br/>

<br/>

### 기본형을 사용하는 함수형 인터페이스

지금까지 기본형 타입의 값을 처리할 때도 wrapper클래스를 사용했는데 이는 비효율적이다.

보다 효율적으로 처리할 수 있도록 기본형을 사용하는 함수형 인터페이스들이 제공된다.

<br/>

#### Consumer 인터페이스

XXX는 Double, Long, Int

실행메서드 : `accept()`

| 형태                | 내용                              |
| ------------------- | --------------------------------- |
| `XXXConsumer`       | XXX형태의 인자값을 받는다.        |
| `ObjXXXConsumer<T>` | T, XXX형태의 인자값 2개를 받는다. |

<br/>

**종류**

- `DoubleConsumer`
  - void accept(double value)
- `LongConsumer`
  - void accept(long value)
- `IntConsumer`
  - void accpet(int value)

<br/>

- `ObjDoubleConsumer<T>`
  - void accpet(T t, double value)
- `ObjLongConsumer<T>`
  - void accept(T t, long value)
- `ObjIntConsumer<T>`
  - void accpet(T t, int value)

<br/>

<br/>

#### Supplier 인터페이스

XXX는 Boolean, Double, Int, Long

실행메서드 : `getAsXXX()`

| 형태          | 내용       |
| ------------- | ---------- |
| `XXXSupplier` | XXX형 반환 |

<br/>

**종류**

- `BooleanSupplier`
  - boolean getAsBoolean()
- `DoubleSupplier`
  - double getAsDouble()
- `IntSupplier`
  - int getAsInt()
- `LongSupplier`
  - long getAsLong()

<br/>

<br/>

#### Function 인터페이스

xxx는 Double, Int, Long

실행메서드 : `applyXXX()`

| 형태                    | 내용                 |
| ----------------------- | -------------------- |
| `XXXFunction<R>`        | XXX 받아서 T 리턴    |
| `XXXToYYYFunction`      | XXX 받아서 YYY 리턴  |
| `ToXXXFunction<T>`      | T 받아서 XXX 리턴    |
| `ToXXXBiFunction<T, U>` | T, U 받아서 XXX 리턴 |

<br/>

**종류**

- `DoubleFunction<R>`
  - R apply(double value)
- `IntFunction<R>`
  - R apply(int value)
- `LongFunction<R>`
  - R apply(long value)

<br/>

- `DoubleToIntFunction`
  - int applyAsInt(double value)
- `DoubleToLongFunction`
  - int applyAsLong(doulbe value)
- `IntToDoubleFunction`
  - double applyAsDouble(int value)
- `IntToLongFunction`
  - long applyAsLong(int value)
- `LongToDoubleFunction`
  - double applyAsDouble(long value)
- `LongToIntFunction`
  - int applyAsInt(long value)

<br/>

- `ToDoubleFunction<T> `
  - double applyAsDouble(T value)
- `ToIntFunction<T>`
  - int applyAsInt(T value)
- `ToLongFunction<T>`
  - long applyAsLong(T value)

<br/>

- `ToDoubleBiFunction<T, U>`
  - double applyAsDouble(T t, U u)
- `ToIntBiFunction<T, U>`
  - int applyAsInt(T t, U u)
- `ToLongBiFunction<T, U>`
  - long applyAsLong(T t, U u)

<br/>

<br/>

#### Operator 인터페이스

xxx는 Double, Int, Long

실행메서드 : `applyAsXXX()`

| 형태              | 내용              |
| ----------------- | ----------------- |
| XXXUnaryOperator  | XXX 타입 1개 연산 |
| XXXBinaryOperator | XXX 타입 2개 연산 |

<br/>

**종류**

- `DoubleUnaryOperator`
  - double applyAsDouble(double operand)
- `DoubleBinaryOperator`
  - double applyAsDouble(double left, double right)
- `IntUnaryOperator`
  - int applyAsInt(int operand)
- `IntBinaryOperator`
  - int applyAsInt(int left, int right)
- `LongUnaryOperator`
  - long applyAsLong(long operand)
- `LongBinaryOperator`
  - long applyAsLong(long left, long right)

<br/>

<br/>

#### Predicate 인터페이스

XXX는 Double, Int, Long

실행메서드 : `test()`

| 형태           | 내용                      |
| -------------- | ------------------------- |
| `XXXPredicate` | XXX를 받아서 boolean 리턴 |

<br/>

**종류**

- `DoublePredicate`
  - boolean test(double value)
- `IntPredicate`
  - boolean test(int value)
- `LongPredicate`
  - boolean test(long value)

<br/>

<br/>

#### 이전 예제를 기본형으로 사용하는 함수형 인터페이스로 변경한 예제

```java
package Lambda;


import java.util.function.*;
import java.util.*;

public class LambdaEx6 {
    public static void main(String[] args) {
        IntSupplier s = () -> (int) (Math.random() * 100) + 1;
        IntConsumer c = i -> System.out.print(i + ", ");
        IntPredicate p = i -> i % 2 == 0;
        IntUnaryOperator op = i -> i / 10 * 10; // 일의자리 없애기

        int [] arr = new int[10];

        makeRandomList(s,arr);
        System.out.println(Arrays.toString(arr));
        printEvenNum(p,c,arr);
        int[] newArr = doSomething(op,arr);
        System.out.println(Arrays.toString(newArr));

    }

    static int[] doSomething(IntUnaryOperator op, int[] arr){
        int[] newArr = new int[arr.length];

        for(int i=0; i<newArr.length;i++){
            newArr[i] = op.applyAsInt(arr[i]);
        }
        return newArr;
    }

   static void printEvenNum(IntPredicate p, IntConsumer c, int[] arr){
        System.out.print("[");
        for(int i : arr){
            if(p.test(i))
                c.accept(i);
        }
        System.out.println("]");
   }

    static void makeRandomList(IntSupplier s, int[] arr){
        for(int i=0; i<arr.length;i++)
            arr[i] = s.getAsInt();
    }
}
```

<br/>

<br/>

<br/>

## 1.5 Function의 합성과 Predicate의 결합

java.util.function 패키지의 함수형 인터페이스에는 추상메서드 외에도 디폴트 메서드와 static메서드가 정의되어 있다.

<br/>

### 1. Function의 합성

#### 두 함수를 `andThen()`으로 합성하여 새로운 함수 h를 만들어내기

```java
//  this 함수가 먼저 실행되고 그 결과가 after 함수로 전달됨
// T -> Function<T,R> -> FUnction<R,V> -> V

default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
    Objects.requireNonNull(after);
    return (T t) -> after.apply(apply(t));
}
```

```java
Function<String, Integer> f = (s) -> Integer.parseInt(s,16);	// 문자열을 숫자로 변환하는 함수 f
Function<Integer, String> g = (i) -> Integer.toBinaryString(i);	// 숫자를 2진 문자열로 변환하는 함수 g
Function<String, String> h = f.andThen(g);

System.out.println(h.apply("FF"));	// "FF" -> 255 -> "11111111"
```

![Image](https://github.com/user-attachments/assets/188a0b41-2309-41f6-afa5-f2ebf28fbc2e)

<br/>

<br/>

#### `compose()`를 이용해서 두 함수를 반대의 순서로 합성하기

```java
// 먼저 before 함수를 실행한 후 그 결과에 현재 Function을 적용한다.
// V-> Function<V,T> -> Function<T,R> -> R

default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
    Objects.requireNonNull(before);
    return (V v) -> apply(before.apply(v));
}
```

```java
Function<Integer, String> g = (i) -> Integer.toBinaryString(i);	// 숫자를 2진 문자열로 변환하는 함수 g
Function<String, Integer> f = (s) -> Integer.parseInt(s,16);	// 문자열을 숫자로 변환하는 함수 f

Function<Integer, Integer> h = f.compose(g);

System.out.println(h.apply(2));	// 2 -> "10" -> 16
```

![Image](https://github.com/user-attachments/assets/28356935-c11a-4270-901b-2f064aa15c03)

<br/>

<br/>

#### `identity()`

함수를 적용하기 이전과 이후가 동일한 항등 함수가 필요할 때 사용

```java
// T 타입의 값을 그대로 반환하는 함수
static <T> Function<T, T> identity() {
    return t -> t;
}
```

```java
Function<String, String> f = x -> x;
// Function<String, String> f = Function.identity();	// 위의 문장과 동일

System.out.println(f.apply("AAA"));	// AAA가 그대로 출력됨
```

<br/>

<br/>

### 2. Predicate의 결합

```java
boolean test(T t);

default Predicate<T> and(Predicate<? super T> other) {
    Objects.requireNonNull(other);
    return (t) -> test(t) && other.test(t);
}


default Predicate<T> negate() {
    return (t) -> !test(t);
}

default Predicate<T> or(Predicate<? super T> other) {
    Objects.requireNonNull(other);
    return (t) -> test(t) || other.test(t);
}

static <T> Predicate<T> isEqual(Object targetRef) {
    return (null == targetRef)
        ? Objects::isNull
        : object -> targetRef.equals(object);
}

@SuppressWarnings("unchecked")
static <T> Predicate<T> not(Predicate<? super T> target) {
    Objects.requireNonNull(target);
    return (Predicate<T>)target.negate();
}
```

<br/>

<br/>

```java
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i%2 == 0;
Predicate<Integer> notP = p.negate();	// i >= 100

// 100 < = i && (i <200 || i%2 == 0)
Predicate<Integer> all = notP.and(q.or(r));
```

아래와 같이 람다식을 직접 넣어도 됨

```
Predicate<Integer> all = notP.and(i-> i < 200).or(i-> i%2==0);
```

<br/>

static메서드인 `isEqual()`은 두 대상을 비교하는 Predicate를 만들 때 사용한다. 먼저, isEqual()의 매개변수로 비교대상을 하나 지정하고 또 다른 비교대상은 test()의 매개변수로 지정한다.

```java
Predicate<String> p = Predicate.isEqual(str1);
boolean result = p.test(str2);	// str1과 str2가 같은지 비교하여 결과를 반환

// 위의 두 문장을 합치면 아래와 같다.
boolean result = Predicate.isEqual(str1).test(str2);
```

<br/>

<br/>

<br/>

## 1.6 메서드 참조

람다식이 하나의 메서드만 호출하는 경우에 **메서드 참조**(method reference)라는 방법으로 람다식을 더욱 간결하게 표현 가능하다.

```java
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```

위 람다식을 메서드로 표현하면 아래와 같다.

```java
Integer wrapper(String s){	// 이 메서드의 이름은 의미없다.
    return Integer.parseInt(s);
}
```

이 wrapper메서드는 단지 값을 받아서 Integer.parseInt()에게 넘겨주는 일만 한다.

차라리 메서드를 벗개내고 Integer.parseInt()를 직접호출 하는게 낫다

```java
Function<String, Integer> f = Integer::parseInt;	// 메서드 참조
```

위의 메서드 참조에서 람다식의 일부가 생략되었지만, 컴파일러는 생략된 부분을 우변의 parseInt메서드의 선언부로부터, 또는 좌변의 Function인터페이스에 지정된 지네릭 타입으로부터 쉽게 알아낼 수 있다.

<br/>

<br/>

```java
BiFunction<String, String, Boolean> f = (s1,s2) -> s1.equals(s2);
```

위 람다식의 경우 참조변수 f의 타입만 봐도 람다식이 두 개의 String타입의 매개변수를 받는 것을 알 수 있으므로, 람다식의 매개변수들은 없어도 된다.

```java
BiFunction<String, String, Boolean> f = String::equals();	// 메서드 참조
```

두 개의 String을 받아서 Boolean을 반환하는 equals라는 이름의 메서드는 다른 클래스에도 존재할 수 있기에 equals앞에 클래스 이름은 반드시 필요하다.

<br/>

이미 생성된 객체의 메서드를 람다식에서 사용한 경우에는 클래스 이름 대신 그 객체의 참조변수를 적어줘야 함

```java
MyClass obj = new MyClass();
Function<String, Boolean> f = (x) -> obj.equals(x);	// 람다식
Function<String, Boolean> f2 = obj::equals;	// 메서드 참조
```

<br/>

### 메서드 참조 방식 정리

| 종류                           | 람다                      | 메서드 참조       |
| ------------------------------ | ------------------------- | ----------------- |
| static 메서드 참조             | (x)->ClassName.method(x)  | ClassName::method |
| 인스턴스메서드 참조            | (obj, x) -> obj.method(x) | ClassName::method |
| 특정 객체 인스턴스 메서드 참조 | (x) -> obj.method(X)      | obj::method       |

```
하나의 메서드만 호출하는 람다식은
	`클래스이름::메서드이름` 또는 `참조변수::메서드이름` 으로 바꿀 수 있다.
```

<br/>

<br/>

### 생성자의 메서드 참조

생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.

```java
Supplier<MyClass> s = () -> new MyClass();	// 람다식
Supplier<MyClass> s = MyClass::new;		// 메서드 참조
```

<br/>

매개변수가 있는 생성자라면, 매개변수의 개수에 따라 알맞은 함수형 인터페이스를 사용하거나 필요하다면 함수형 인터페이스를 새로 정의해야 한다.

```java
Function<Integer, MyClass> f = (i) -> new MyClass();	// 람다식
Function<Integer, MyClass> f2 = MyClass::new; // 메서드 참조

BiFunction<Integer, String, MyClass> bf = (i,s) -> new MyClass(i, s);
BiFunction<Integer, String, MyClass> bf = MyClas::new;	// 메서드 참조
```

배열 생성방법

```java
Function<Integer, int[]> f = x -> new int[x];	// 람다식
Function<Integer, int[]> f = int[]::new;	// 메서드 참조
```

메서드 참조는 람다식을 마치 static 변수처럼 다룰 수 있게 해준다.

<br/>

--------------------------

<br/>

## 2. 스트림(stream)

## 2.1 스트림이란?

다양한 **데이터 소스를 표준화된 방법**으로 다루기 위한 것

- 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 됨

```java
String[] strArr = { "aaa", "ddd", "ccc"};
List<String> strList = Arrays.asList(strArr);
```

이 두 데이터 소스를 기반으로 하는 스트림 생성

```java
Stream<String> strStream1 = strList.stream();
Stream<String> strStream2 = Arrays.stream(strArr);
```

이 두 스트림으로부터 데이터 소스의 데이터를 읽어서 정렬하고 화면에 출력 예제

```java
// 두 스트림의 데이터 소스는 서로 다르지만 정렬하고 출력하는 방법은 동일하다.
strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);

// 이전에는 아래와 같이 코드를 작성했어야 했음
Arrays.sort(strArr);
Collections.sort(strList);

for(String str : strArr)
    System.out.println(str);

for(String str : strList)
    System.out.println(str);
```

<br/>

<br/>

### 스트림은 데이터 소스를 변경하지 않는다.(ReadOnly)

스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다.

<br/>

<br/>

### 스트림은 일회용이다.

스트림은 Iterator처럼 일회용이다. 최종연산 후 스트림은 닫혀서 다시 사용할 수 없다.

```java
strStream1.sorted().forEach(System.out::println);	// (str) -> System.out.println(str)
int numOfStr = stream1.count();	// 에러. 스트림이 이미 닫혔음
```

<br/>

<br/>

### 스트림은 작업을 내부 반복으로 처리한다.

**내부 반복** : 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미

스트림을 이용한 작업이 간결한 이유중 하나는 내부 반복이다.

![Image](https://github.com/user-attachments/assets/972e42da-7298-4eb6-a638-a3a4821c0a51)

`forEach()`는 메서드 안으로 for문을 넣은 것. 수행할 작업은 매개변수로 받는다.

```java
void forEach(Consumer<? super T> action){
    Objects.requireNonNull(action);	// 매개변수 널 체크
    
    for(T t : src){
        action.accept(T);
    }
}
```

<br/>

<br/>

### 스트림의 연산

스트림에 정의된 메서드 중에서 **데이터 소스를 다루는 작업을 수행하는 것**을 연산이라고 한다.

```
중간 연산	:	연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
최종 연산	:	연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능
```

![Image](https://github.com/user-attachments/assets/c52d6f7f-0977-4099-9d38-145531b0204a)

모든 중간 연산의 결과는 스트림이지만, 연산 전의 스트림과 같은 것은 아니다.

<br/>

<br/>

### 지연된 연산

최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다.

중간 연산은 **최종 연산이 호출될 때 한꺼번에 처리**된다.

```java
IntStream intStream = new Random().ints(1,46);	// 1~45범위의 무한 스트림
intStream.distinct().limit(6).sorted()	// 중간연산
    .forEach(i -> System.out.print(i+","));  // 최종연산
```

<br/>

<br/>

### `Stream<Integer>`와 `IntStream`

오토박싱&언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림이 제공된다.

- IntStream, LongStream, DoubleStream

<br/>

<br/>

### 병렬 스트림

스트림으로 데이터를 다룰 때의 장점 중 하나가 병렬 처리가 쉽다는 것이다.

> parallel()과 sequential()은 새로운 스트림을 생성하는 것이 아니라, 그저 스트림의 속성을 변경할 뿐이다.

```java
Stream<String> strStream = Stream.of("dd","aaa","CC","cc","b");
int sum = strStream.parallel()	// strStream을 병렬 스트림으로 전환
    .mapToInt(s-> s.length())
    .sum();
```

<br/>

<br/>

<br/>

## 2.2 스트림 만들기

### 컬렉션

컬렉션의 최고 조상인 Collection에 `stream()`이 정의되어 있다. `stream()`은 해당 컬렉션을 source로 하는 스트림을 반환한다.

```java
Stream<T> Collection.stream()
```

<br/>

**List로부터 스트림을 생성하는 예제**

```java
List<Integer> list = Arrays.asList(1,2,3,4,5); // 가변 인자
Stream<Integer> intStream = list.stream();	// list를 소스로 하는 컬렉션 생성
```

<br/>

<br/>

### 배열

**배열을 소스로 하는 스트림을 생성하는 메서드**는 다음과 같이 Stream과 Arrays에 static메서드로 정의되어 있다.

```java
Stream<T> Stream.of(T... values)	// 가변인자
Stream<T> Arrays.stream(T[])
Stream<T> Arrays.stream(T[] array, int startInclusive, int endExclusive)
```

<br/>

**문자열 스트림 생성 예제**

```java
Stream<String> srtStream = Stream.of("a","b","c");
Stream<String> srtStream = Stream.of(new String[]{"a","b","c"});
Stream<String> srtStream = Arrays.stream(new String[]{"a","b","c"});
Stream<String> srtStream = Arrays.stream(new String[]{"a","b","c"}, 0, 3);
```

<br/>

<br/>

**기본형 배열을 소스로 하는 스트림을 생성하는 메서드**들도 있다.(int, long double이 있음)

```java
IntStream IntStream.of(int... values)
IntStream Arrays.stream(int[])
IntStream Arrays.stream(int[] array, int startInclusive, int endExclusive)
```

<br/>

<br/>

### 특정 범위의 정수

IntStream과 LongStream은 다음과 같이 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 메서드를 가지고 있다.

> int보다 큰 범위의 스트림을 생성하려면 LongStream에있는 동일한 이름의 메서드를 사용하면 됨 

```java
IntStream IntStream.range(int begin, int end)
IntStream IntStream.rangeClosed(int begin, int end)

// 사용 예
IntStream intStream = IntStream.range(1,5);	// 1,2,3,4
IntStream intStream = IntStream.rangeClosed(1,5);	// 1,2,3,4,5
```

<br/>

<br/>

### 난수

Random클래스에 아래와 같은 인스턴스 메서드들이 있다. 이 메서드들은 해당 타입의 난수들로 이루어진 스트림을 반환한다.

```java
IntStream ints()
LongStream longs()
DoubleStream doubles()
```

이 메서드들이 반환하는 스트림은 크기가 정해지지 않은 **무한 스트림**(infinite stream)이다.

따라서 `limit()`도 같이 사용해서 스트림의 크기를 제한해 유한 스트림으로 만들어야 함

```java
IntStream intStream = new Random().ints();	// 무한 스트림
intStream.limit(5).forEach(System.out::println); // 5개의 요소만 출력한다.
```

<br/>

매개변수로 스트림의 크기를 지정할 수 있는 메서드들도 있다.(유한 스트림)

```java
IntStream ints(long streamSize)
LongStream longs(long streamSize)
DoubleStream doubles(long streamSize)
    
// 크기가 5인 난수 스트림을 반환
IntStream intStream = new Random().ints(5);	
```

위 메서들에 의해 생성된 스트림의 난수는 아래의 범위를 갖는다.

```java
Integer.MIN_VALUE <= ints() <= Integer.MAX_VALUE
Long.MIN_VALUE <= longs() <= Long.MAX_VALUE
0.0 <= doubles() < 1.0
```

<br/>

지정된 범위(begin~end)의 난수를 발생시키는 스트림을 생성하는 메서드(end는 범위 포함 x)

```java
IntStream ints(int begin, int end)
LongStream longs(long begin, long end)
DoubleStream doubles(double begin, double end)
    
    
IntStream ints(long streamSize, int begin, int end)
LongStream longs(long streamSize, long begin, long end)
DoubleStream doubles(long streamSize, double begin, double end)
```

<br/>

<br/>

### 람다식 - iterate(), generate()

두 메서드 모두  람다식에 의해 게산되는 값들을 요소로 하는 **무한 스트림을 생성**.

#### iterate()

```java
static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
```

seed로 지정된 값부터 시작해서, 람다식 f에 의해 계산된 결과를 다시 seed값으로 해서 계산을 반복한다.

```java
Stream<Integer> evenStream = Stream.iterate(0, n->n+2);	// 0, 2, 4, 6, ...
```

<br/>

#### generate()

```java
static <T> Stream<T> generate(Supplier<T> s)
```

iterate()와 달리, 이전 결과를 이용해서 다음 요소를 계산하지 않음

```java
Stream<Double> randomStream = Stream.generate(Math::random);
Stream<Integer> oneStream = Stream.generate(()->1); // 1, 1, 1, 1, 1, 1, ...
```

<br/>

#### 주의할 점

iterate()와 generate()에 생성된 스트림을 아래와 같이 기본형 스트림 타입으로 다룰 수 없다.

```java
IntStream evenStream = Stream.iterate(0, n->n+2);	//에러
DoubleStream randomStream = Stream.generate(Math::random);	// 에러
```

<br/>

<br/>

### 파일

java.nio.file.Files는 파일을 다루는데 필요한 유용한 메서드들을 제공한다.

`list()`는 지정된 **디렉토리**(dir)에 있는 **파일의 목록을 소스로 하는 스트림**을 생성해서 반환한다.

```java
Stream<Path> Files.list(Path dir)
```

<br/>

파일의 한 행(line)을 요소로 하는 스트림을 생성하는 메서드

```java
Stream<String> Files.lines(Path path)
Stream<String> Files.lines(Path path, Charset cs)
Stream<String> lines()	// BufferedReader클래스의 메서드
```

<br/>

### 빈 스트림

요소가 하나도 없는 비어있는 스트림을 생성 가능

```java
Stream stream = Stream.empty(); // empty()는 빈 스트림을 생성해서 반환
long count = stream.count(); // 스트림 요소의 개수를 반환, 값 : 0
```

<br/>

<br/>

### 두 스트림의 연결

Stream의 static메서드인 `concate()`를 사용하면 , 두 스트림을 하나로 연결할 수 있다.

```java
public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
```

<br/>

```java
String[] str1 = {"123", "456", "789"};
String[] str2 = {"ABC", "abc", "DEF"};

Stream<String> strs1 = Stream.of(str1);
Stream<String> strs2 = Stream.of(str2);
Stream<String> strs3 = Stream.concat(strs1, strs2);
str3.forEach(System.out::println);	// 123456789ABCabcDEF

// 매개변수로 wildcard를 사용했기에 다음과 같이도 됨
Stream<Integer> integerStream = Stream.of(1, 2, 3);
Stream<Double> doubleStream = Stream.of(1.1, 2.2, 3.3);
Stream<Number> resultStream = Stream.concat(integerStream, doubleStream);
```

<br/>

<br/>

<br/>

## 2.3 스트림의 중간연산

| 중간 연산                                                    | 설명                      |
| ------------------------------------------------------------ | ------------------------- |
| `Stream<T> distinct()`                                       | 중복 제거                 |
| `Stream<T> filter (Predicate<T> predicate)`                  | 조건에 안 맞는 요소 제외  |
| `Stream<T> limit(long maxSize)`                              | 스트림의 일부를 잘라낸다. |
| `Stream<T> skip(long n)`                                     | 스트림의 일부를 건너뛴다. |
| `Stream<T> peek(Consumer<T> action)`                         | 스트림의 요소에 작업수행  |
| `Stream<T> sorted()`<br />`Stream<T> sorted(Comparator<T> comparator)` | 스트림의 요소를 정렬      |
| `Stream<R>    map(Function<T,R> mapper)`<br />`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`<br />`IntStream    mapToInt(ToIntFunction<T> mapper)`<br />`LongStream   mapToLong(ToLongFunction<T> mapper)`<br /><br />`Stream<R>    flatMap(Function<T, Stream<R>> mapper)`<br />`DoubleStream flatMapToDouble(Function<T, DoubleStream> m)`<br />`IntStream    flatMapToInt(Function<T, IntStream> m)`<br />`LongStream   flatMapToLong(Function<T, LongStream> m)` | 스트림의 요소를 반환      |

<br/>

<br/>

### skip(), limit() -- 스트림 자르기

```java
Stream<T> skip(long n)		// 처음 n개의 요소를 건너뜀
Stream<T> limit(long maxSize)	// 스트림의 요소를 maxSize개로 제한한다.
```

**예시**

```java
IntStream intStream = IntStream.rangeClosed(1,10);	// 1~10의 요소를 가진 스트림
intStream.skip(3).limit(5).forEach(System.out::print);	// 45678
```

<br/>

<br/>

### filter(), distinct() -- 스트림의 요소 걸러내기

```java
Stream<T> filter (Predicate<T> predicate)	// 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다.
Stream<T> distinct()	// 스트림에서 중복된 요소들 제거
```

**예시**

`distinct()`

```java
IntStream intStream = Instream.of(1,2,2,3,3,3,4,5,5,6);
intStream.distinct().forEach(System.out::print); // 123456
```

`filter()`

```java
IntStream intStream = IntStream.rangeClosed(1,10);	// 1~10
intStream.filter((i) -> i%2==0).forEach(System.out::print);	// 246810

// 아래처럼 다른 조건으로 여러번 사용 가능
inStream.filter(i -> i % 2 != 0 && i % 3 != 0).forEach(System.out::print);    // 157
inStream.filter(i -> i % 2 != 0).filter(i -> i % 3 != 0).forEach(System.out::print);	// 157
```

<br/>

<br/>

### sorted() -- 정렬

```java
Stream<T> sorted()	// 스트림 요소의 기본 정렬 기준(Comparable)로 정렬
Stream<T> sorted(Comparator<T> comparator)	//  지정된 Comparartor로 정렬
```

>  Comparator대신 **int값을 반환하는 람다식을 사용하는 것도 가능**

<br/>

```java
Stream<String> strStream = Stream.of("dd", "aaa", "CC", "cc", "b");
```

### 문자열 스트림을 정렬하는 다양한 방법

![Image](https://github.com/user-attachments/assets/54844772-83bf-4e3e-b02c-e25455c55e77)

<br/>

#### Comparator의 static 메서드

```java
naturalOrder()	// 기본 정렬
reverseOrder()	// 기본정렬의 역순
comparing(Function<T,U> keyExtractor)	// 특정 키 값을 기준으로 정렬
comparing(Function<T,U> keyExtractor, Comparartor<U> keyComparartor)	// 특정 키 값을 사용자 정의 기준으로 정렬
    
// xxx 타입의 키 값을 기준으로 비교하는 Comparator
comparingInt(ToIntFunction<T> keyExtractor)
comparingLong(ToLongFunction<T> keyExtractor)
comparingDouble(ToDoubleFunction<T> keyExtractor)

// null 값을 앞쪽에 배치하는 Comparator
nullsFirst(Comparartor<T> comparartor)
    
// null 값을 뒤쪽에 배치하는 Comparator를 생성
nullsLast(Comparartor<T> comparartor)
```

<br/>

#### Comparartor의 default 메서드

```java
reversed()	// 현재 Comparator의 정렬 방향을 반대로 변경
thenComparing(Comparator<T> other)	// 첫 번째 비교가 동일할 경우, 추가적인 Comparator 적용
thenComparing(Function<T, U> keyExtractor)	// 특정 키 값을 기준으로 추가 정렬
    
// 특정 키 값을 사용자 지정 Comparator 기준으로 추가 정렬    
thenComparing(Function<T, U> keyExtractor, Comparator<U> keyComp) 

// xxx 타입 값 기준 추가 정렬
thenComparingInt(ToIntFunction<T> keyExtractor)	
thenComparingLong(ToLongFunction<T> keyExtractor)
thenComparingDouble(ToDoubleFunction<T> keyExtractor)
```

<br/>

학생 스트림을 반, 성적, 그리고 이름순으로 정렬하여 출력하려면 다음과 같이한다.

```java
studentStream.sorted(Comparartor.comparing(Student::getBan)	// comapring( (Student s) -> s.getBan() )
                    .thenComparing(Student::getTotalScore)
                    .thenComparing(Student::getName)).forEach(System.out::println);
```

<br/>

#### 예제

학생의 성적을 반별 오름차순, 총점별 내림차순으로 정렬하는 예제

```java
package Stream;

import java.util.Comparator;
import java.util.stream.Stream;

public class StreamEx1 {
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("이자바", 3, 300),
                new Student("김자바", 1, 200),
                new Student("안자바", 2, 100),
                new Student("박자바", 2, 150),
                new Student("소자바", 1,200),
                new Student("나자바", 3,290),
                new Student("김자바",3,180)
        );
        studentStream.sorted(Comparator.comparing(Student::getBan)  // 반별 정렬
                .thenComparing(Comparator.naturalOrder()))  // 기본 정렬
                .forEach(System.out::println);
        
        /* 
        [김자바, 1, 200]
        [소자바, 1, 200]
		[박자바, 2, 150]
		[안자바, 2, 100]
		[이자바, 3, 300]
		[나자바, 3, 290]
		[김자바, 3, 180]
		*/
        
    }

}

class Student implements Comparable<Student> {

    String name;
    int ban;
    int totalScore;

    public Student(String name, int ban, int totalScore) {
        this.name = name;
        this.ban = ban;
        this.totalScore = totalScore;
    }
    public String toString(){
        return String.format("[%s, %d, %d]",name,ban,totalScore);
    }

    public String getName() {
        return name;
    }

    public int getBan() {
        return ban;
    }

    public int getTotalScore() {
        return totalScore;
    }


    @Override
    // 총점 내림차순을 기본 정렬
    public int compareTo(Student s) {
        return s.totalScore - this.totalScore;
    }
}
```

<br/>

<br/>

### map() -- 변환

스트림의 요소에 저장된 값 중에서 **원하는 필드만 뽑아내거나 특정 형태로 변환**해야할 때 사용한다.

```java
// 매개변수 T타입을 R타입으로 변환해서 반환하는 함수를 지정해야한다.
Stream<R> map(Function<? super T, ? extends R> mapper)
```

<br/>

**예제**

```java
package Stream;

import java.io.*;
import java.util.stream.*;

public class StreamEx2 {
    public static void main(String[] args) {
        File[] fileArr = {new File("Ex1.java"), new File("Ex1.bak"),
                new File("Ex2.java"), new File("Ex1"), new File("Ex1.txt")};

        Stream<File> fileStream = Stream.of(fileArr);

        // map()으로 Stream<File>을 Stream<String>으로 변환
        Stream<String> filenameStream = fileStream.map(File::getName);
        filenameStream.forEach(System.out::println);
        /* Ex1.java
        Ex1.bak
		Ex2.java
		Ex1
		Ex1.txt
		*/
        
        fileStream = Stream.of(fileArr);    // 스트림 다시 생성

        fileStream.map(File::getName)	// Stream<File> -> Stream<String>
                .filter((s) -> s.indexOf('.') != -1)    // 확장자가 없는 것은 제외
                .map( s-> s.substring(s.indexOf('.')+1)) // 확장자만 추출, Stream<String> -> Stream<String>
                .map(String::toUpperCase)   // 모두 대문자로 변환
                .distinct()     // 중복 제거
                .forEach(System.out::print);	// JAVABAKTXT     
      }
}
```

<br/>

<br/>

### peek() -- 조회

연산과 연산 사이에 올바르게 처리되었는지 확인할때 사용한다.

`forEach()`(최종연산)와 달리 스트림의 요소를 소모하지 않는 **중간연산**이다.

```java
Stream<T> peek(Consumer<T> action)
```

<br/>

filter나 map의 결과를 확일할 때 유용하다.

```java
fileStream.map(File::getName)
    .filter(s -> s.indexOf('.')!= -1)
    .peek(s -> System.out.printf("filename = %s\n", s)) // 파일명 출력
    .map(s) -> s.substring(s.indexOf('.')+1))
    .peek(s -> System.out.printf("extension=%s\n",s)) // 확장자를 출력
    .map(String::toUpperCase)  
    .distinct()   
    .forEach(Sytem.out::print);


/* 결과(지연된 연산)
filename = Ex1.java
extension=java
JAVA
filename = Ex1.bak
extension=bak
BAK
filename = Ex2.java
extension=java
filename = Ex1.txt
extension=txt
TXT
*/
```

<br/>

<br/>

### mapToInt(), mapToLong(), mapToDouble()

`map()`의 return 타입은 `Stream<T>` , 스트림의 요소를 숫자로 변환하는 경우 IntStream과 같은 기본형 스트림으로 변환하는 것이 더 유용할 수 있다.

아래는 `Stream<T>`타입의 스트림을 기본형 스트림으로 변환할 때 사용하는 메서드들이다.

```java
DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper)
IntStream	 mapToInt(ToIntFunction<? super T> mapper)
LongStream   mapToLong(ToLongFunction<? super T> mapper)
```

<br/>

모든 학생의 성적을 더할때, IntStream을 사용하면 Integer를 int로 변환할 필요도 없고 편리한 메서드도 있다.

```java
Stream<Integer> studentScoreStream = studentStream.map(Student::getTotalScore);

// IntStream 사용!!
IntStream studnetScoreStream = studentStream.mapToInt(Student::getTotalScore);
int allTotalScore = studentScoreStream.sum();
```

<br/>`mapToInt`와 함께 자주 사용되는 메서드

```
Stream<String> -> IntStream 변환 할 때, mapToInt(Integer::parseInt)
Stream<Integer> -> IntStream 변환 할 때, mapToInt(Integer::intValue)
```

<br/>

`count()`만 지원하는 `Stream<T>`와 달리 IntStream과 같은 기본형 스트림은 아래와 같이 숫자를 다루는데 편리한 메서드들을 제공한다.

> max, min은 Stream에도 정의되어 있지만, 매개변수로 Comparator을 지정해줘야한다.

```java
int	sum()		// 스트림의 모든 요소의 합
OptionalDouble	average()	// sum() / (double)count()
OptionalInt	max()	// 스트림의 요소 중 제일 큰 값
OptionalInt min() 	// 스트림의 요소 중 제일 작은 값
```

위 메서드들은 최종연산이다.

```java
IntStream scoreStream = studentStream.mapToInt(Student::getTotalScore);

long totalScore = scoreStream.sum();	// sum()은 최종연산이라 호출 후 스트림이 닫힘
OptionalDouble average = scoreStream.average(); // 에러 스트림이 이미 닫혔음
double d = average.getAsDouble();	// OptionalDouble에 저장된 값을 꺼내서 d에 저장
```

<br/>

`sum()`, `average()`를 모두 호출해야할 때, 스트림을 또 생성하기 불편하다.

따라서 `summaryStatistics()` 메서드 사용!

```java
IntStream scoreStream = studentStream.mapToInt(Student::getTotalScore); // s -> s.getTotalScore()

IntSummaryStatistics stat = scoreStream.summaryStatistics();

// IntSummaryStatistics클래스의 다양한 메서드들
long totalCount = stat.getCount();
long totalScore = stat.getSum();
double avgScore = stat.getAverage();
int minScore = stat.getMin();
int maxScore = stat.getMax();
```

> IntSummaryStatistics외  LongSummaryStatistics, DoubleSummaryStatistics도 있음

<br/>

#### IntStream, LongStream, DoubleStream에서 변환

`InStream` -> `Stream<T>`로 변환할때

```java
Stream<U> mapToObj(IntFunction<? extends U> mapper)
```

**예제**

```java
IntStream intStream = new Random().ints(1,46);	// 1~45사이의 정수
Stream<String> lottoStream = intStream.mapToObj(i -> i+","); // 정수를 문자열로 변환

lottoStream.forEach(System.out::print);	// 12,14,20,23,26,29,
```

<br/>

`IntStream` -> `Stream<Integer>` 변환할 때

```java
Stream<Integer> boxed()
```

**예제**

```java
IntStream intStream = IntStream.range(1,5);
Stream<Integer> boxedStream = intStream.boxed();
```

<br/>

#### CharSequence에 정의된 `chars()`

`chars()`는 String이나 StringBuffer에 저장된 문자열들을 IntStream으로 다룰 수 있게해줌

```java
IntStream charStream = "12345".chars();	// default IntStream chars()


//   IntStream map(IntUnaryOperator mapper)
int charSum = charStream.map(ch -> ch-'0').sum();	// charSum = 15
```

<br/>

<br/>

### flatMap() -- `Stream<T[]>`를 `Stream<T>`로 변환

```java
Stream<R>    flatMap(Function<T, Stream<R>> mapper)
```

스트림의 요소가 배열이거나 map()의 연산결과가 배열인 경우

즉, 스트림의 타입이 `Stream<T[]>`인 경우, `Stream<T>`로 다루는 것이 더 편리할 때가 있다. 그럴 때 `map()` 대신 `flatMap()` 사용

```java
Stream<String[]> strArrStrm = Stream.of(
    new String[]{"abc", "def", "ghi"},
    new String[]{"ABC", "GHI", "JKLMN"}
)
```

위와 같이 요소가 문자열 배열(String[])인 스트림이 있을때 각 요소의 문자열들을 합쳐서 문자열이 요소인 스트림,

 즉 `Stream<String>`으로 만들려면 `flatMap()`과 배열을 스트림으로 만들어주는 `Arrays.stream(T[])` 를 사용하면됨

```java
Stream<String> strStrm = strArrStrm.flatMap(Arrays::stream); // arr -> Arrays.stream(arr)
```

![Image](https://github.com/user-attachments/assets/9bfbb975-e6d6-45c1-94e0-26dc38c7c3f3)

<br/>

<br/>

만약 map()을 쓴다면 `Stream<Stream<String>>` 즉, 스트림의 스트림이 되버린다.

```java
// Stream<R> map(Function<? super T, ? extends R> mapper)
    
Stream<String> strStrm = strArrStrm.map(Arrays::stream);
/* Arrays::stream의 결과로 String[](T)가 Stream<String>(R)이 되는데 map은 반환타입이 Stream<R>이므로
Stream<Stream<String>> 이 되는것!
*/
```

![Image](https://github.com/user-attachments/assets/67907095-eea9-46cc-b508-42c9a6d6af34)

<br/>

<br/>

아래와 같이 **여러 문장을 요소**로 하는 스트림이 있을 때, 이 문장들을 `split()`으로 나눠서 **요소가 단어인 스트림으로** 만드는 예제

```java
String[] lineArr = {
    "Belive or not It is ture",
    "Do or do not There is no try"
};
Stream<String> lineStream = Arrays.stream(lineArr);
Stream<String> strStream = lineStream.flatMap(line -> Stream.of(line.split(" +"))); // 하나 이상의 공백
```

<br/>

만약 `map()`을 사용하면 `line.split(" +")`의 결과(String[])를 그대로 `Stream.of()`로 감싸므로, `Stream<Stream<String>>`이 만들어진다.

```java
Stream<Stream<String>> strStream = lineStream.map(line -> Stream.of(line.split(" +")));
```

<br/>

스트림의 스트림을 하나의 스트림으로 합칠때도 `flatMap()`을 사용한다.

```java
Stream<String> strStrm = Stream.of("abc", "def", "jklmn");
Stream<String> strStrm2 = Stream.of("ABC", "GHI", "JKLMN");
Stream<Stream<String>> strmStrm = Stream.of(strStrm, strStrm2);

// toArray()는 스트림을 배열로 변환해서 반환한다. 매개변수를 지정하지 않으면 Object[] 을 반환
// 여기서는 String배열의 생성자를 지정함
Stream<String> strStream = strmStrm
    .map(s-> s.toArray(String[]::new)) // Stream<Stream<String>> -> Stream<String[]>
    .flatMap(Arrays::stream);	// Stream<String[]> -> Stream<String>
```

<br/>

<br/>

<br/>

## 2.4 `Optional<T>`

`Optional<T>`는 지네릭 클래스로 **T타입의 객체를 감싸는 래퍼 클래스**이다. 따라서 Optional타입의 객체에는 모든 타입의 참조변수를 담을 수 있음

> java.util.Optional은 JDK1.8부터 추가됨

```java
public final class Optional<T>{
    private final T value;	// T타입의 참조변수
    ...
}
```

최종 연산의 결과를 Optional객체에 담아서 반환하기에

- null을 직접 다루지 않고 **간접적**으로 다루게 되어 NullPointerException으로부터 안전하다.
- 널 체크를 위한 지저분한 if문으로 체크 안해도됨
  - 대신 Optional에 정의된 메서드를 통해 간단히 처리 가능

<br/>

<br/>

### Optional 객체 생성

`of()` 사용

```java
String str = "abc";
Optional<String> optVal = Optional.of(str);
Optional<String> optVal = Optional.of("abc");
Optional<String> optVal = Optional.of(new String("abc"));
```

 `ofNullable()`사용

```java
Optional<String> optVal = Optional.of(null);	// NullPointerException발생!
Optional<String> optVal = Optional.ofNullable(null);	// Ok
```

<br/>

`Optional<T>`타입의 참조변수를 기본값으로 초기화

```java
Optional<String> optVal = null;	// 지양한다.
Optional<String> optVal = Optional.<String>empty(); // 빈 객체로 초기화, <T>는 추정 가능하므로 생략가능
```

<br/>

<br/>

### Optional객체의 값 가져오기

```java
Optional<String> optVal = Optional.of("abc");
String str1 = optVal.get();			// optVal에 저장된 값을 반환, 값이 없으면 NoSuchElementException 발생
String str2 = optVal.orElse("");	// optVal에 저장된 값이 null일때는, ""를 반환
```

<br/>

#### orElse() 의 변형

null을 대체할 값을 반환하는 **람다식을 지정**할 수 있는 `orElseGet()`

null일 때 지정딘 예외를 발생시키는 `orElseThrow()`

```java
T orElseGet(Supplier<? extends T> other)
T orElseThorw(Supplier<? extends X> exceptionSupplier)
```

사용법

```java
String str3 = optVal2.orElseGet(String::new);	// () -> new String()
String str4 = optVal2.orElseThrow(NullPointerException::new)
```

<br/>

### filter(), map(), flatMap()

Stream처럼 Optional객체에도 위 메서드들을 사용할 수 있다.

flatMap()을 사용하면 `Optional<Optional<T>>` -> `Optional<T>`

> 만약 Optional 객체의 값이 null이면, 이 메서드들은 아무일도 안함

```java
int result = Optional.of("123")
    .filter(x->x.length() > 0)
    .map(Integer::parseInt).orElse(-1);	// result = 123

int result = Optional.of("")
    .filter(x->x.length() > 0)
    .map(Integer::parseInt).orElse(-1);	// result = -1

// 만약 예외처리된 메서드를 만든다면 다음과 같이됨
static int optStrToInt(Optional<String> optStr, int defaultValue){
    try{
        return optStr.map(Integer::parseInt).get();
    }catch (Exception e){
        return defaultValue;
    }
}
```

<br/>

<br/>

### isPresent() -- Optional객체의 값이 null이면 false, 아니면 true를 반환

```java
if(Optional.ofNullable(str).isPresnt()){	// if(str!=null)
    System.out.println(str);
}
```

위 코드를 `ifPresent()`를 이용해서 바꾸면 더 간단해짐

```java
public void ifPresent(Consumer<? super T> action) {
    if (value != null) {
        action.accept(value);
    }
}
```

```java
// str이 null이 아닐때만 출력, null이면 아무일도 안일어남
Optional.ofNullalbe(str).ifPresent(System.out::println); 
```

<br/>

`ifPresent()`는 `Optional<T>` 를 반환하는 최종연산과 잘어울린다.

```java
Optional<T> findAny()
Optional<T>	findFirst()
Optional<T> max(Comparator<? super T> comparator)
Optional<T> min(Comparator<? super T> comparator)
Optional<T> reduce(BinaryOperator<T> accumulator)
```

**예제**

```java
Stream<String> stream = Stream.of("apple", "banana", "cherry");
stream.findFirst().ifPresent(System.out::println); // apple

Stream<Integer> stream = Stream.of(3, 1, 4, 1, 5);
stream.max(Integer::compare)
      .ifPresent(max -> System.out.println("최대값: " + max)); // 최대값: 5

Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
stream.reduce(Integer::sum)
      .ifPresent(sum -> System.out.println("합계: " + sum)); // 합계: 15
```

<br/>

<br/>

### OptionalInt, OptionalLong, OptionalDouble -- 기본형값을 감싸는 래퍼클래스

```java
public final class OptionalInt{
    ...
    private final boolean isPresent;	// 값이 저장되어 있으면 true
    private final int value;
}
```

#### Optional에 저장된 값 꺼내오기

![Image](https://github.com/user-attachments/assets/7a7b4751-742d-4ca3-9192-6197bac3c665)

<br/>

기본형 int의 기본값은 0이다. 아무런 값도 갖지 않은 OptioanlInt에 저장되는 값도 0일것이다.

```java
OptionalInt opt = OptionalInt.of(0);
OptionalInt opt2 = OptionalInt.empty();
```

isPresent라는 인스턴스 변수로 구분이 가능함

```java
private final boolean isPresent;
 
public boolean isPresent() {
    return isPresent;
}
```

<br/>

```java
System.out.println(opt.isPresent());	// true
System.out.println(opt2.isPresent()); 	// false

System.out.println(opt.getAsInt());		// 0
System.out.println(opt2.getAsInt());	// NoSuchElementException 예외 발생

System.out.println(opt.equals(opt2));	// false
```

그러나 Optional객체의 경우 null을 저장하면 비어있는 것과 동일 취급

```java
Optional<String> opt = Optional.ofNullable(null);
Optional<String> opt2 = Optional.empty();
       
System.out.println(opt.equals(opt2));	// true
```

<br/>

<br/>

**지금까지 Optional 예제**

```java
package Stream;
import java.util.*;

public class OptionalEx1 {
    public static void main(String[] args) {
        Optional<String> optStr = Optional.of("abccde");
        Optional<Integer> optInt = optStr.map(String::length);
        System.out.println("optStr="+ optStr.get());  // optStr=abccde
        System.out.println("optInt="+optInt.get());  // optInt=6

        int result1 = Optional.of("123")
                .filter(x->x.length()>0)
                .map(Integer::parseInt).get();
        
        int result2 = Optional.of("")
                .filter(x->x.length()>0)
                .map(Integer::parseInt).orElse(-1);
        
        System.out.println("result1="+result1);  // result1=123
        System.out.println("result2="+result2);  // result2=-1

        Optional.of("456").map(Integer::parseInt)
                .ifPresent(x->System.out.printf("result3=%d\n",x));  // result3=456

        OptionalInt optInt1 = OptionalInt.of(0);
        OptionalInt optInt2 = OptionalInt.empty();

        System.out.println(optInt1.isPresent());  // true
        System.out.println(optInt2.isPresent());  // false

        System.out.println(optInt1.getAsInt());  // 0
        // System.out.println(optInt2.getAsInt());  // NoSuchElementException 예외 발생
        System.out.println("optInt1="+optInt1);  // optInt1=OptionalInt[0]
        System.out.println("optInt2="+optInt2);  // optInt2=OptionalInt.empty
        System.out.println(optInt1.equals(optInt2));  // false

        Optional<String> opt = Optional.ofNullable(null);
        Optional<String> opt2 = Optional.empty();
        
        System.out.println("opt="+opt);  // opt=Optional.empty
        System.out.println("opt2="+opt2);  // opt2=Optional.empty
        System.out.println(opt.equals(opt2));  // true
    }
}
```

<br/>

<br/>

<br/>

## 2.5 스트림의 최종 연산

### forEach(), forEachOrdered() -- 스트림의 모든 요소에 지정된 작업을 수행

```java
void  forEach(Consumer<? super T> action)	// 병렬스트림인 경우 순서가 보장되지 않음
void  forEachOrdered(Consumer<? super T> action) // 병렬스트림인 경우에도 순서가 보장됨
```

**예제**

```java
IntStream.range(1, 10).sequential().forEach(System.out::print);	// 123456789
IntStream.range(1, 10).sequential().forEachOrdered(System.out::print); // 12345678

IntStream.range(1, 10).parallel().forEach(System.out::print);	// 683295714
IntStream.range(1, 10).parallel().forEachOrdered(System.out::print); // 12345678
```

<br/>

<br/>

### allMatch(), anyMatch(), noneMatch(), findFirst(), findAny() -- 조건검사

```java
boolean allMatch (Predicate<? super T> predicate) // 모든 요소가 조건을 만족시키면 true
boolean anyMatch (Predicate<? super T> predicate) // 한 요소라도 조건을 만족시키면 true
boolean noneMatch(Predicate<? super T> predicate) // 모든 요소가 조건을 만족시키지 않으면 true
```

학생들의 성적 정보 스트림(stuStream)에서 총점이 낙제점(총점 100이하)인 학생이 있는지 확인하는 예제

```java
boolean noFailed = stuStream.anyMatch(s-> s.getTotalScore() <= 100)
```

<br/>

```java
Optional<T> findFirst()	// 첫 번째 요소를 반환. 순차 스트림에 사용
Optional<T> findAny()	// 아무거나 하나를 반환. 병렬 스트림에 사용 
```

`findFirst()`는 주로 `filter()`와 함께 사용되어 조건에 맞는 스트림의 요소가 있는지 확인하는데 사용된다. 

> 병렬 스트림인 경우 `findAny()`

```java
Optional<Student> stu = stuStream.filter(s-> s.getTotalScore() <= 100).findFirst();
Optional<Student> stu = parallelStream.filter(s-> s.getTotalScore() <= 100).findAny();
```

<br/>

<br/>

### count(), sum(), average(), max(), min() -- 스트림에 대한 통계정보 제공

#### `Stream<T>`인터페이스 메서드

```java
long count()
Optional<T>  max(Comparator<? super T> comparator)
Optional<T>  min(Comparator<? super T> comparator)
```

<br/>

#### IntStream인터페이스 메서드

```java
long count()
int sum()
OptionalDouble average()
OptionalInt max()
OptionalInt min()
IntSummaryStatistics summaryStatistics()
```

<br/>

#### IntSummaryStatistics 클래스 메서드

```java
double getAverage()
long getCount()
int getMax()
int getMin()
long getSum()
```

<br/>

<br/>

### toArray -- 스트림을 배열로 변환

```java
Object[] toArray();
<A> A[] toArray(IntFunction<A[]> generator);
```

```java
Student[] stuNames = studentStream.toArray(Student[]::new); // Ok,  람다식 : size -> new String[size]
Student[] stuNames = studentStream.toArray();	// 에러
Object[] stuNames = studentStream.toArray();	// OK
```

<br/>

<br/>

### reduce -- 스트림의 요소를 줄여가며 누적연산을 수행

처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
```

위 `reduce` 메서드는 내부적으로 다음과 같이 되어있다.

```java
boolean foundAny = false;	// 스트림에 요소가 하나라도 있는지 확인하는 변수, false면 아직 요소를 발견 못한 상태
T result = null;	// 최종 결과 값을 저장하는 변수, 초기값 null
for (T element : this stream) {  
    if (!foundAny) {  	// 첫 번째 요소를 처리하는 경우
        foundAny = true;  	// true로 설정하여 최소한 하나의 요소가 존재함을 표시
        result = element;  //  첫 번째 요소를 result에 저장
    } else {	// 첫번째 요소가 아니라면 accumulator 함수를 사용하여 누적 연산
        result = accumulator.apply(result, element); 
    }
}  
return foundAny ? Optional.of(result) : Optional.empty(); 
```

<br/>

<br/>

**연산결과의 초기값**(identity)를 갖는 `reduce()`

```java
T reduce(T identity, BinaryOperator<T> accumulator)
    
// combiner는 병렬 스트림에 의해 처리된 결과를 합칠때 사용하기 위한 것
U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)
```

위의 `reduce`는 다음과 같이 내부적으로 작동함

```java
T result = identity;
for (T element : this stream) {
    result = accumulator.apply(result, element);
}
return result;	// 스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로, 반환타입이 Optional<T>가아니라 T이다.
```

<br/>

<br/>

사실 count, sum, max, min은 모두 reduce를 이용해서 작성된것이다.

> a = 이전까지의 누적 값(result),  identity가 있을 경우, result = identity
>
> b = 현재 스트림의 요소(element)

```java
int count = intStream.reduce(0, (a, b) -> a + 1 );
int sum = intStream.reduce(0, (a,b) -> a + b);
int max = intStream.reduce((a,b) -> a < b ? b : a);
int min = intStream.reduce((a,b) -> a < b ? a : b);
```

<br/>

<br/>

intStream의 **타입이 IntStream인 경우**는 **OptionalInt**를 사용해야 한다.

`Stream<T>`와 달리 IntStream에 정의된 reduce의 반환 타입이 `Optional<T>`가 아니라 **OptionalInt**이기 때문이다.

```java
OptionalInt max = intStream.reduce((a,b) -> a > b ? a : b);
OptionalInt min = intStream.reduce((a,b) -> a < b ? a : b);
```

위의 문장들에서 Integer클래스의 static 메서드 max()와 min()을 이용해서 메서드 참조로 바꾸면 다음과 같다.

```java
OptionalInt max = intStream.reduce(Integer::max);	// int max(int a, int b)
OptionalInt min = intStream.reduce(Integer::min);	// int min(int a, int b)

int maxValue = max.getAsInt();	// OptionalInt에 저장된 값을 maxValue에 저장
```

<br/>

<br/>

**예제**

```java
import java.util.*;
import java.util.stream.*;

public class StreamEx5 {
    public static void main(String[] args){
        String[] strArr = {
                "Inheritance", "Java", "Lambda", "stream",
                "OptionalDobule", "IntStream", "count", "sum"
        };
        Stream.of(strArr).forEach(System.out::println);

        boolean noEmptyStr = Stream.of(strArr).noneMatch(s->s.length()==0);
        System.out.println(noEmptyStr);	// true

        Optional<String> sWord = Stream.of(strArr).filter(s->s.charAt(0)=='s').findFirst();
        System.out.println("sWord: "+sWord.get());	// sWord: stream

        // Stream<String[]> 을 IntStream으로 변환
        IntStream intStream1 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream2 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream3 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream4 = Stream.of(strArr).mapToInt(String::length);

        int count = intStream1.reduce(0,(a,b) -> a+1);
        int sum = intStream2.reduce(0,(a,b) -> a+b);
        OptionalInt max = intStream3.reduce(Integer::max);
        OptionalInt min = intStream4.reduce(Integer::min);
        
        System.out.println("count="+count);	// 8
        System.out.println("sum="+sum);	// 58
        System.out.println("max="+max.getAsInt());	// 14
        System.out.println("min="+min.getAsInt());	// 3

    }
}
```

<br/>

<br/>

<br/>

## 2.6 collect()

#### `collect()`

- **스트림의 요소를 수집하는 최종 연산**

- 매개변수로 **Collector**를 필요로 한다.

  > sort()가 Comparator가 필요한 것처럼 collect()는 Collector가 필요하다

```java
Object collect(Collector collector) // Collector를 구현한 클래스의 객체를 매개변수로
    
// Collector 인터페이스를 구현하지 않고 간단히 람다식으로 수집할 때 사용함
Object collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)  //  잘 안쓰임
```

<br/>

#### Collector 인터페이스

- `collect()`가 스트림의 요소를 **어떻게 수집할 것인가에 대한 방법을 정의**한 것

<br/>

#### Collectors클래스(Collector를 구현한 클래스)

- 미리 작성된 **다양한 종류의 컬렉터를 반환하는 static메서드**를 가지고 있다.

```
변환 - mapping(), toList(), toSet(), toMap(), toCollection(), …
통계 - counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt(), …
문자열 결합 - joining()
리듀싱 -  reducing()
그룹화와 분할 - groupingBy(), partitioningBy(), collectingAndThen()
```

<br/>

<br/>

### 스트림을 컬렉션으로 변환 - toList(), toSet(), toMap(), toCollection

스트림의 모든 요소를 컬렉션에 수집하려면 **Collectors클래스의** `toList()`, `toSet()`, `toMap()` 이용

```java
List<String> names = stuStream.map(Student::getName)
    .collect(Collectors.toList());

Set<String> nameSet = stuStream.map(Student::getName)
    .collect(Collectors.toSet());

// Map은 객체의 어떤 필드를 키, 값으로 사용할지를 지정해줘야 한다.
Map<String, Person> map = personStream
    .collect(Collectors.toMap(p->p.getRegId(), p->p)); // p->p == Function.identity()
```

List나 Set이 아닌 **특정 컬렉션을 지정하려면** `toCollection()`에 해당 컬렉션의 생성자 참조를 매개변수로 넣어주면 된다.

```java
LinkedList<String> names = stuStream.map(Student::getName)
    .collect(Collectors.toCollection(LinkedList::new);
```

<br/>

<br/>

### 통계 -- counting(), summingInt(), averagingInt(), maxBy(), minBy()

```java
// static 메서드들
counting()
summingInt(ToIntFunction<? super T> mapper)
averagingInt(ToIntFunction<? super T> mapper)
maxBy(Comparator<? super T> comparator)
minBy(Comparator<? super T> comparator)
summarizingInt(ToIntFunction<? super T> mapper)
```

최종 연산들이 제공하는 통계 정보를 `collect()`로 똑같이 얻을 수 있다. 나중에 `groupingBy()`와 함께 사용함

> summingInt()외에도 summingLong(), summingDouble()이 있다. averagingInt()도 마찬가지

```java
long count = stuStream.count();
long count = stuStream.collect(Collectors.counting());

long totalScore = stuStream.mapToInt(Student::getToTotalScore).sum();
long totalScore = stuStream.collect(Collectors.summingInt(Student::getTotalScore));

OptionalInt topScore = studentStream.mapToInt(Student::getTotalScore).max();

Optional<Student> topStudent = stuStream
    .max(Comparator.comparingInt(Student::getTotalScore));

Optional<Student> topStudent = stuStream
    .collect(Collectors.maxBy(Comparator.comparingInt(Student::getTotalScore)));

IntSummaryStatistics stat = stuStream
    .mapToInt(Student::getTotalScore).summaryStatistics();

IntSummaryStatistics stat = stuStream
    .collect(Collectors.summarizingInt(student::getTotalScore));
```

<br/>

<br/>

### 리듀싱 - reducing()

리듀싱 역시 collect()로 가능하다. IntStream에는 매개변수 3개짜리 collect()만 정의되어 있으니 boxed()를 통해 `Stream<Integer>`로 변환해야 매개변수 1개짜리 collect()를 사용 가능

```java
// Collectos.reducing() 종류
Collector reducing(BinaryOperator<T> op)
Collector reducing(T identity, BinaryOperator<T> op)
// 초기값, 변환 함수, 누적 함수 = map()과 reduce를 합처놓은것
Collector reducing(U identity, Function<T,U> mapper, BinaryOperator<U> op)
```

<br/>

```java
IntStream intStream = new Random().ints(1,46).distinct().limit(6);

OptionalInt max = intStream.reduce(Integer::max); // (a,b) -> Integer.max(a,b)
Optional<Integer> max = intStream.boxed().collect(Collectors.reducing(Integer::max));

long sum = intStream.reduce(0, (a, b) -> a + b);
long sum = intStream.boxed().collect(Collectors.reducing(0, (a, b) -> a + b));

int grandTotal = stuStream.map(Student::getTotalScore).reduce(0,Integer::sum);
int grandTotal = stuStream.collect(Collectors.reducing(0,Student::getTotalScore, Integer::sum));
```

<br/>

<br/>

### 문자열 결합 - joining()

- 문자열 스트림의 모든 요소를 하나의 문자열로 연결해서 반환한다.
- 구분자, 접두사, 접미사를 지정 가능하다.
- 스트림의 요소가 String이나 StringBuffer, StringBuilder처럼 CharSequnece의 자손인 경우에만 결합이 가능하다.
- 스트림의 요소가 문자열이 아닌경우 map()으로 먼저 스트림의 요소를 문자열로 변환해야 한다.

```java
// 문자열을 그냥 연결
String studentNames = stuStream.map(Student::getName).collect(Collectors.joining());

// 요소 사이에 "," 추가
String studentNames = stuStream.map(Student::getName).collect(Collectors.joining(","));

// 요소 사이에 "," 추가 + 앞뒤에 대괄호 추가,  ex) "[Alice,Bob,Charlie]"
String studentNames = stuStream.map(Student::getName).collect(Collectors.joining(",", "[", "]"))
    
// map()없이 스트림에 바로 joining()하면, 스트림의 요소에 toString()을 호출한 결과를 결합한다.
String studentInfo = stuStream.collect(Collectors.joining(","));
```

<br/>

<br/>

#### 예제

Student 클래스

```java
class Student implements Comparable<Student> {

    String name;
    int ban;
    int totalScore;

    Student(String name, int ban, int totalScore) {
        this.name = name;
        this.ban = ban;
        this.totalScore = totalScore;
    }
    public String toString() {
        return String.format("[%s, %d, %d]", name, ban, totalScore);
    }

    String getName() {return name;}
    int getBan() {return ban;}
    int getTotalScore() {return totalScore;}

    // totalScore 내림차순
    @Override
    public int compareTo(Student s) {
        return  s.totalScore - this.getTotalScore();

    }
}
```

```java
import java.util.*;
import java.util.stream.*;

public class StreamEx6 {
    public static void main(String[] args) {
        Student[] stuArr = {
                new Student("이자바", 3, 300),
                new Student("김자바", 1, 200),
                new Student("안자바", 2, 100),
                new Student("박자바", 2, 150),
                new Student("소자바", 1, 200),
                new Student("나자바", 3, 290),
                new Student("감자바", 3, 180)
        };

        // 학생 이름만 뽑아서 List<String>에 저장
        List<String> names = Stream.of(stuArr).map(Student::getName).collect(Collectors.toList());
        System.out.println(names);

        // 스트림을 배열로 변환
        Student[] stuArr2 = Stream.of(stuArr).toArray(Student[]::new);

        for (Student s : stuArr2)
            System.out.println(s);
        

        // 스트림을 Map<String, Student>로 변환. 학생 이름이 key
        Map<String, Student> stuMap = Stream.of(stuArr).collect(Collectors.toMap(s -> s.getName(), p -> p));

        for (String name : stuMap.keySet())
            System.out.println(name + "-" + stuMap.get(name));

        long count = Stream.of(stuArr).collect(Collectors.counting());
        long totalScore = Stream.of(stuArr).collect(Collectors.summingInt(Student::getTotalScore));

        System.out.println("count=" + count);	// 7 
        System.out.println("totalScore=" + totalScore);	// 1420

        totalScore = Stream.of(stuArr)
            .collect(Collectors.reducing(0, Student::getTotalScore, Integer::sum));
        System.out.println("totalScore=" + totalScore);	// 1420

        Optional<Student> topStudent = Stream.of(stuArr)
                .collect(Collectors.maxBy(Comparator.comparingInt(Student::getTotalScore)));

        System.out.println("topStudent=" + topStudent.get());	// topStudent=[이자바, 3, 300]

        IntSummaryStatistics stat = Stream.of(stuArr)
                .collect(Collectors.summarizingInt(Student::getTotalScore));
        
        // IntSummaryStatistics{count=7, sum=1420, min=100, average=202.857143, max=300}
        System.out.println(stat);

        String stuNames = Stream.of(stuArr).map(Student::getName)
                .collect(Collectors.joining(",", "{", "}"));

        System.out.println(stuNames); // {이자바,김자바,안자바,박자바,소자바,나자바,감자바}
    }
}
```

<br/>

<br/>

### 그룹화와 분할 - groupingBy(), partitioningBy()

그룹화 : 스트림의 요소를 **Function**으로 그룹화

분할 : 스트림의 요소를 두 가지(**Predicate**) 그룹으로 분할 한다.

```java
Collector groupingBy(Function classifier)
Collector groupingBy(Function classifier, Collector downstream)
Collector groupingBy(Function classifier, Supplier mapFactory, Collector downstream)
    
Collector partitioningBy(Predicate predicate) 
Collector partitioningBy(Predicate predicate, Collector downstream)  
```

> 그룹화와 분할의 결과는 Map에 담겨 반환된다.

<br/>

<br/>

#### Student 클래스

```java
class Student{
    String name;
    boolean isMale; // 성별
    int hak;    // 학년
    int ban;    // 반
    int score;

    Student(String name, boolean isMale, int hak, int ban, int score) {
        this.name = name;
        this.isMale = isMale;
        this.hak = hak;
        this.ban = ban;
        this.score = score;
    }

    String getName() { return name; }
    boolean isMale() { return isMale; }
    int getHak() { return hak; }
    int getBan() { return ban; }
    int getScore() { return score; }

    public String toString() {
        return String.format("[%s, %s, %d학년 %d반, %3d점",name,isMale ? "남":"여", hak, ban, score);
    }
    // groupingBy()에서 사용
    enum Level{ HIGH, MID, LOW }
}
```

#### stuStream

```java
Stream<Student> stuStream =Stream.of(
                new Student("나자바",true,1,1,300),
                new Student("김지미", false,1,1,250),
                new Student("김자바", true, 1,1,200),
                new Student("이지미", false,1,2,150),
                new Student("남자바",true,1,2,100),
                new Student("안지미",false,1,2,50),
                new Student("황지미",false,1,3,100),
                new Student("강지미",false,1,3,150),
                new Student("이자바",true,1,3,200),

                new Student("나자바",true,2,1,300),
                new Student("김지미", false,2,1,250),
                new Student("김자바", true, 2,1,200),
                new Student("이지미", false,2,2,150),
                new Student("남자바",true,2,2,100),
                new Student("안지미",false,2,2,50),
                new Student("황지미",false,2,3,100),
                new Student("강지미",false,2,3,150),
                new Student("이자바",true,2,3,200));
```

<br/>

<br/>

### partioningBy()에 의한 분류

#### 1. 기본 분할(`Collector partitioningBy(Predicate predicate)`)

조건(`predicate`)을 기준으로 `true`와 `false` 두 그룹으로 나누고, 각 그룹에 해당하는 요소들을 `List<T>`로 저장한다.

```java
Map<Boolean, List<Student>> stuBySex = stuStream
    .collect(Collectors.partitioningBy(Student::isMale)); // 학생들을 성별로 분할

List<Student> maleStudent = stuBySex.get(true);	// Map에서 남학생 목록을 얻는다.
List<Student> femaleStudent = stuBySex.get(false); // Map에서 여학생 목록을 얻는다.
```

<br/>

<br/>

#### 2. 기본 분할 + 통계 정보( `Collector partitioningBy(Predicate predicate, Collector downstream)` )

downstream매개변수로 각 그룹을 어떻게 처리할지 결정할 수있다.(각 그룹의 개수, 평균 점수, 최고 점수를 구할 수 있다)

```java
Map<Boolean, Long> stuNumBySex = stuStream
    .collect(Collectors.partitioningBy(Student::isMale, Collectors.counting()));

System.out.println("남학생 수 :"+stuNumBySex.get(true));	// 남학생 수 :8
System.out.println("여학생 수 :"+stuNumBySex.get(false));	// 여학생 수 :10
```

<br/>

남학생과 여학생 총점 구하기

```java
Map<Boolean, Long> stuNumBySex = stuStream
    .collect(Collectors.partitioningBy(Student::isMale, Collectors.summingLong(Student::getScore)));

System.out.println("남학생 총점 :"+stuNumBySex.get(true));	// 남학생 총점 :1600
System.out.println("여학생 총점 :"+stuNumBySex.get(false));  // 여학생 총점 :1400
```

<br/>

남학생 1등, 여학생1등 구하기

> `maxBy()`는 반환타입이 `Optional<Student>`

```java
Map<Boolean, Optional<Student>> topScoreBySex = stuStream.collect(
               Collectors.partitioningBy(Student::isMale, Collectors.maxBy(
                       Comparator.comparing(Student::getScore))));

System.out.println("남학생 1등 : "+topScoreBySex.get(true)); // Optional[[나자바, 남, 1학년 1반, 300점]]
System.out.println("여학생 1등 :"+topScoreBySex.get(false)); // Optional[[김지미, 여, 1학년 1반, 250점]]
```

<br/>

`Optional<Student>`가 아닌 **Student로 반환 결과를 얻는법** = `collectingAndThen()` + `Optional::get` 사용

```java
// collector : 원래 수행할 컬렉션 연산
// 예시 : maxBy, toList, averageInt 등

// finisher : 최종 변환 작업. 즉, 모은 데이터를 가공해서 다른 형태로 변환 
// 예시: Optional.get(), Collections.unmodifiableList() 등

Collector<T,A,RR> collectingAndThen(Collector<T, A, R> collector, Function<R, RR> finisher)
```

```java
Map<Boolean, Student> topScoreBySex2 = stuStream
               .collect(
                       Collectors.partitioningBy(Student::isMale,
                               Collectors.collectingAndThen(
                                       Collectors.maxBy(
                                           // Optional<Student>타입 -> Student타입
                                               Comparator.comparingInt(Student::getScore)), Optional::get
                                       )
                               )
               );
System.out.println("남학생 1등 : " + topScoreBySex.get(true));	// [나자바, 남, 1학년 1반, 300점]
System.out.println("여학생 1등 :" + topScoreBySex.get(false));  // [김지미, 여, 1학년 1반, 250점]
```

<br/>

성적이 150점 아래인 학생들은 불합격 처리하고, 불합격자를 성별로 분류하여 얻어내려면 `partitioningBy()`를 한번 더 사용해서 이중 분할 하면 된다.

```
{
 true => { 남학생
    true  => 150점 미만
 	false => 150점 이상
 },
 
 false => { 여학생
 	true  => 150점 미만
 	false => 150점 이상
 }
}
```

```java
Map<Boolean, Map<Boolean, List<Student>>> failedStuBySex = stuStream
    .collect(Collectors.partitioningBy(Student::isMale,
                                      Collectors.partitioningBy(s -> s.getScore() < 150)));

List<Student> failedMaleStu = failedStuBySex.get(true).get(true);	 
List<Student> failedFemaleStu = failedStuBySex.get(false).get(true); 
```

<br/>

<br/>

### groupingBy()에 의한 분류

```java
Collector groupingBy(Function classifier)
Collector groupingBy(Function classifier, Collector downstream)	
Collector groupingBy(Function classifier, Supplier mapFactory, Collector downstream)
```

`classifier` → 그룹화 기준

`downstream` → 각 그룹에 적용할 집계 작업을 수행하는 **컬렉터** (`Collector<T, A, D>`)

`mapFactory` → 사용할 `Map`의 타입을 지정하는 **`Supplier<Map<K, V>>`**

<br/>

#### stuStream을 **반 별**로 그룹지어 Map에 저장하는 방법

```java
Map<Integer, List<Student>> stuByBan = stuStream
    .collect(Collectors.groupingBy(Student::getBan)); // toList()가 생략됨

Map<Integer, List<Student>> stuB2yBan = Stream.of(stuArr)
                .collect(Collectors.groupingBy(Student::getBan, Collectors.toList())); // toList()생략가능

// toList() 대신 toSet()이나 toCollection(HashSet::new)도 가능
Map<Integer, HashSet<Student>> stuByHak = stuStream
                .collect(Collectors.groupingBy(Student::getBan),Collectors.toCollection(HashSet::new)));
```

<br/>

#### subStream을 성정의 등급(Student.Level)으로 그룹화

아래의 문장은 모든 학생을 세 등급(HIGH, MID, LOW)으로 분류하여 집계한다.

```JAVA
Map<Student.Level, Long> stuByLevel = Stream.of(stuArr)
                .collect(Collectors.groupingBy(
                        s->{
                            if(s.getScore() >=200) return Student.Level.HIGH;
                            else if(s.getScore() >=100) return Student.Level.MID;
                            else return Student.Level.LOW;
                        },Collectors.counting()));
// [MID] - 8명, [HIGH] - 8명, [LOW] - 2명
```

<br/>

#### 다수준 그룹화

`groupingBy()`를 여러 번 사용하면, 다수준 그룹화가 가능하다.

학년별로 그룹화 한후에 다시 반별로 그룹화하기 예제

```java
Map<Integer, Map<Integer, List<Student>>> stuByHakAndBan = stuStream
                .collect(Collectors.groupingBy(Student::getHak,
                        Collectors.groupingBy(Student::getBan)));
```

<br/>

위의 코드를 발전시켜서 각 반의 1등을 출력하고 싶다면, `collectingAndThen()`과 `maxBy()`를 같이 사용

```java
Map<Integer, Map<Integer, List<Student>>> stuByHakAndBan = stuStream
               .collect(Collectors.groupingBy(Student::getHak,
                       Collectors.groupingBy(Student::getBan,
                               Collectors.collectingAndThen(
                                       Collectors.maxBy(Comparator.comparingInt(Student::getScore)),
                                       Optional::get))));
```

<br/>

학년별, 반별로 그룹화한 후, 성적그룹으로 변환(mapping)하여 Set에 저장

```java
Collector mapping(Function mapper, Collector downstream)
```

- mapper
  - 스트림의 각 요소인 `T`를 다른 객체 `R`로 변환하는 함수
  - `T` -> `T`타입으로 추출만 할 수 도 있음
- downstream
  - 변환된 값을 수집하는데 사용되는 Collector
  - 변환된 값을 `Set`이나 `List`와 같은 컬렉션으로 수집할 수 있다.

```java
Map<Integer, Map<Integer, Set<Student.Level>>> stuByHakAndBan = subStream
              .collect(Collectors.groupingBy(Student::getHak, // 학년별 그룹화
                      Collectors.groupingBy(Student::getBan, // 반별 그룹화
                              Collectors.mapping(s -> {  // 점수에 따라 Level을 계산
                                  if (s.getScore() >= 200) return Student.Level.HIGH;
                                  else if (s.getScore() >= 100) return Student.Level.MID;
                                  else return Student.Level.LOW;
                              },Collectors.toSet()))));        // 각 반에서 학생의 Level을 Set으로 수집함
```

<br/>

<br/>

#### 예제

단순그룹화(반별로 그룹화)

```java
Map<Integer, List<Student>> stuByBan = Stream.of(stuArr)
    .collect(Collectors.groupingBy(Student::getBan));

for (List<Student> ban : stuByBan.values()) {
    for (Student s : ban) {
        System.out.println(s);
    }
}
/* 
1. 단순그룹화(반별로 그룹화)
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]
[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]
[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[안지미, 여, 1학년 2반,  50점]
[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[안지미, 여, 2학년 2반,  50점]
[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이자바, 남, 1학년 3반, 200점]
[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]
[이자바, 남, 2학년 3반, 200점]
*/
```

단순그룹화(성적별로 그룹화)

```java
System.out.printf("\n2. 단순그룹화(성적별로 그룹화)\n");

Map<Student.Level, List<Student>> stuByLevel = Stream.of(stuArr)
        .collect(Collectors.groupingBy(s -> {
            if (s.getScore() >= 200) return Student.Level.HIGH;
            else if (s.getScore() >= 100) return Student.Level.MID;
            else return Student.Level.LOW;
        }));

TreeSet<Student.Level> keySet = new TreeSet<>(stuByLevel.keySet());

for (Student.Level key : keySet) {
    System.out.println("[" + key + "]");

    for (Student s : stuByLevel.get(key)) {
        System.out.println(s);
    }
    System.out.println();
}
/*
2. 단순그룹화(성적별로 그룹화)
[HIGH]
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]
[이자바, 남, 1학년 3반, 200점]
[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]
[이자바, 남, 2학년 3반, 200점]

[MID]
[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]

[LOW]
[안지미, 여, 1학년 2반,  50점]
[안지미, 여, 2학년 2반,  50점]
*/
```

단순그룹화 + 통계(성적별 학생수)

```java
Map<Student.Level, Long> stuCntByLevel = Stream.of(stuArr)
        .collect(Collectors.groupingBy(s -> {
            if (s.getScore() >= 200) return Student.Level.HIGH;
            else if (s.getScore() >= 100) return Student.Level.MID;
            else return Student.Level.LOW;
        }, Collectors.counting()));

for (Student.Level key : keySet) {
    System.out.printf("[%s] - %d명, ", key, stuCntByLevel.get(key));
}
System.out.println();

/*
3. 단순그룹화 + 통계(성적별 학생수)
[HIGH] - 8명, [MID] - 8명, [LOW] - 2명, 
*/
```

다중그룹화(학년별, 반별)

```java
Map<Integer, Map<Integer, List<Student>>> stuByHakAndBan = Stream.of(stuArr)
        .collect(Collectors.groupingBy(
                Student::getHak, 
                Collectors.groupingBy(Student::getBan)
        ));

for (Map<Integer, List<Student>> hak : stuByHakAndBan.values()) {
    for (List<Student> ban : hak.values()) {
        System.out.println();
        for (Student s : ban) {
            System.out.println(s);
        }
    }
}
/*
4. 다중그룹화(학년별, 반별)
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]

[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[안지미, 여, 1학년 2반,  50점]

[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이자바, 남, 1학년 3반, 200점]

[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]

[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[안지미, 여, 2학년 2반,  50점]

[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]
[이자바, 남, 2학년 3반, 200점]
*/
```

다중그룹화 + 통계(학년별, 반별 1등)

```java
Map<Integer, Map<Integer, Student>> topStuByHakAndBan = Stream.of(stuArr)
        .collect(Collectors.groupingBy(
                Student::getHak, // 학년별 그룹
                Collectors.groupingBy(
                        Student::getBan, // 반별 그룹
                        Collectors.collectingAndThen( // 최고 점수 학생 찾기 (Optional<Student>)
                                Collectors.maxBy(Comparator.comparingInt(Student::getScore)), 
                                Optional::get // Optional<Student> -> Student (값 꺼내기)
                        )
                )
        ));

for (Map<Integer, Student> ban : topStuByHakAndBan.values()) {
    for (Student s : ban.values()) {
        System.out.println(s);
    }
}
/*
5. 다중그룹화 + 통계(학년별, 반별 1등)
[나자바, 남, 1학년 1반, 300점]
[이지미, 여, 1학년 2반, 150점]
[이자바, 남, 1학년 3반, 200점]
[나자바, 남, 2학년 1반, 300점]
[이지미, 여, 2학년 2반, 150점]
[이자바, 남, 2학년 3반, 200점]
*/
```

다중그룹화 + 통계(학년별, 반별 성적그룹)

```java
Map<String, Set<Student.Level>> stuByScoreGroup = Stream.of(stuArr)
        .collect(Collectors.groupingBy(
                s -> s.getHak() + "-" + s.getBan(), // 학년-반을 기준으로 그룹화 ("학년-반" 문자열 키 생성)
                Collectors.mapping(
                        s -> { // 각 학생의 성적을 기준으로 레벨을 변환 (HIGH, MID, LOW)
                            if (s.getScore() >= 200) return Student.Level.HIGH;
                            else if (s.getScore() >= 100) return Student.Level.MID;
                            else return Student.Level.LOW;
                        },
                        Collectors.toSet() // 중복되지 않는 레벨(Set<Student.Level>)을 저장
                )
        ));

Set<String> keySet2 = stuByScoreGroup.keySet();

for (String key : keySet2) {
    System.out.println("[" + key + "]" + stuByScoreGroup.get(key));
}

/*
6. 다중그룹화 + 통계(학년별, 반별 성적그룹)
[1-1][HIGH]
[2-1][HIGH]
[1-2][LOW, MID]
[2-2][LOW, MID]
[1-3][HIGH, MID]
[2-3][HIGH, MID]
*/
```

<br/>

<br/>

<br/>

## 2.7 Collector구현하기

지금까지 Collectors클래스가 제공하는 컬렉터를 사용하는 방법을 배웠다.

컬렉터를 작성하기 위해서는 Collector인터페이스를 구현해야 하는 것을 의미하는데, Collector 인터페이스는 다음과 같이 정의되어 있다.

```java
public interface Collector<T,A,R>{
    Supplier<A>			supplier();
    BiConsumer<A,T> 	accumulator();
    BinaryOperator<A> 	combiner();
    Function<A,R>		finisher();
    
    Set<characteristics> characteristics();	// 컬렉터의 특성이 담긴 Set을 반환
}
```

직접 구현해야하는 것은 위의 5개의 메서드인데 characteristics()를 제외하면 모두 반환 타입이 함수형 인터페이스이다.

즉, 4개의 람다식을 작성하면 됨

```
supplier()  	작업 결과를 저장할 공간을 제공
accumulator()	스트림의 요소를 수집(collect)할 방법을 제공
combiner()		두 저장공간을 병합할 방법을 제공(병렬 스트림)
finisher()		결과를 최종적으로 변환할 방법을 제공
```

`supplier()` : 수집 결과를 저장할 공간을 제공하기 위한 것

`accumulator()` : 스트림의 요소를 어떻게 supplier()가 제공한 공간에 누적할 것인지를 정의

`combiner()` : 병렬 스트림의 경우, 여러 쓰레드에 의해 처리된 결과를 어떻게 합칠 것인가를 정의

`finisher()` : 작업결과를 변환한다. 변환이 필요없다면, 항등 함수인 Function.identity()를 반환하면 됨

```java
public Function finisher(){
    return Function.identity();
}
```

`characteristics()` : 컬렉터가 수행하는 작업의 속성에 대한 정보를 제공

```
열거형 Characteristics는 Collector내에 정의되어 있다.
-----------------------------------------------------
Characteristics.CONCURRENT			병렬로 처리할 수 있는 작업
Characteristics.UNORDERED			스트림의 요소의 순서가 유지될 필요가 없는 작업
Characteristics.IDENTITY_FINISH		finisher()가 항등 함수인 작업
```

위의 3가지 속성 중에서 해당하는 것을 다음과 같이 Set에 담아서 반환하도록 구현하면 됨

```java
public Set<characteristics> characteristics(){
    return Collections.unmodifiableSet(EnumSet.of(
        Collector.Characteristics.CONCURRENT,
        Collector.Characteristics.UNORDERED
    ));
}

// 아무런 속성도 지정하고 싶지 않은 경우
public Set<characteristics> characteristics(){
    return Collections.emptySet();
}
```

<br/>

#### reduce()와 collect()의 차이

근본적으로 하는 일이 같다. 그룹화와 분할, 집계 등에 유용하게 쓰이고, 병렬화에 있어서는 collect()가 더 유리하다.

<br/>

<br/>

String배열의 모든 문자열을 하나의 문자열로 합치려면 다음과 같을 것이다.

```java
String[] strArr = { "aaa", "bbb", "ccc" };
StringBuffer sb = new StringBuffer();	// supplier(), 저장할 공간을 생성

for(String tmp : strArr)
    sb.append(tmp);		// accumulator(), sb에 요소를 저장

String result = sb.toString();	// finisher(), StringBuffer를 String으로 변환
```

위 코드를 바탕으로 `Stream<String>`의 모든 문자열을 하나로 결합해서 String으로 반환하는 ConcatCollector를 작성하겠다.

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class CollectorEx1 {
    public static void main(String[] args) {
        String[] strArr = new String[] { "aaa", "bbb", "ccc"};
        Stream<String> strStream = Stream.of(strArr);

        String result = strStream.collect(new ConcatCollector());
        System.out.println(Arrays.toString(strArr));	// [aaa, bbb, ccc]
        System.out.println("result: " + result);	// result: aaabbbccc	
    }
}

class ConcatCollector implements Collector<String, StringBuilder, String>{

    @Override
    public Supplier<StringBuilder> supplier() {
        return StringBuilder::new;
        // return () -> new StringBuilder();
    }

    @Override
    public BiConsumer<StringBuilder, String> accumulator() {
        return (sb,s) -> sb.append(s);
        // StringBuilder::append;
    }

    @Override
    public BinaryOperator<StringBuilder> combiner() {
        return (sb, sb2) -> sb.append(sb2);
        // return StringBuilder::append;
    }

    @Override
    public Function<StringBuilder, String> finisher() {
        return sb -> sb.toString();
        // return StringBuilder::toString;
    }

    @Override
    public Set<Characteristics> characteristics() {
        return Collections.emptySet();
    }
}
```

<br/>

<br/>

<br/>

## 2.8 스트림의 변환

![Image](https://github.com/user-attachments/assets/a6ae5408-4a43-4cbb-974d-22641ebfca6b)

![Image](https://github.com/user-attachments/assets/ba71c9f5-1631-4a7a-8922-befe309d50c8)



