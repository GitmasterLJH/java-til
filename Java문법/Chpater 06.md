## Chpater 06 객체지향 프로그래밍 I

### 1. 객체지향언어

---

#### 1.1 객체지향언어 특징

1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

**3가지 키워드**

- 재사용성
- 유지보수
- 중복된 코드의 제거



### 2. 클래스와 객체

---

#### 2.1 클래스와 객체 정의와 용도

- 클래스(객체의 틀, 설계도)
  - 정의 : 객체를 정의해 놓은 것
  - 용도 : 객체를 생성하는데 사용

- 객체
  - 정의 : 실제로 존재하는 것. 사물 또는 개념
  - 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름
  - 객체 종류
    - 유형의 객체 :  책상, 의자, 자동차, TV와 같은 사물
    - 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리와 개념

**먼저 클래스를 작성한 다음, 클래스로부터 객체를 생성하여 사용**

| 클래스      | 객체   |
| ----------- | ------ |
| 제품 설계도 | 제품   |
| TV 설계도   | TV     |
| 붕어빵 기계 | 붕어빵 |

**Java API**

- JDK에서는 유용한 클래스(Java API)를 기본적으로 제공, 이 클래스들을 이용해서 원하는 기능의 프로그램을 쉽게 작성 가능



#### 2.2 객체와 인스턴스

- 인스턴스화 : 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.
- 인스턴스 : 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

```
					 	   인스턴스화
				클래스  ----------------> 인스턴스(객체)
				
```

**예시**

- **'책상은 인스턴스다'** 라고 하기 보다는 **'책상은 객체다'**라는 쪽이 더 자연스럽다.
- **'책상은 책상 클래스의 객체이다.'** 라고 하기 보다는 **'책상은 책상 클래스의 인스턴스다.'** 라고 하는 것이 더 자연스럽다.



#### 2.3 객체의 구성요소 - 속성과 기능

- 객체 : 속성과 기능의 집합

- 객체가 가지고 있는 속성과 기능을 그 **객체의 멤버**라 한다.

  ```
  속성(property) 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
  기능(function) 메서드(method), 함수(function), 행위(behavior)
  ```

TV예시

<img src="https://github.com/GitmasterLJH/java-til/assets/129172593/eeb3d6ca-e248-441b-b0d7-b4b73abde766" width="500px" height="200px">

#### 2.4 인스턴스의 생성과 사용

예제

```java
class Tv {
    // Tv의 속성(멤버변수)
    String color;       // 색상
    boolean power;      // 전원 상태(on/off)
    int channel;        // 채널

    // Tv의 기능(메서드)
    void power() { power = !power;} // Tv를 켜거나 끄는 기능을 하는 메서드
    void channelUp(){ ++channel;}   // Tv의 채널을 높이는 기능을 하는 메서드
    void channelDown(){ --channel;} // Tv의 채널을 낮추는 기능을 하는 메서드

}
class TvTest{
    public static void main(String[] args) {
        Tv t;            // Tv인스턴스를 참조하기 위한 변수 t를 선언
        t = new Tv();    // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
        t.channel = 7;   // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
        t.channelDown(); // Tv인스턴스의 메서드 channelDown()을 호출한다.
        System.out.println("현재 채널은 "+ t.channel+"입니다.");
    }
}
```

**설명**

1. Tv t;
   - Tv클래스 타입의 참조변수 t를 선언한다. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.
2. t= new Tv()
   - 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다.
   - 참조형은 null, boolean은 false, int형은  0
   - 그다음 = 에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다. 이제 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다.

```
인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
```



#### 2.5 객체 배열

- 배열안에 객체의 주소가 저장됨
- 같은 타입의 객체만 저장 가능

```java
Tv[] tvArr = new Tv[3];  // 길이가 3인 Tv타입의 참조변수 배열 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 초기화 블럭 이용
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };

// for문 이용
Tv[] tvArr = new Tv[100];

for(int i=0; i<tvArr.length;i++){
    tvArr[i] = new Tv();
}
```

#### 2.6 클래스의 또 다른 정의

**클래스**

- 객체지향이론 관점
  - 객체를 생성하기 위한 틀이며 속성과 기능으로 정의되어있다.
- 프로그래밍적인 관점
  - 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것

ex) String : C언어에서는 문자열을 문자의 배열로 다루지만 자바에서는 String이라는 클래스로 문자열을 다룬다.

 이유 : 문자열을 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서 이렇게 하면 변수와 함수가 서로 유기적으로 연결되어 작업이 간단하고 명료해진다.



### 3. 변수와 메서드

---

#### 3.1 선언위치에 따른 변수의 종류

```java
class Variables
{
	int iv;		   // 인스턴스 변수
	static int cv  //  클래스 변수(static변수,공유변수)    
	
	void method()
	{
		int lv = 0;  // 지역변수       
	}
}
```

**1. 인스턴스변수**

- 클래스 영역에 선언된다.
- 클래스의 인스턴스를 생성할 때 만들어진다.
- 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
  - 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언

**2. 클래스 변수**

- 클래스 영역에 선언된다.
- 인스턴스변수 앞에 static을 붙이기만 하면 된다.
- 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다.
  - 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언
- 인스턴스를 생성하지 않고도 언제라도 바로 사용 가능
- 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.
- public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 가짐
- c1.width가 아니라 Card.width와 같이 인스턴스 변수로 오해하지 않기위해 **"클래스이름.클래스변수"**의 형태로 하는 것이 좋다. 

**3. 지역변수**

- 메서드 내에 선언되어 메서드 내에서만 사용 가능
- 메서드가 종료되면 소멸되어 사용 불가
- for,while의 블럭 내에 선언된 지역변수는, 선언된 블럭{} 내에서만 사용가능, 블럭을 벗어나면 사용불가 



#### 3.2 클래스변수와 인스턴스변수

게임 카드 예시

- 각 Card인스턴스는 자신만의 무늬,숫자를 유지하고 있어야 하므로 이들을 **인스턴스변수로 선언**

- 각 카드의 폭과 높이는 모든 인스턴스가 공통적으로 같은 값을 유지해야하므로 **클래스변수로  선언**
- 카드의 폭을 변경해야할 필요가 있는경우 한카드의 width값만 변경해도 모든 카드의 값이 변경됨

<img src="https://github.com/GitmasterLJH/java-til/assets/129172593/ade81d68-81df-40ad-940a-9da326d68cdb" width="500px" height="200px">

#### 3.3 메서드

```
반환타입 메서드이름 (타입 변수명, 타입변수명, ...)  ----> 선언부
{                                              	 | 
		// 메서드 호출시 수행될 코드			      |--->	  구현부		
}											     |   
```

```java
int add(int a, int b)       ----> 선언부
{												|
	int result = a + b;							|---> 구현부
	return result;								|
}												|	
    
    
int add(int x, int y) // OK
int add(int x, y)     // 에러. 매개변수 y의 타입이 없다.
```

**return문**

- return 반환값;에서 반환값은 **반환타입과 일치하거나 적어도 자동 형변환이 가능한 것**이어야한다.

**지역변수**

```java
int add(int x, int y){
	int result = x + y;
	return result;
}

int multiply(int x, int y){
	int result = x * y;
	return result;
}
// 위에 정의된 메서드 add, multiply에 각기 선언된 변수 x,y,result는 이름만 같을 뿐 서로 다른 변수이다. 
```

#### 3.5 메서드의 호출

**-같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능**

**-static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.**

```java
메서드이름(값1,값2....); // 메서드 호출하는 방법

print99danAll();	   // void print99danAll()을 호출
int result = add(3,5)  // int add(int x, int y)를 호출하고, 결과를 result에 저장
```

**인자(argument), 매개변수(parameter)**

- 메서드를 호출할때 괄호()안에 지정해준 값들을 인자 또는 인수라고 함
- 인자는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 **매개변수의 타입과 일치하거나 자동 형변환**이 가능해야함.

#### 3.6 return문

```java
int max(int a, int b){
	if(a>b)
		return a;  // 조건식이 참일 때만 실행되기에 return문이 없다는 에러가 발생
}
// 이런 경우 다름과 같이 else블럭에 return문을 추가 해야함

int max(int a, int b){
	if(a>b)
		return a;
    else
        return b;
}
```

**매개변수의 유효성 검사**

- 호출하는 쪽에서 알아서 적절한 값을 넘겨주겠지 라는 생각을 절대로 가져서는 안된다

예제(0으로 나누는 것은 금지되어 있기에 계산 전에 y의 값이 0인지 확인)

```
float divide(int x, int y){
	//작업을 하기전에 나누는 수(y)가 0인지 확인한다.
	if(y==0){
		System.out.println("0으로 나눌 수 없습니다.");
		return 0; // 매개변수가 유효하지 않으므로 메서드를 종료한다.
	}
	return x/(float)y;
}
```

#### 3.7 JVM의 메모리 구조

1.메서드 영역(method area)

- 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.

2.힙(heap)

- 인스턴스가 생성되는 공간, 프로그램 실행 중에 생성되는 인스턴스는 모두 이곳에 생성된다.
- 즉, 인스턴스변수들이 생성되는 공간

3.호출스택(call stack 또는 execution stack)

- 메서드의 작업에 필요한 메모리 공간을 제공
- 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 지워진다.

#### 3.8 기본형 매개변수와 참조형 매개변수

```
기본형 매개변수	:	변수의 값을 읽기만 할 수 있다.(read only)
참조형 매개변수	:	변수의 값을 읽고 변경할 수 있다.(read & write)   값이 저장된 곳의 주소를 알 수 있기 때문에
```

#### 3.9 참조형 반환타입

```java
public class ReferenceReturnEx {
    public static void main(String[] args) {	
        Data d = new Data();		// 객체 생성
        d.x = 10;					// d의 인스턴스 변수 x 에 10저장

        Data d2 = copy(d);				// tmp의 주소값을 참조변수 d2에 저장
        System.out.println("d.x ="+d.x);
        System.out.println("d2.x="+d2.x);

    }

    static Data copy(Data d){
        Data tmp = new Data();		// 새로운 객체 생성
        tmp.x = d.x; 				// d.x에 저장된 값을 tmp.x에 복사
        return tmp;					// tmp의 주소값을 반환 
    }
}
```

