# Chapter 15 입출력 I/O

# 1. 자바에서의 입출력

## 1.1 입출력이란?

### **I/O** 

- Input(입력)과 Ouput(출력)의 약자

- **컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말함**

<br/>

<br/>

<br/>

## 1.2 스트림(stream)

자바에서 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면(**입출력을 수행하려면**), 두 대상을 연결하고 데이터를 전송할 수 있는 **스트림**(stream)이 필요하다.

> 14장의 스트림과 같은 용어를 쓰지만 다른 개념

<br/>

### 스트림이란?

- **데이터를 운반(입출력)하는데 사용되는 연결 통로**
- 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름이다.
- 먼저 보낸 데이터를 먼저 받게 되어있으며 연속적으로 데이터를 주고 받음
- **단반향통신만 가능**하다(하나의 스트림으로 입력과 출력을 동시에 처리 불가)
- 입출력을 동시에 수행하려면, 2개의 스트림이 필요하다
  - input stream(입력 스트림)
  - output stream(출력 스트림)

![Image](https://github.com/user-attachments/assets/26e7e984-2e6f-4c3a-aa5f-8129826e7417)

<br/>

<br/>

<br/>

## 1.3 바이트기반 스트림 - InputStream, OutputStream

바이트기반 스트림은 데이터를 **바이트**(byte)단위로 주고받는다.

<br/>

### 아래는 여러 종류의 입출력 스트림이다.

| 입력스트림           | 출력스트림            | 입출력 대상의 종류          |
| -------------------- | --------------------- | --------------------------- |
| FileInputStream      | FileOutputStream      | 파일                        |
| ByteArrayInputStream | ByteArrayOutputStream | 메모리(byte 배열)           |
| PipedInputStream     | PipedOutputStream     | 프로세스(프로세스간의 통신) |
| AudioInputStream     | AudioOutputStream     | 옹디오장치                  |

만약 어떤 파일의 내용을 읽고자 하는 경우 FileInputStream을 사용하면 된다.

이들은 모두 InputStream, OutputStream의 자손들이며, 각각 읽고 쓰는데 필요한 추상메서드를 자신에 맞게 구현해 놓음

> 자바에선 java.io패키지를 통해서 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하다.

<br/>

### InputStream과 OutputStream에 정의된 읽기와 쓰기를 수행하는 메서드

| InputStream                          | OutputStream                           |
| ------------------------------------ | -------------------------------------- |
| abstract int read()                  | abstract void write(int b)             |
| int read(byte[] b)                   | void write(byte[] b)                   |
| int read(byte[] b, int off, int len) | void write(byte[] b, int off, int len) |

> read()의 반환타입이 byte가 아니라 int인 이유는 read()의 반환값의 범위가 0~255와 -1이기 때문이다

**InputStream**의 `read()`와 **OutputStream**의 `write(int b)`는 입출력의 대상에 따라 알맞게 구현하라는 의미에서 **추상메서드로 정의되어 있다**. 

추상메서드를 구현안하고 추상메서드가 아닌 다른 메서드 `int read(byte[] b)`, `void write(byte[] b)`를 쓰면 될 것이라고 생각할 수 있지만 사실 **추상메서드**인 `read()`와 `write(int b)`를 이용해서 구현한 것들이여서 **무조건 구현해야함** 

<br/>

<br/>

### InputStream의 실제 소스코드의 일부를 이해하기 쉽게 변형한 버전

```java
public abstract class InputStream{
    ...
        
    // 입력스트림으로 부터 1 byte를 읽어서 반환한다. 읽을 수 없으면 -1을 반환
    abstract int read();
    
    // 입력스트림으로부터 len개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다.
    int read(byte[] b, int off, int len){
        ...
        for(int i=off;i<off+len;i++){
            b[i] = (byte)read();
        }
    }
    ...
        // 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다.
        int read(byte[] b){
        return read(b, 0, b.length);
    }
    ...
}
```

위 코드를 보면 `read(byte[] b)`가 `read(byte[] b, int off, int len)`를 호출하고 `read(byte[] b, int off, int len)`가 추상메서드인 `read()`를 호출하는 것을 알수있다.

**결론적으로 read()는 반드시 구현되어야하는 핵심적인 메서드**

<br/>

<br/>

<br/>

## 1.4 보조 스트림

### 보조스트림

-  스트림의 기능을 향상시키거나 새로운 기능을 추가하기 위해 사용
- 실제 데이터를 주고받는 스트림이 아니기 때문에 **독립적으로 입출력을 수행 못함**

<br/>

**text.txt** 파일을 읽을 때,  입력 성능을 향상시키기 위해 버퍼를 사용하는 **보조스트림인 BufferedInputStream**을 사용하는 코드

```java
// 먼저 기반스트림을 생성한다.
FileInputStream fis = new FileInputStream("test.txt");

// 기반스트림을 이용해서 보조스트림을 생성한다.
BufferdInputStream bis = new BufferedInputStream(fis);
bis.read();	// 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.
```

- 보조스트림이 입력기능을 수행하는 것처럼 보이지만, **실제 입력기능은** BufferedInputStream과 연결된 **FileInputStream**이 수행
- 보조스트림인 BufferedInputStream은 **버퍼만을 제공**한다.
- 실제로 버퍼를 사용한것과 안한 입출력간의 성능차이는 상당하기에 대부분 버퍼를 이용한 보조스트림 사용한다.

<br/>

<br/>

### 바이트 기반 보조스트림의 종류

| 입력                  | 출력                 | 설명                                                         |
| --------------------- | -------------------- | ------------------------------------------------------------ |
| FilterInputStream     | FilterOutputStream   | 필터를 이용한 입출력 처리                                    |
| BufferedInputStream   | BufferedOutputStream | 버퍼를 이용한 입출력 성능향상                                |
| DataInputStream       | DataOutputStream     | int, float와 같은 기본형 단위로 데이터를 처리하는 기능       |
| SequenceInputStream   | 없음                 | 두 개의  스트림을 하나로 연결                                |
| LineNumberInputStream | 없음                 | 읽어 온 데이터의 라인 번호를 카운트<br />(JDK1.1부터 LineNumberReader로 대체) |
| ObjectInputStream     | ObjectOutputStream   | 데이터를 객체단위로 읽고 쓰는데 사용.<br />주로 파일을 이용하며 객체 직렬화와 관련있음 |
| 없음                  | PrintStream          | 버퍼를 이용하며, 추가적인 print관련 기능<br />(print, printf, println메서드) |
| PushbackInputStream   | 없음                 | 버퍼를 이용해서 읽어온 데이터를 다시 되돌리는 기능<br />(unread, push back to buffer) |

모든 보조스트림은 InputStream과 OutputStream의 자손들이므로 입출력방법이 같다.

![Image](https://github.com/user-attachments/assets/d4a3401a-1b72-4894-8432-0966512d1243)

<br/>

<br/>

<br/>

## 1.5 문자기반 스트림 - Reader, Writer

입출력 단위가 **문자**(char, 2byte)인 스트림, 문자기반 스트림의 최고 조상이다.

<br/>

```
InputStream  -------> Reader
OutputStream -------> Writer
```

### 바이트기반 스트림과 문자기반 스트림 비교

| 바이트기반 스트림                                            | 문자기반 스트림                      |
| ------------------------------------------------------------ | ------------------------------------ |
| FileInputStream<br />FileOuputStream                         | FileReader<br />FileWriter           |
| ByteArrayInputStream<br />ByteArrayOuputStream               | CharArrayReader<br />CharArrayWriter |
| PipedInputStream<br />PipedOutputStream                      | PipedReader<br />PipedWriter         |
| StringBufferInputStream(deprecated)<br />StringBufferOutputStream(deprecated) | StringReader<br />StringWriter       |

<br/>

<br/>

### 읽고 쓰는 메서드 비교

| InputStream                                                  | Reader                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract int read()<br/>int read(byte[] b)<br/>int read(byte[] b, int off, int len) | int read()<br/>int read(char[] cbuf)<br/>abstract int read(char[] cbuf, int off, int len) |

| OutputStream                                                 | Writer                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract void write(int b)<br/>void write(byte[] b)<br/>void write(byte[] b, int off, int len) | void write(int c)<br/>void write(char[] cbuf)<br/>abstract void write(char[] cbuf, int off, int len)<br/>void write(String str)<br/>void write(String str, int off, int len) |

<br/>

<br/>

### 보조스트림 비교

| 바이트기반 보조스트림                         | 문자기반 보조스트림                |
| --------------------------------------------- | ---------------------------------- |
| BufferedInputStream<br />BufferedOuputtStream | BufferedReader<br />BufferedWriter |
| FilterInputStream<br />FilterOutputStream     | FilterReader<br />FilterWriter     |
| LineNumberInputStream(deprecated)             | LineNumberReader                   |
| PushbackInputStream                           | PushbackReader                     |

<br/>

<br/>

<br/>

<br/>

# 2. 바이트기반 스트림

## 2.1 InputStream과 OutputStream

![Image](https://github.com/user-attachments/assets/a8b122d2-ee44-451d-98e8-6c9be2c8a6bb)

`flush()`는 버퍼가 있는 출력스트림의 경우에만 의미가 있으며, OutputStream에 정의된 `flush()`는 아무런 일도 하지 않는다.

프로그램이 종료될때, 사용하고 닫지 않은 스트림을 JVM이 자동으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후 에는 `close()`를 호출해서 반드시 닫아줘야 한다.

ByteArrayInputStream과 같이 **메모리를 사용하는 스트림**과 System.in, System.out과 같은 **표준 입출력 스트림**은 닫아 주지 않아도 됨

<br/>

<br/>

<br/>

## 2.2 ByteArrayInputStream과 ByteArrayOutputStream

> 위 클래스는 자주 사용되지는 않음

메모리, 즉 메모리내의 **바이트배열에 데이터를 입출력 하는데 사용하는 스트림**이다.

주로 다른 곳에 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 가비지컬렉터에 의해 자동적으로 자원을 반환하므로 `close()`를 이용해서 **스트림을 닫지 않아도 된다.**

<br/>

<br/>

#### 예제1

`read()`와 `write()`를 사용하는 가장 기본적인 방법을 보여준다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEX1 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = null;
        ByteArrayOutputStream output = null;

        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();

        int data = 0;


        while ((data = input.read()) != -1) {
            output.write(data); // void write(int b)
        }
        outSrc = output.toByteArray();  // 스트림의 내용을 byte배열로 반환한다.

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/* 
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제2

예제1은 `read()`와 `write(int b)`를 사용하기에  한 번에 1byte만 읽고 쓰므로 작업효율이 떨어지기에 배열을 사용하여 입출력 작업이 보다 효율적으로 이루어지도록함

- byte배열과 `int read(byte[] b, int off, int len)` 와 `void write(byte[] b, int off, int len)`를 사용하여 한 번에 배열의 크기만큼 읽고 쓸 수 있게함

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Arrays;

public class IOEX2 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        byte[] temp = new byte[10];

        // input 스트림에서 최대 temp.length만큼 바이트를 읽어 temp 배열의 0번째 인덱스부터 저장
        input.read(temp, 0, temp.length); // 읽어 온 데이터를 배열 temp에 담는다.
        
        // temp 배열의 5번째 인덱스부터 5개의 바이트를 output 스트림에 쓴다.
        output.write(temp, 5, 5); 

        outSrc = output.toByteArray(); //  출력 스트림(output)에 쓰인 데이터들을 outSrc 배열로 복사

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("temp :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/*
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제3

`read()`나 `write()`이 **IOException**을 발생시킬 수 있기에 try-catch문으로 감싸줌

`available()`은 스트림으로부터 **blocking없이 읽어 올 수 있는 바이트의 수를 반환**한다.

> 블락킹(blocking)이란 데이터를 읽어 올 때 데이터를 기다리기 위해 멈춰있는 것을 뜻한다.
>
> 예를 들어 사용자가 데이터를 입력하기 전까지 기다리고 있을 때 블락킹 상태에 있다고 한다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEx3 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;
        byte[] temp = new byte[4]; // 이전 예제와 배열의 크기가 다르다.

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        System.out.println("Input Source :" + Arrays.toString(inSrc));

        try {
            while (input.available() > 0) {
                input.read(temp);
                output.write(temp);

                outSrc = output.toByteArray();
                printArrays(temp, outSrc);
            }
        } catch (IOException e) {}
    }

    static void printArrays(byte[] temp, byte[] outSrc) {
        System.out.println("temp          :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
```

**결과**

```
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6, 7]
```

결과를 보면 예상과 다른데 그 이유는 마지막에 읽은 배열의 9번째와 10번째 요소값인 8과 9만을 출력해야하는데  temp에 남아 있던 6,7까지 출력했기 때문이다. 보다 나은 성능을 위해서 temp에 담긴 내용을 지우고 쓰는 것이 아니라 그냥 기존의 내용 위에 덮어쓴다.

그래서 temp의 내용은 `[4,5,6,7]`에서 8과 9을 읽고 난 후에는 `[8,9,6,7]`이 된다.

원하는 결과를 얻기위해서는 다음과 같이 출력해야함

- `int len = input.read(temp)`은 읽어온 데이터의 개수를 반환하고
- `output.write(temp, 0, len)`은 읽어 온 만큼 write한다.

![Image](https://github.com/user-attachments/assets/2ef4ff87-d0e0-45a6-95ed-09850ce0b162)

```java
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]		// 올바른 출력이 됨
```

<br/>

<br/>

<br/>

## 2.3 FIleInputStream과 FileOutputStream

파일에 입출력을 하기 위한 스트림

> 자주 사용됨

### FIleInputStream 생성자

| 생성자                                | 설명                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| FileInputStream(String name)          | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileInputStream을 생성한다. |
| FileInputStream(File file)            | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileInputStream(FileDescriptor fdObj) | 파일 디스크립터(fdObj)로 FIleInputStream을 생성한다.         |

### FileOutputStream의 생성자

| 생성자                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| FileOutputStream(String name)                 | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileOutputStream을 생성한다. |
| FileOutputStream(File file)                   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(String name, boolean append) | 두번째 인자인 append를 true로 하면, 출력 시 기존의 파일의 마지막에 덧붙인다, false면 기존의 파일내용을 덮어쓰게 된다. |
| FileOutputStream(File file, boolean append)   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(FileDescriptor fdObj)        | 파일 디스크립터(fdObj)로 FIleOutputStream을 생성한다.        |

<br/>

<br/>

#### 예제1

커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 간단한 예제.

```java
import java.io.*;

public class FileViewer {
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream(args[0]);	// args[0]에는 이 파일의 경로
        int data = 0;

        /*
        read()의 반환값이 int(4byte) 이긴 하지만, 더 이상 입력값이 없음을 알리는 -1을 제외하고 
        0~255(1byte)범위의 정수값이기 때문에, char형(2byte)로 변환해도 손실되는 값이 없다.
        */
        
        while((data=fis.read())!=-1){
            char c = (char)data;
            System.out.print(c);
        }
    }
}
```

read()가 한 번에 1byte씩 파일로부터 데이터를 읽어 들이긴 하지만, 데이터의 범위가 십진수로 0~255(16진수로는 0x00~0xff)범위의 정수값이고, 또 읽을 수 있는 입력값이 더 이상 없음을 알릴 수 있는 값(-1)도 필요하다. 그래서 다소 크긴 하지만 정수형중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한다.

<br/>

<br/>

#### 예제2

단순히 FileCopy.java의 내용을 `read()`로 읽어서, `write(int b)`로 FileCopy.bak에 출력하는 예제

> 이처럼 텍스트파일을 다루는 경우에는 FileInputStream/FIleOutputStream보다 문자기반의 스트림인 FIleReader/FileWriter를 사용하는 것이 더 좋다.

```java
import java.io.*;


public class FileCopy {
    public static void main(String[] args) {
        try{
            FileInputStream fis = new FileInputStream(args[0]);	// FileCopy.java의 경로
            FileOutputStream fos = new FileOutputStream(args[1]); // FileCopy.bak의 경로

            int data = 0;
            while((data=fis.read())!=-1){
                fos.write(data);
            }
            fis.close();
            fos.close();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
```

> FileOutputStream fos = new FileOutputStream(args[1], true)와 같이 생성자의 두번째 매개변수의 값을 true로 하면 기존 파일의 마지막 내용에 덧붙인다.

![Image](https://github.com/user-attachments/assets/69f915f4-06b3-49aa-bc66-63adba9ef64e)

<br/>

<br/>

<br/>

<br/>
