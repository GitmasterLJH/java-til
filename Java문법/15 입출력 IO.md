# Chapter 15 입출력 I/O

# 1. 자바에서의 입출력

## 1.1 입출력이란?

### **I/O** 

- Input(입력)과 Ouput(출력)의 약자

- **컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말함**

<br/>

<br/>

<br/>

## 1.2 스트림(stream)

자바에서 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면(**입출력을 수행하려면**), 두 대상을 연결하고 데이터를 전송할 수 있는 **스트림**(stream)이 필요하다.

> 14장의 스트림과 같은 용어를 쓰지만 다른 개념

<br/>

### 스트림이란?

- **데이터를 운반(입출력)하는데 사용되는 연결 통로**
- 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름이다.
- 먼저 보낸 데이터를 먼저 받게 되어있으며 연속적으로 데이터를 주고 받음
- **단반향통신만 가능**하다(하나의 스트림으로 입력과 출력을 동시에 처리 불가)
- 입출력을 동시에 수행하려면, 2개의 스트림이 필요하다
  - input stream(입력 스트림)
  - output stream(출력 스트림)

![Image](https://github.com/user-attachments/assets/26e7e984-2e6f-4c3a-aa5f-8129826e7417)

<br/>

<br/>

<br/>

## 1.3 바이트기반 스트림 - InputStream, OutputStream

바이트기반 스트림은 데이터를 **바이트**(byte)단위로 주고받는다.

<br/>

### 아래는 여러 종류의 입출력 스트림이다.

| 입력스트림           | 출력스트림            | 입출력 대상의 종류          |
| -------------------- | --------------------- | --------------------------- |
| FileInputStream      | FileOutputStream      | 파일                        |
| ByteArrayInputStream | ByteArrayOutputStream | 메모리(byte 배열)           |
| PipedInputStream     | PipedOutputStream     | 프로세스(프로세스간의 통신) |
| AudioInputStream     | AudioOutputStream     | 옹디오장치                  |

만약 어떤 파일의 내용을 읽고자 하는 경우 FileInputStream을 사용하면 된다.

이들은 모두 InputStream, OutputStream의 자손들이며, 각각 읽고 쓰는데 필요한 추상메서드를 자신에 맞게 구현해 놓음

> 자바에선 java.io패키지를 통해서 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하다.

<br/>

### InputStream과 OutputStream에 정의된 읽기와 쓰기를 수행하는 메서드

| InputStream                          | OutputStream                           |
| ------------------------------------ | -------------------------------------- |
| abstract int read()                  | abstract void write(int b)             |
| int read(byte[] b)                   | void write(byte[] b)                   |
| int read(byte[] b, int off, int len) | void write(byte[] b, int off, int len) |

> read()의 반환타입이 byte가 아니라 int인 이유는 read()의 반환값의 범위가 0~255와 -1이기 때문이다

**InputStream**의 `read()`와 **OutputStream**의 `write(int b)`는 입출력의 대상에 따라 알맞게 구현하라는 의미에서 **추상메서드로 정의되어 있다**. 

추상메서드를 구현안하고 추상메서드가 아닌 다른 메서드 `int read(byte[] b)`, `void write(byte[] b)`를 쓰면 될 것이라고 생각할 수 있지만 사실 **추상메서드**인 `read()`와 `write(int b)`를 이용해서 구현한 것들이여서 **무조건 구현해야함** 

<br/>

<br/>

### InputStream의 실제 소스코드의 일부를 이해하기 쉽게 변형한 버전

```java
public abstract class InputStream{
    ...
        
    // 입력스트림으로 부터 1 byte를 읽어서 반환한다. 읽을 수 없으면 -1을 반환
    abstract int read();
    
    // 입력스트림으로부터 len개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다.
    int read(byte[] b, int off, int len){
        ...
        for(int i=off;i<off+len;i++){
            b[i] = (byte)read();
        }
    }
    ...
        // 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다.
        int read(byte[] b){
        return read(b, 0, b.length);
    }
    ...
}
```

위 코드를 보면 `read(byte[] b)`가 `read(byte[] b, int off, int len)`를 호출하고 `read(byte[] b, int off, int len)`가 추상메서드인 `read()`를 호출하는 것을 알수있다.

**결론적으로 read()는 반드시 구현되어야하는 핵심적인 메서드**

<br/>

<br/>

<br/>

## 1.4 보조 스트림

### 보조스트림

-  스트림의 기능을 향상시키거나 새로운 기능을 추가하기 위해 사용
- 실제 데이터를 주고받는 스트림이 아니기 때문에 **독립적으로 입출력을 수행 못함**

<br/>

**text.txt** 파일을 읽을 때,  입력 성능을 향상시키기 위해 버퍼를 사용하는 **보조스트림인 BufferedInputStream**을 사용하는 코드

```java
// 먼저 기반스트림을 생성한다.
FileInputStream fis = new FileInputStream("test.txt");

// 기반스트림을 이용해서 보조스트림을 생성한다.
BufferdInputStream bis = new BufferedInputStream(fis);
bis.read();	// 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.
```

- 보조스트림이 입력기능을 수행하는 것처럼 보이지만, **실제 입력기능은** BufferedInputStream과 연결된 **FileInputStream**이 수행
- 보조스트림인 BufferedInputStream은 **버퍼만을 제공**한다.
- 실제로 버퍼를 사용한것과 안한 입출력간의 성능차이는 상당하기에 대부분 버퍼를 이용한 보조스트림 사용한다.

<br/>

<br/>

### 바이트 기반 보조스트림의 종류

| 입력                  | 출력                 | 설명                                                         |
| --------------------- | -------------------- | ------------------------------------------------------------ |
| FilterInputStream     | FilterOutputStream   | 필터를 이용한 입출력 처리                                    |
| BufferedInputStream   | BufferedOutputStream | 버퍼를 이용한 입출력 성능향상                                |
| DataInputStream       | DataOutputStream     | int, float와 같은 기본형 단위로 데이터를 처리하는 기능       |
| SequenceInputStream   | 없음                 | 두 개의  스트림을 하나로 연결                                |
| LineNumberInputStream | 없음                 | 읽어 온 데이터의 라인 번호를 카운트<br />(JDK1.1부터 LineNumberReader로 대체) |
| ObjectInputStream     | ObjectOutputStream   | 데이터를 객체단위로 읽고 쓰는데 사용.<br />주로 파일을 이용하며 객체 직렬화와 관련있음 |
| 없음                  | PrintStream          | 버퍼를 이용하며, 추가적인 print관련 기능<br />(print, printf, println메서드) |
| PushbackInputStream   | 없음                 | 버퍼를 이용해서 읽어온 데이터를 다시 되돌리는 기능<br />(unread, push back to buffer) |

모든 보조스트림은 InputStream과 OutputStream의 자손들이므로 입출력방법이 같다.

![Image](https://github.com/user-attachments/assets/d4a3401a-1b72-4894-8432-0966512d1243)

<br/>

<br/>

<br/>

## 1.5 문자기반 스트림 - Reader, Writer

입출력 단위가 **문자**(char, 2byte)인 스트림, 문자기반 스트림의 최고 조상이다.

<br/>

```
InputStream  -------> Reader
OutputStream -------> Writer
```

### 바이트기반 스트림과 문자기반 스트림 비교

| 바이트기반 스트림                                            | 문자기반 스트림                      |
| ------------------------------------------------------------ | ------------------------------------ |
| FileInputStream<br />FileOuputStream                         | FileReader<br />FileWriter           |
| ByteArrayInputStream<br />ByteArrayOuputStream               | CharArrayReader<br />CharArrayWriter |
| PipedInputStream<br />PipedOutputStream                      | PipedReader<br />PipedWriter         |
| StringBufferInputStream(deprecated)<br />StringBufferOutputStream(deprecated) | StringReader<br />StringWriter       |

<br/>

<br/>

### 읽고 쓰는 메서드 비교

| InputStream                                                  | Reader                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract int read()<br/>int read(byte[] b)<br/>int read(byte[] b, int off, int len) | int read()<br/>int read(char[] cbuf)<br/>abstract int read(char[] cbuf, int off, int len) |

| OutputStream                                                 | Writer                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract void write(int b)<br/>void write(byte[] b)<br/>void write(byte[] b, int off, int len) | void write(int c)<br/>void write(char[] cbuf)<br/>abstract void write(char[] cbuf, int off, int len)<br/>void write(String str)<br/>void write(String str, int off, int len) |

<br/>

<br/>

### 보조스트림 비교

| 바이트기반 보조스트림                         | 문자기반 보조스트림                |
| --------------------------------------------- | ---------------------------------- |
| BufferedInputStream<br />BufferedOuputtStream | BufferedReader<br />BufferedWriter |
| FilterInputStream<br />FilterOutputStream     | FilterReader<br />FilterWriter     |
| LineNumberInputStream(deprecated)             | LineNumberReader                   |
| PushbackInputStream                           | PushbackReader                     |

<br/>

<br/>

<br/>

<br/>

# 2. 바이트기반 스트림

## 2.1 InputStream과 OutputStream

![Image](https://github.com/user-attachments/assets/a8b122d2-ee44-451d-98e8-6c9be2c8a6bb)

`flush()`는 버퍼가 있는 출력스트림의 경우에만 의미가 있으며, OutputStream에 정의된 `flush()`는 아무런 일도 하지 않는다.

프로그램이 종료될때, 사용하고 닫지 않은 스트림을 JVM이 자동으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후 에는 `close()`를 호출해서 반드시 닫아줘야 한다.

ByteArrayInputStream과 같이 **메모리를 사용하는 스트림**과 System.in, System.out과 같은 **표준 입출력 스트림**은 닫아 주지 않아도 됨

<br/>

<br/>

<br/>

## 2.2 ByteArrayInputStream과 ByteArrayOutputStream

> 위 클래스는 자주 사용되지는 않음

메모리, 즉 메모리내의 **바이트배열에 데이터를 입출력 하는데 사용하는 스트림**이다.

주로 다른 곳에 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 가비지컬렉터에 의해 자동적으로 자원을 반환하므로 `close()`를 이용해서 **스트림을 닫지 않아도 된다.**

<br/>

<br/>

#### 예제1

`read()`와 `write()`를 사용하는 가장 기본적인 방법을 보여준다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEX1 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = null;
        ByteArrayOutputStream output = null;

        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();

        int data = 0;


        while ((data = input.read()) != -1) {
            output.write(data); // void write(int b)
        }
        outSrc = output.toByteArray();  // 스트림의 내용을 byte배열로 반환한다.

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/* 
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제2

예제1은 `read()`와 `write(int b)`를 사용하기에  한 번에 1byte만 읽고 쓰므로 작업효율이 떨어지기에 배열을 사용하여 입출력 작업이 보다 효율적으로 이루어지도록함

- byte배열과 `int read(byte[] b, int off, int len)` 와 `void write(byte[] b, int off, int len)`를 사용하여 한 번에 배열의 크기만큼 읽고 쓸 수 있게함

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Arrays;

public class IOEX2 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        byte[] temp = new byte[10];

        // input 스트림에서 최대 temp.length만큼 바이트를 읽어 temp 배열의 0번째 인덱스부터 저장
        input.read(temp, 0, temp.length); // 읽어 온 데이터를 배열 temp에 담는다.
        
        // temp 배열의 5번째 인덱스부터 5개의 바이트를 output 스트림에 쓴다.
        output.write(temp, 5, 5); 

        outSrc = output.toByteArray(); //  출력 스트림(output)에 쓰인 데이터들을 outSrc 배열로 복사

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("temp :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/*
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제3

`read()`나 `write()`이 **IOException**을 발생시킬 수 있기에 try-catch문으로 감싸줌

`available()`은 스트림으로부터 **blocking없이 읽어 올 수 있는 바이트의 수를 반환**한다.

> 블락킹(blocking)이란 데이터를 읽어 올 때 데이터를 기다리기 위해 멈춰있는 것을 뜻한다.
>
> 예를 들어 사용자가 데이터를 입력하기 전까지 기다리고 있을 때 블락킹 상태에 있다고 한다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEx3 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;
        byte[] temp = new byte[4]; // 이전 예제와 배열의 크기가 다르다.

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        System.out.println("Input Source :" + Arrays.toString(inSrc));

        try {
            while (input.available() > 0) {
                input.read(temp);
                output.write(temp);

                outSrc = output.toByteArray();
                printArrays(temp, outSrc);
            }
        } catch (IOException e) {}
    }

    static void printArrays(byte[] temp, byte[] outSrc) {
        System.out.println("temp          :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
```

**결과**

```
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6, 7]
```

결과를 보면 예상과 다른데 그 이유는 마지막에 읽은 배열의 9번째와 10번째 요소값인 8과 9만을 출력해야하는데  temp에 남아 있던 6,7까지 출력했기 때문이다. 보다 나은 성능을 위해서 temp에 담긴 내용을 지우고 쓰는 것이 아니라 그냥 기존의 내용 위에 덮어쓴다.

그래서 temp의 내용은 `[4,5,6,7]`에서 8과 9을 읽고 난 후에는 `[8,9,6,7]`이 된다.

원하는 결과를 얻기위해서는 다음과 같이 출력해야함

- `int len = input.read(temp)`은 읽어온 데이터의 개수를 반환하고
- `output.write(temp, 0, len)`은 읽어 온 만큼 write한다.

![Image](https://github.com/user-attachments/assets/2ef4ff87-d0e0-45a6-95ed-09850ce0b162)

```java
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]		// 올바른 출력이 됨
```

<br/>

<br/>

<br/>

## 2.3 FIleInputStream과 FileOutputStream

파일에 입출력을 하기 위한 스트림

> 자주 사용됨

### FIleInputStream 생성자

| 생성자                                | 설명                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| FileInputStream(String name)          | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileInputStream을 생성한다. |
| FileInputStream(File file)            | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileInputStream(FileDescriptor fdObj) | 파일 디스크립터(fdObj)로 FIleInputStream을 생성한다.         |

### FileOutputStream의 생성자

| 생성자                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| FileOutputStream(String name)                 | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileOutputStream을 생성한다. |
| FileOutputStream(File file)                   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(String name, boolean append) | 두번째 인자인 append를 true로 하면, 출력 시 기존의 파일의 마지막에 덧붙인다, false면 기존의 파일내용을 덮어쓰게 된다. |
| FileOutputStream(File file, boolean append)   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(FileDescriptor fdObj)        | 파일 디스크립터(fdObj)로 FIleOutputStream을 생성한다.        |

<br/>

<br/>

#### 예제1

커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 간단한 예제.

```java
import java.io.*;

public class FileViewer {
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream(args[0]);	// args[0]에는 이 파일의 경로
        int data = 0;

        /*
        read()의 반환값이 int(4byte) 이긴 하지만, 더 이상 입력값이 없음을 알리는 -1을 제외하고 
        0~255(1byte)범위의 정수값이기 때문에, char형(2byte)로 변환해도 손실되는 값이 없다.
        */
        
        while((data=fis.read())!=-1){
            char c = (char)data;
            System.out.print(c);
        }
    }
}
```

read()가 한 번에 1byte씩 파일로부터 데이터를 읽어 들이긴 하지만, 데이터의 범위가 십진수로 0~255(16진수로는 0x00~0xff)범위의 정수값이고, 또 읽을 수 있는 입력값이 더 이상 없음을 알릴 수 있는 값(-1)도 필요하다. 그래서 다소 크긴 하지만 정수형중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한다.

<br/>

<br/>

#### 예제2

단순히 FileCopy.java의 내용을 `read()`로 읽어서, `write(int b)`로 FileCopy.bak에 출력하는 예제

> 이처럼 텍스트파일을 다루는 경우에는 FileInputStream/FIleOutputStream보다 문자기반의 스트림인 FIleReader/FileWriter를 사용하는 것이 더 좋다.

```java
import java.io.*;


public class FileCopy {
    public static void main(String[] args) {
        try{
            FileInputStream fis = new FileInputStream(args[0]);	// FileCopy.java의 경로
            FileOutputStream fos = new FileOutputStream(args[1]); // FileCopy.bak의 경로

            int data = 0;
            while((data=fis.read())!=-1){
                fos.write(data);
            }
            fis.close();
            fos.close();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
```

> FileOutputStream fos = new FileOutputStream(args[1], true)와 같이 생성자의 두번째 매개변수의 값을 true로 하면 기존 파일의 마지막 내용에 덧붙인다.

![Image](https://github.com/user-attachments/assets/69f915f4-06b3-49aa-bc66-63adba9ef64e)

<br/>

<br/>

<br/>

<br/>

# 3. 바이트기반의 보조스트림

## 3.1 FilterInputStream과 FilterOutputStream

- 모든 바이트기반 보조스트림의 최고조상
- **보조스트림은** 자체적으로 입출력을 수행할 수 없기 때문에 **기반스트림을 필요**로 한다.

<br/>

### FilterInputStream/FilterOutputStream클래스 분석

- FilterInputStream/FilterOutputStream의 모든 메서드는 **단순히 기반스트림의 메서드를 그대로 호출**할 뿐이다.
- 상속을 통해 원하는 작업을 수행하도록 읽고 쓰는 메서드를 오버라이딩 해야함
- FilterInputStream의 생성자는 접근 제어자가 protected이기에 인스턴스를 생성해서 사용할 수 없고 상속을 통해서 오버라이딩되어야 한다.
- FilterOutputStream의 생성자가 protected가 아니라 public인 이유는 출력때 그대로 출력하는 것은 의미가 있기 때문이다.(항등함수)

```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected FilterInputStream(InputStream in) { 
        this.in = in; 
    }
    
    public int read() throws IOEXception{
        return in.read();
    }
    ...
}
  

public class FilterOutputStream extends OutputStream {
    protected OutputStream out;
    
    public FilterOutputStream(OutputStream out) { 
        this.out = out;
    }    
    
    public void write(int b) throws IOException {
        out.write(b);
    }
    ...
}
```

### Volatile

>  각 스레드가 같은 변수에 대해 읽기, 쓰기 동작을 수행할 시 각자의 `CPU 캐시` 에 `메인 메모리` 의 값과 다른 값을 갖고 있을 수 있게 된다.
>
> `volatile` 변수에 값을 쓰면 → 즉시 메인 메모리에 반영됨.
>
> 다른 스레드가 `volatile` 변수를 읽으면 → 항상 메인 메모리에서 최신 값을 읽음.
>
> > 모든 스레드가 항상 같은 공유 변수의 값을 읽어올 수 있도록 보장함 -> 가시성이 보장됨(원자성은 보장x)

<br/>

<br/>

### **FilterInputStream의 자손**

- BufferedInputStream, DataInputStream, PushbackInputStream 등

### **FilterOutputStream의 자손**

- BufferedOutputStream, DataOutputStream, PrintStream 등

<br/>

<br/>

<br/>

## 3.2 BufferedInputStream과 BufferedOutputStream

- 스트림의 입출력 효율을 높이기 위해 버퍼(byte[])를 사용하는 보조스트림

###  BufferedInputStream 생성자

| 생성자                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| BufferedInputStream(InputStream in, int size) | 주어진 InputStream인스턴스를 입력소스(input source)로 하며 지정된 크기(byte단위)의 버퍼를 갖는 BufferedInputStream 인스턴스를 생성한다. |
| BufferedInputStream(InputStream in)           | 주어진 InputStream인스턴스를 입력소스(input source)로 하며 버퍼의 크기를 지정해주지 않으므로 기본적으로 8192byte 크기의 버퍼를 갖게 된다. |

프로그램에서 read메서드를 호출하면, BufferedInputSteram은 입력소스로 부터 버퍼 크기만큼의 데이터를 읽어다 자신의 내부 버퍼에 저장한다. 

이제 프로그램에서는 버퍼에 저장된 데이터를 읽으면 된다. 외부의 입력소스로 부터 읽는 것보다 내부의 버퍼로 부터 읽는 것이 훨씬 빠르기 떄문에 그만큼 작업 효율이 높아진다. 

프로그램에서 버퍼에 저장된 모든 데이터를 다 읽고 그다음 데이터를 읽기 위해 read메서드가 호출되면, BufferdInputStream은 입력소스로부터 다시 버퍼크기 만큼의 데이터를 읽어다 버퍼에 저장해 놓는다. 이와 같은 작업이 반복됨

<br/>

<br/>

### BufferedOutputStream 생성자

| 메서드/생성자                                    | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| BufferedOutputStream(OutputStream out, int size) | 주어진 OutputStream 인스턴스를 출력소스(output source)로 하며 지정된 크기(단위 byte)의 버퍼를 갖는 BufferedOutputStream인스턴스를 생성한다. |
| BufferedOutputStream(OutputStream out)           | 주어진 OutputStream 인스턴스를 출력소스(output source)로 하며 버퍼의 크기를 지정해주지 않으므로 기본적으로 8192 byte 크기의 버퍼를 갖게 된다. |
| flush()                                          | 버퍼의 모든 내용을 출력소스에 출력한 다음, 버퍼를 비운다.    |
| close()                                          | flush()를 호출해서 버퍼의 모든 내용을 출력소스에 출력하고, BufferedOutputStream인스턴스가 사용하던 모든 자원을 반환한다. |

프로그램에서 write메서드를 이용한 출력이 BufferedOutputStream의 버퍼에 저장된다. 버퍼가 가득 차면, 그 때 버퍼의 모든 내용을 출력소스에 출력한다.  그리고는 버퍼를 비우고 다시 프로그램으로부터 출력을 저장할 준비를 한다.

버퍼가 가득 찼을 때만 출력소스에 출력을 하기 떄문에, 마지막 출력부분이 출력소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다. 그래서 프로그램에서 모든 출력작업을 마친 후 BufferedOuptStream에 close()나 flush()를 호출해서 마지막에 버퍼에 있는 모든 내용이 출력소스에 출력되도록 해야 한다.

> BufferedOutputStream인스턴스의 참조변수에 null을 지정함으로써 사용하던 자원들이 반환되게 한다.

<br/>

<br/>

#### 예제

크기가 5인 BufferdOutputStream을 이용해서 파일 123.txt에 1부터 9까지 출력하는 예제

```java
import java.io.*;

public class BufferedOutputStreamEx1 {
    public static void main(String[] args) {
        try{
            FileOutputStream fos = new FileOutputStream("src/123.txt");

            BufferedOutputStream bos = new BufferedOutputStream(fos, 5);
            // 파일에 1부터 9까지 출력한다.
            for(int i='1'; i<='9';i++){
                bos.write(i);
            }
            fos.close();
        }catch (IOException e){e.printStackTrace();}
    }
}
```

**결과**

```
12345
```

1부터 9까지 출력해야되는데 5까지만 출력되어있다. 그 이유는 **버퍼에 남아있는 데이터가 출력되지 못한 상태로 프로그램이 종료**되었기 때문이다.

![Image](https://github.com/user-attachments/assets/f5e99b58-3716-4c8b-b6d9-b03b1494ccc4)

`fos.close()`로 스트림을 닫아주긴 했지만, BufferdOutputStream의 버퍼에 있는 내용이 출력되지 않음

`bos.close()`와 같이해서 보조스트림인 BufferdOutputStream의 `close()`를 호출해 주어야 버퍼에 남아있던 모든 내용이 출력된다.

아래의 코드는 BufferedOutputStream의 조상인 FilterOutputStream의 소스코드이다. BufferdOutputStream은 `close()`를 오버라이딩  없이 그대로 상속받음

```java
public class FilterOutputStream extends OutputStream{
    protected OutputStream out;
    public FilterOutputStream(OutputStream out){
        this.out = out;
    }
    ...
    public void close() throws IOException{
        try{
            flush();	// 버퍼의 모든 내용을 출력소스에 호출 한다음, 버퍼를 비운다.
        } catch(IOException ignored){}
        out.close();	// 기반 스트림의 close()를 호출한다.
    }
}
```

<br/>

<br/>

<br/>

## 3.3 DataInputStream과 DataOutputStream

- **기본 자료형의 단위로 읽고 쓰는 보조스트림**
- DataOutputStream은 기본자료형을 **이진데이터**로 저장한다.
  - int 값 10을 저장하면 **4바이트의 이진 값**이 그대로 기록된다.
    - 이진 데이터를 16진수 형식으로 표현하면 `00 00 00 0A`와 같이 보인다.
- 각 자료형의 크기가 다르므로, 출력한 순서대로 같은 자료형을 사용해 읽어야 한다.

### DataInputStream의 생성자와 메서드

| 메서드/생성자                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DataInputStream(InputStream in)                              | 주어진 InputStream인스턴스를 기반스트림으로 하는<br />DataInputStream인스턴스를 생성한다. |
| boolean readBoolean()<br />byte        readByte()<br />char        readChar()<br />short      readShort()<br />int           readInt()<br />long        readLong()<br />float       readFloat()<br />double   readDouble()<br />int           readUnsignedByte()<br />int           readUnsignedShort() | 각 타입에 맞게 값을 읽어 온다.<br />더 이상 읽을 값이 없으면 EOFException을 발생시킨다. |
| void readFully(byte[] b)<br />void readFully(byte[] b, int off, int len) | 입력스트림에서 지정된 배열의 크기만큼 또는 지정된 위치에서 len만큼 데이터를 <br />읽어온다. 파일의 끝에 도달하면 EOFException을 발생하고, I/O에러가 발생하면 IOException이 발생 |
| String readUTF()                                             | UTF-8형식으로 쓰여진 문자를 읽는다.<br />더 이상 읽을 값이 없으면 EOFException을 발생시킨다. |
| static String readUTF(DataInput in)                          | 입력스트림(in)에서 UTF-8형식의 유니코드를 읽어온다.          |
| int skipBytes(int n)                                         | 현재 읽고 있는 위치에서 지정된 숫자(n) 만큼을 건너뛴다.      |

<br/>

### DataOutputStream의 생성자와 메서드

| 메서드/생성자                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DataOutputStream(OutputStream out)                           | 주어진 OutputStream인스턴스를 기반스트림으로 하는<br />DataOutputStream인스턴스를 생성한다. |
| void writeBoolean(boolean b)<br/>void writeByte(int b)<br/>void writeChar(int c)<br/>void writeShort(int s)<br/>void writelnt(int I)<br/>void writeLong(long I)<br/>void writeFloat(float f)<br/>void writeDouble(double d) | 각 자료형에 알맞은 값들을 출력한다.                          |
| void writeUTF(String s)                                      | UTF형식으로 문자를 출력한다.                                 |
| void writeChars(String s)                                    | 주어진 문자열을 출력한다. writeChar(int c)메서드를 여러번 호출한 결과와 같다. |
| int size()                                                   | 지금까지 DataOutputStream에 쓰여진 byte의 수를 알려준다.     |

<br/>

<br/>

#### 예제1

FileOutputStream을 기반으로 하는 DataOutputStream을 생성한 후, DataOutputStream의 메서들을 이용해서 sample.dat파일에 값들을 출력하는 예제

```java
import java.io.*;

public class DataOutputStreamEx1 {
    public static void main(String[] args) {
        FileOutputStream fos = null;
        DataOutputStream dos = null;

        try{
            fos = new FileOutputStream("src/sample.dat");
            dos = new DataOutputStream(fos);
            dos.writeInt(10);			// int 4바이트 저장 (00 00 00 0A)
            dos.writeFloat(20.0f); 		// float 4바이트 저장 (41 A0 00 00)
            dos.writeBoolean(true);		// boolean 1바이트 저장 (01)

            dos.close();

        }catch (IOException e){e.printStackTrace();}
    }
}
```

출력한 값들은 이진 데이터(binary data)로 저장된다. 파일을 16진수 코드로 볼 수 있는 UltraEdit과 같은 프로그램이나 ByteArrayOutputStream을 사용하면 이진데이터를 확인할 수 있다.

<br/>

<br/>

#### 예제2

```java
import java.io.*;
import java.util.Arrays;

public class DataOutputStreamEx2 {
    public static void main(String[] args) {
        ByteArrayOutputStream bos = null;
        DataOutputStream dos = null;

        byte[] result = null;

        try {
            bos = new ByteArrayOutputStream();
            dos = new DataOutputStream(bos);
            dos.writeInt(10);			// int 4바이트 출력 (00 00 00 0A)
            dos.writeFloat(20.0f);		// float 4바이트 출력 (41 A0 00 00)
            dos.writeBoolean(true);		// boolean 1바이트 출력 (01)


            result = bos.toByteArray();

            String[] hex = new String[result.length];

            for (int i = 0; i < result.length; i++) {
                if (result[i] < 0) {
                    hex[i] = String.format("%02X", result[i] + 256);	// 음수 값을 부호 없는 값으로 변환
                } else {
                    hex[i] = String.format("%02X", result[i]);	// 양수는 그대로 변환
                }
            }
            System.out.println("10진수 :" + Arrays.toString(result)); // [0, 0, 0, 10, 65, -96, 0, 0, 1]
            System.out.println("16진수 : " + Arrays.toString(hex));	// [00, 00, 00, 0A, 41, A0, 00, 00, 01]

            dos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

`writeInt(10)`에 의해서 출력된 값 : 첫 번째 4byte

| 인덱스 | 값 (10진수) | 값 (16진수) |
| ------ | ----------- | ----------- |
| 0      | 0           | 00          |
| 1      | 0           | 00          |
| 2      | 0           | 00          |
| 3      | 10          | 0A          |

`writeFloat(20.0f)`에 의해서 출력된 값 : 두 번째 4byte

| 인덱스 | 값 (10진수) | 값 (16진수) |
| ------ | ----------- | ----------- |
| 4      | 65          | 41          |
| 5      | -96         | A0          |
| 6      | 0           | 00          |
| 7      | 0           | 00          |

`writeBoolean(true)`에 의해서 출력된 값 : 마지막 1byte

| 인덱스 | 값(10진수) | 값(16진수) |
| ------ | ---------- | ---------- |
| 8      | 1          | 01         |

<br/>

### 값이 음수일때 256을 더한 이유

![Image](https://github.com/user-attachments/assets/3f9f9cc1-4020-4443-8362-d6fe47596e03)

부호 비트가 있으면 범위는 -128~127, 부호 비트가 없으면 범위는 0~255가 된다.

결국 같은 데이터지만 자바의 자료형인 byte의 범위가 부호 있는 1byte 정수의 범위인 -128~127이기 때문에 -1로 인식한다는 것이다. 그래서 이 값을 0~255사이의 값으로 변환하려면 256을 더해주어야 한다. 

다음에 `String.format()`을 사용해서 10진 정수를 16진수 정수로 변환하여 출력함

<br/>

<br/>

#### 예제3

예제1을 실행해서 만들어진 sample.dat를 읽어서 화면에 출력하는 예제

- **여러 가지 종류의 자료형으로 출력한 경우 읽을 때는 반드시 순서대로 읽어야한다.**

```java
import java.io.*;

public class DataInputStreamEx1 {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("src/sample.dat");
            DataInputStream dis = new DataInputStream(fis);

            System.out.println(dis.readInt());
            System.out.println(dis.readFloat());
            System.out.println(dis.readBoolean());
            dis.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
/* 결과
10
20.0
true
*/
```

### DataInputStream과 DataOutputStream 사용 장점

#### 1. **데이터 변환 과정이 필요 없음**

- **문자열로 저장하면 → 숫자로 변환해야 함** (`Integer.parseInt("100")` 필요)
- **DataOutputStream을 사용하면 → 그대로 읽을 수 있음** (`readInt()`만 호출하면 됨)
- 변환 과정이 없으므로 **빠르고 간편함**

<br/>

#### 2. **자리수를 따질 필요 없음**

- 문자열 `"100200300"`으로 저장하면 자리수를 구분해야 함
- `writeInt(100); writeInt(200); writeInt(300);` 하면
  **100(4B) → 200(4B) → 300(4B)** 순서로 저장되므로
  `readInt(); readInt(); readInt();` 만 하면 원래 데이터 그대로 읽을 수 있음

<br/>

✅결론

**DataOutputStream / DataInputStream을 사용하면 더 효율적이고 빠르게 데이터를 저장하고 읽을 수 있다!**

<br/>

<br/>

#### 예제4

int형 배열 score의 값들을 DatatOutputStream을 이용해서 score.dat파일에 출력하는 예제

```java
import java.io.*;

public class DataOutputStreamEx3 {
    public static void main(String[] args) {
        int[] score = {100, 90, 95, 85, 50};

        try {
            FileOutputStream fos = new FileOutputStream("src/score.dat");
            DataOutputStream dos = new DataOutputStream(fos);

            for (int i = 0; i < score.length; i++) {
                dos.writeInt(score[i]);
            }
            dos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### sccore.dat의 실제 저장된 내용

int의 크기가 4byte이므로 모두 20byte의 데이터가 저장되어 있다. 밑줄 아래의 숫자는 10진수로 변환한 결과

> 16진수 두자리가 1byte

!![Image](https://github.com/user-attachments/assets/b58a63ef-2c94-4ee8-b631-b4e4b141a603)

<br/>

<br/>

#### 예제5

예제4에서 만든 파일을 읽어서 데이터의 총합을 구하는 예제

```java
import java.io.*;

public class DataInputStreamEx2 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        DataInputStream dis = null;
        int sum = 0;
        int score = 0;
        try {
            fis = new FileInputStream("src/score.dat");
            dis = new DataInputStream(fis);

            while (true) {
                score = dis.readInt();
                System.out.println(score);
                sum += score;
            }
        } catch (EOFException e) {
            System.out.println("점수의 총합은 " + sum + "입니다.");
        } catch (IOException ie) {
            ie.printStackTrace();
        } finally {
            try {
                if (dis != null) {
                    dis.close();
                }
            } catch (IOException ie) {
                ie.printStackTrace();
            }
        }
    }
}
/* 결과
100
90
95
85
50
점수의 총합은 420입니다.
*/
```

- DataInputStream의 `readInt()`와 같이 데이터를 읽는 메서드는 **더 이상 읽을 데이터가 없으면 EOFException을 발생시키기에** 다른 입력스트림들과는 달리 무한반복문과 catch문을 이용해서 데이터를 읽는다.
- 원래 while문으로 작업을 마친 후에 스트림을 닫아 줘야 하는 데, 무한 반복문이기 때문에 finally블록에서 스트림을 닫도록 처리함
- 참조변수 dis가 null일때 `close()`를 호출하면 NullPointerException이 발생하므로 null인지 체크한 후 닫아줘야함
- `close()`는 IOException을 발생시킬 수 있으므로 try-catch블록으로 감싸주었다.

<br/>

<br/>

#### 예제6

지금까지 try블럭 내에서 스트림을 닫아주었지만, 작업도중에 예외가 발생해서 스트림을 닫지 못하고 try블럭을 빠져나갈 수 있기에 finally블럭을 이용해서 닫아주어야 한다. 그런데 코드가 너무 복잡해져서 이때까지 그냥 간단히 try블럭에서 닫았음

JDK1.8부터는 **try-with-resources**문을 이용해서 `close()`를 직접 호출하지 않아도 자동호출되도록 할 수있는데, 이를 사용하면 훨씬 간결해짐

```java
try (자원 선언) {
    // 자원을 사용한 코드
} catch (ExceptionType e) {
    // 예외 처리 코드
}
```

```java
import java.io.*;

public class DataInputStreamEx3 {
    public static void main(String[] args) {
        int sum = 0;
        int score = 0;


        try (FileInputStream fis = new FileInputStream("src/score.dat");
             DataInputStream din = new DataInputStream(fis)) {
            while (true) {
                score = din.readInt();
                System.out.println(score);
                sum += score;
            }

        } catch (EOFException e) {
            System.out.println("점수의 총합은 " + sum + "입니다.");
        } catch (IOException ie) {
            ie.printStackTrace();
        }
    }
}

```

<br/>

<br/>

<br/>

## 3.4 SequenceInputStream

- 여러 개의 입력스트림을 연속적으로 연결해서 하나의 스트림처럼 다룰 수 있게 해준다.

> SequneceInputStream은 다른 보조스트림들과는 달리 InputStream을 바로 상속 받아서 구현함

| 생성자                                                   | 설명                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| SequenceInputStream(Enumeration e)                       | Enumeration에 저장된 순서대로 입력스트림을 하나의 스트림으로 연결한다. |
| SequenceInputStream(InputStream s1,<br />InputStream s2) | 두 개의 입력스트림을 하나로 연결한다.                        |

<br/>

사용 예1

```java
Vector files = new Vector();
files.add(new FileInputStream("file.001"));
files.add(new FileInputStream("file.002"));
SequenceInputStream in = new SequenceInputStream(files.elements());
```

사용 예2

```java
FileInputStream file1 = new FileInputStream("file.001");
FileInputStream file2 = new FileInputStream("file.002");
SequenceInputStream in = new SequnenceInputStream(file1, file2);
```

<br/>

#### 예제

```java
import java.io.*;
import java.util.*;

public class SequenceInputStreamEx {
    public static void main(String[] args) {
        byte[] arr1 = {0, 1, 2};
        byte[] arr2 = {3, 4, 5};
        byte[] arr3 = {6, 7, 8};
        byte[] outSrc = null;

        Vector<InputStream> v = new Vector<>();
        v.add(new ByteArrayInputStream(arr1));
        v.add(new ByteArrayInputStream(arr2));
        v.add(new ByteArrayInputStream(arr3));

        SequenceInputStream input = new SequenceInputStream(v.elements());
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        int data = 0;
        try {
            while ((data = input.read()) != -1) {
                output.write(data);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        outSrc = output.toByteArray();

        // Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8]
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
```

<br/>

<br/>

<br/>

## 3.5 PrintStream

- 데이터를 기반스트림에 다양한 형태의 문자로 출력하는 기능을 제공하는 보조스트림
- 데이터를 적절한 문자로 출력하는 것이기 때문에 문자기반 스트림의 역할을 수행한다.
  - 그래서 JDK1.1에서 부터 PrintStream보다 향상된 기능의 문자 기반 스트림인 PrintWirter가 추가되었지만,  그동안 매우 빈번히 사용되던 System.out이 PrintStream이다 보니 둘 다 사용할 수 밖에 없게 됨
- PrintStream보단 PrintWriter를 사용하는 것을 권장함
- System클래스의 static 멤버  `System.out`, `System.err`이 **PrintStream이다**.

<br/>![Image](https://github.com/user-attachments/assets/0214eccd-a698-4f67-95c1-90d1378526db)

<br/>

print()나 println()을 이용해서 출력하는 중에 PrintStream의 기반스트림에서 IOException이 발생하면 `checkError()`를 통해서 인지 할 수있다. 

println()이나 print()는 매우 자주 사용되기에 예외를 던지지 않고 내부에서 처리하도록 정의했다.

- 만약 println()이 예외를 던지도록 정의되었다면 println()을사용하는 모든 곳에 try-catch문을 사용해야 할 것이다.

<br/>

> |참고| i  +""와 String.valueOf(i)는 결과는 같지만, 성능은 String.valueOf(i)가 더좋다.
>
> >  StringBuilder 인스턴스를 생성해서 문자열을 합치지게 객체가 추가로 생성되므로 메모리 낭비 발생!
> >
> > ```java
> > String s = new StringBuilder().append(String.valueOf(i)).toString();
> > ```
>
> 
>
> > 불필요한 객체 생성 없이 바로 문자열 반환
> >
> > ```java
> > public static String valueOf(int i) {
> >     return Integer.toString(i);
> > }
> > ```

<br/>

```java
public class PrintStream extends FilterOutputStream implements Appendable, Closeable{
    ...
    private boolean trouble = false;
    
    public void print(int i){
        write(String.valueOf(i));	// write(i+""); 와 같다.
    }
    
    private void write(String s){
       try{
           ...
       }catch(IOException x){
           trouble = true;
       }
    }
    ...
    public boolean checkError(){
        if(out!=null) flush();
        return trouble;
    }
}
```

 <br/>

<br/>

### printf()

printf()는 JDK1.5부터 추가된 것으로, 편리한 형식화된 출력을 지원하게 되었다.

### 정수의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/3fc1c297-9f40-4c97-8498-0fa4d42acc7f)

### 문자열의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/b8e46647-1201-4fdc-b351-45f55d03ecf6)

### 실수의 출력에 사용될 수 있는 옵션

`float f = 1234.56789f`

![Image](https://github.com/user-attachments/assets/d2d15dc9-f95a-4a35-95fd-03f1ffa8e33e)

### 특수문자를 출력하는 옵션

![Image](https://github.com/user-attachments/assets/7d88b7cb-4fcd-48f8-b597-69b59e81092c)

### 날짜와 시간의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/4e0ffb52-a9f2-4f92-ba28-57bc7f701b03)

<br/>

```java
public class PrintStreamEx1 {
    public static void main(String[] args) {
       Date d = new Date();

       System.out.printf("지금은 %tH시 %tM분 %tS초입니다.\n",d,d,d);
        System.out.printf("지금은 %1$tH시 %1$tM분 %1$tS초입니다.\n",d);
    }
}

```

위의 두 문장은 같은 결과를 출력하는데, 두 번째 문장의 경우 형식화된 문자열에 사용된 옵션의 개수와 매개변수의 개수가 일치하지 않는 것을 알 수 있다. 

이처럼 `숫자$`를 옵션 앞에 붙여 줌으로써 출력된 매개변수를 지정가능하다. `1$` 라면 첫 번째 매개변수를 의미한다.

<br/>

<br/>

<br/>

<br/>

# 4. 문자기반 스트림

## 4.1 Reader와 Writer

byte배열 대신 char배열을 사용한다는 것 외에는 InputStream/OutputStream의 메서드와 크게 다르지 않다.

### Reader(문자기반 입력스트림의 최고 조상)의 메서드

| 메서드                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| abstract void close()                         | 입력스트림을 닫음으로써 사용하고 있던 자원을 반환한다.       |
| void mark(int readlimit)                      | 현재위치를 표시해놓는다. 후에 reset()에 의해서 표시해 놓은 위치로 다시 돌아갈 수 있다 |
| boolean markSupported()                       | mark()와 reset()을 지원하는지를 알려 준다.                   |
| int read()                                    | 입력소스로부터 하나의 문자를 읽어 온다. char의 범위인 0~65535범위의 정수를 반환하며,<br/>입력스트림의 마지막 데이터에 도달하면, -1을 반환한다. |
| int read(char[] c);                           | 입력소스로부터 매개변수로 주어진 배열 c의 크기만큼 읽어서 배열 c에 저장한다. <br />읽어 온 데이터의 개수 또는 -1을 반환한다 |
| abstract int read(char[] c, int off, int len) | 입력소스로부터 최대 len개의 문자를 읽어서 , 배열 c의 지정된 위치(off)부터 읽은 만큼 저장한다. 읽어 온 데이터의 개수 또는 -1을 반환한다. |
| boolean ready()                               | 입력소스로부터 데이터를 읽을 준비가 되어있는지 알려 준다.    |
| void reset()                                  | 입력소스에서의 위치를 마지막으로 mark()가 호출되었던 위치로 되돌린다. |
| long skip(long n)                             | 현재 위치에서 주어진 문자 수(n)만큼을 건너뛴다.              |

<br/>

### Writer(문자기반 출력스트림의 최고 조상)의 메서드

| 메서드                                                  | 설명                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| abstract void close()                                   | 출력스트림를 닫음으로써 사용하고 있던 자원을 반환한다        |
| abstract void flush()                                   | 스트림의 버퍼에 있는 모든 내용을 출력소스에 쓴다.(버퍼가 있는 스트림에만 해당됨) |
| void write(int b)                                       | 주어진 값을 출력소스에 쓴다.                                 |
| void write(char[] c)                                    | 주어진 배열 c에 저장된 모든 내용을 출력소스에 쓴다.          |
| abstract void write(char[] c, int off, int len)         | 주어진 배열 c에 저장된 내용 중에서 off번째부터 len길이만큼만 출력소스에 쓴다. |
| void write(String str)                                  | 주어진 문자열(str)을 출력소스에 쓴다.                        |
| void write(String str, int off, int len)                | 주어진 문자열(str)의 일부를 출력소스에 쓴다.(off번째 문자부터 len개 만큼의 문자열) |
| Writer append(char c)                                   | 지정된 문자를 출력소스에 추가                                |
| Writer append(CharSequence c)                           | 지정된 문자열(CharSequence)을 출력소스에 추가                |
| Writer append(CharSequence c, <br />int start, int end) | 지정된 문자열(CharSequence)의 일부를 출력소스에 추가<br />(CharBuffer, String, StringBuffer가 CharSequence를 구현) |

<br/>

문자기반 스트림(Reader/Writer 그리고 그 자손들)은 여러 종류의 인코딩과 자바에서 사용하는 유니코드(UTF-16)간의 변환을 자동적으로 처리해준다. 

**Reader는 특정 인코딩을 읽어서 유니코드로 변환하고 Writer는 유니코드를 특정 인코딩으로 변환하여 저장한다.**

<br/>

<br/>

<br/>

## 4.2 FileReader와 FileWriter

문자기반의 파일 입출력, 텍스트 파일의 입출력에 사용한다.

#### 예제1

바이트기반 스트림과 문자기반 스트림 차이점을 보여주기 위한 예제

```java
import java.io.*;

public class FileReaderEx1 {
    public static void main(String[] args) {
        try {
            String fileName = "src/test.txt";
            FileInputStream fis = new FileInputStream(fileName);
            FileReader fr = new FileReader(fileName);
            int data = 0;

            // FileInputStream을 이용해서 파일내용을 읽어 화면에 출력한다.
            while ((data = fis.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
            fis.close();

            // FileReader를 이용해서 파일내용을 읽어 화면에 출력한다.
            while ((data = fr.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
            fr.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**결과**

**FileInputStream**을 사용했을 때는 **한글이 깨져서 출력**되는 것을 알 수있다.

> **바이트(byte) 단위로 읽고, 인코딩 정보를 모름** → 한글 깨짐

```java
Hello, ìëíì¸ì?
Hello, 안녕하세요?
```

<br/>

<br/>

#### 예제2

파일의 공백을 모두 없애는 예제

입력스트림으로부터 읽은 데이터를 변환해서 출력스트림에 쓰는 작업의 예를 보여 주기 위한 것

```java
import java.io.*;

public class FileConversion {
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader("src/input.txt");
            FileWriter fw = new FileWriter("src/result.txt");

            int data = 0;
            while ((data = fr.read()) != -1) {
                if (data != '\t' && data != '\n' && data != ' ' && data != '\r')
                    fw.write(data);
            }
            fr.close();
            fw.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

input.txt

```
안   녕   하
세
요

ㅇㅇㅇ
```

result.txt

```
안녕하세요ㅇㅇㅇ
```

<br/>

<br/>

<br/>

## 4.3 PipedReader와 PipedWriter

- 프로세스(쓰레드)간의 통신(데이터를 주고 받음)에 사용한다.
- 다른 스트림과는 달리 **입력과 출력스트림을 하나의 스트림으로 연결**(connect)해서 **데이터를 주고받는다**.
- 스트림을 생성한 다음 어느 한쪽 쓰레드에서 `connect()`를 호출해서 입력스트림과 출력스트림을 연결한다.
- 입출력을 마친 후에는 어느 한쪽 스트림만 닫아도 나머지 스트림은 자동으로 닫힌다.

#### 예제

두 쓰레드가 PipedReader/PipedWriter를 이용해서 서로 메시지를 주고받는 예제

- 쓰레드를 시작하기전에 PipedReader/PipedWriter를 연결해야함
- StringWriter는 CharArrayWriter처럼 메모리를 사용하는 스트림인데 내부적으로 String Buffer를 가지고 있어서 출력하는 내용이 여기 저장된다.

```java
import java.io.*;

public class PipedReaderWriter {
    public static void main(String[] args) {
        InputThread inThread = new InputThread("InputThread");
        OutputThread outThread = new OutputThread("OutputThread");

        // PipedReader와 PipedWriter를 연결한다.
        inThread.connect(outThread.getOutput());

        inThread.start();
        outThread.start();
    }
}

class InputThread extends Thread {
    PipedReader input = new PipedReader();
    StringWriter sw = new StringWriter();

    InputThread(String name) {
        super(name);    // Thread(String name);
    }

    public void run() {
        try {
            int data = 0;

            while ((data = input.read()) != -1) {
                sw.write(data);
            }
            System.out.println(getName() + " received : " + sw.toString());

        } catch (IOException e) {
        }
    }

    public PipedReader getInput() {
        return input;
    }

    public void connect(PipedWriter output) {
        try {
            input.connect(output);
        } catch (IOException e) {
        }
    }
}

class OutputThread extends Thread {

    PipedWriter output = new PipedWriter();

    OutputThread(String name) {
        super(name);
    }

    public void run() {
        try {
            String msg = "Hello";
            System.out.println(getName() + " sent : " + msg);
            output.write(msg);
            output.close();
        } catch (IOException e) {}
    }

    public PipedWriter getOutput() {
        return output;
    }

    public void connect(PipedReader input) {
        try {
            output.connect(input);
        } catch (IOException e) {}
    }
}
/* 
OutputThread sent : Hello
InputThread received : Hello
*/
```

<br/>

<br/>

<br/>

## 4.4 StringReader와 StringWriter

- CharArrayReader/CharArrayWriter와 같이 **입출력 대상이 메모리인 스트림**
- StringWriter에 출력되는 데이터는 내부의 **StringBuffer에 저장**된다.

```
StringBuffer getBuffer()	StringWriter에 출력한 데이터가 저장된 StringBuffer를 반환한다.
String toString()			StringWriter에 출력된(StringBuffer에 저장된) 문자열을 반환한다.
```

<br/>

#### 예제

```java
import java.io.*;

public class StringReadeerWriterEx {
    public static void main(String[] args) {
        String inputData = "ABCD";
        StringReader input = new StringReader(inputData);
        StringWriter output = new StringWriter();

        int data=0;

        try{
            while((data=input.read())!=-1){
                output.write(data);
            }
            System.out.println("Input Data :"+inputData);
            System.out.println("Output Data :"+output.toString());
            System.out.println("Output Data :"+output.getBuffer().toString());
        }catch (IOException e){}

    }
}
/*
Input Data :ABCD
Output Data :ABCD
Output Data :ABCD
*/
```

