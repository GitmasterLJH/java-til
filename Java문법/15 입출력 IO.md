# Chapter 15 입출력 I/O

# 1. 자바에서의 입출력

## 1.1 입출력이란?

### **I/O** 

- Input(입력)과 Ouput(출력)의 약자

- **컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말함**

<br/>

<br/>

<br/>

## 1.2 스트림(stream)

자바에서 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면(**입출력을 수행하려면**), 두 대상을 연결하고 데이터를 전송할 수 있는 **스트림**(stream)이 필요하다.

> 14장의 스트림과 같은 용어를 쓰지만 다른 개념

<br/>

### 스트림이란?

- **데이터를 운반(입출력)하는데 사용되는 연결 통로**
- 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름이다.
- 먼저 보낸 데이터를 먼저 받게 되어있으며 연속적으로 데이터를 주고 받음
- **단반향통신만 가능**하다(하나의 스트림으로 입력과 출력을 동시에 처리 불가)
- 입출력을 동시에 수행하려면, 2개의 스트림이 필요하다
  - input stream(입력 스트림)
  - output stream(출력 스트림)

![Image](https://github.com/user-attachments/assets/26e7e984-2e6f-4c3a-aa5f-8129826e7417)

<br/>

<br/>

<br/>

## 1.3 바이트기반 스트림 - InputStream, OutputStream

바이트기반 스트림은 데이터를 **바이트**(byte)단위로 주고받는다.

<br/>

### 아래는 여러 종류의 입출력 스트림이다.

| 입력스트림           | 출력스트림            | 입출력 대상의 종류          |
| -------------------- | --------------------- | --------------------------- |
| FileInputStream      | FileOutputStream      | 파일                        |
| ByteArrayInputStream | ByteArrayOutputStream | 메모리(byte 배열)           |
| PipedInputStream     | PipedOutputStream     | 프로세스(프로세스간의 통신) |
| AudioInputStream     | AudioOutputStream     | 옹디오장치                  |

만약 어떤 파일의 내용을 읽고자 하는 경우 FileInputStream을 사용하면 된다.

이들은 모두 InputStream, OutputStream의 자손들이며, 각각 읽고 쓰는데 필요한 추상메서드를 자신에 맞게 구현해 놓음

> 자바에선 java.io패키지를 통해서 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하다.

<br/>

### InputStream과 OutputStream에 정의된 읽기와 쓰기를 수행하는 메서드

| InputStream                          | OutputStream                           |
| ------------------------------------ | -------------------------------------- |
| abstract int read()                  | abstract void write(int b)             |
| int read(byte[] b)                   | void write(byte[] b)                   |
| int read(byte[] b, int off, int len) | void write(byte[] b, int off, int len) |

> read()의 반환타입이 byte가 아니라 int인 이유는 read()의 반환값의 범위가 0~255와 -1이기 때문이다

**InputStream**의 `read()`와 **OutputStream**의 `write(int b)`는 입출력의 대상에 따라 알맞게 구현하라는 의미에서 **추상메서드로 정의되어 있다**. 

추상메서드를 구현안하고 추상메서드가 아닌 다른 메서드 `int read(byte[] b)`, `void write(byte[] b)`를 쓰면 될 것이라고 생각할 수 있지만 사실 **추상메서드**인 `read()`와 `write(int b)`를 이용해서 구현한 것들이여서 **무조건 구현해야함** 

<br/>

<br/>

### InputStream의 실제 소스코드의 일부를 이해하기 쉽게 변형한 버전

```java
public abstract class InputStream{
    ...
        
    // 입력스트림으로 부터 1 byte를 읽어서 반환한다. 읽을 수 없으면 -1을 반환
    abstract int read();
    
    // 입력스트림으로부터 len개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다.
    int read(byte[] b, int off, int len){
        ...
        for(int i=off;i<off+len;i++){
            b[i] = (byte)read();
        }
    }
    ...
        // 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다.
        int read(byte[] b){
        return read(b, 0, b.length);
    }
    ...
}
```

위 코드를 보면 `read(byte[] b)`가 `read(byte[] b, int off, int len)`를 호출하고 `read(byte[] b, int off, int len)`가 추상메서드인 `read()`를 호출하는 것을 알수있다.

**결론적으로 read()는 반드시 구현되어야하는 핵심적인 메서드**

<br/>

<br/>

<br/>

## 1.4 보조 스트림

### 보조스트림

-  스트림의 기능을 향상시키거나 새로운 기능을 추가하기 위해 사용
- 실제 데이터를 주고받는 스트림이 아니기 때문에 **독립적으로 입출력을 수행 못함**

<br/>

**text.txt** 파일을 읽을 때,  입력 성능을 향상시키기 위해 버퍼를 사용하는 **보조스트림인 BufferedInputStream**을 사용하는 코드

```java
// 먼저 기반스트림을 생성한다.
FileInputStream fis = new FileInputStream("test.txt");

// 기반스트림을 이용해서 보조스트림을 생성한다.
BufferdInputStream bis = new BufferedInputStream(fis);
bis.read();	// 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.
```

- 보조스트림이 입력기능을 수행하는 것처럼 보이지만, **실제 입력기능은** BufferedInputStream과 연결된 **FileInputStream**이 수행
- 보조스트림인 BufferedInputStream은 **버퍼만을 제공**한다.
- 실제로 버퍼를 사용한것과 안한 입출력간의 성능차이는 상당하기에 대부분 버퍼를 이용한 보조스트림 사용한다.

<br/>

<br/>

### 바이트 기반 보조스트림의 종류

| 입력                  | 출력                 | 설명                                                         |
| --------------------- | -------------------- | ------------------------------------------------------------ |
| FilterInputStream     | FilterOutputStream   | 필터를 이용한 입출력 처리                                    |
| BufferedInputStream   | BufferedOutputStream | 버퍼를 이용한 입출력 성능향상                                |
| DataInputStream       | DataOutputStream     | int, float와 같은 기본형 단위로 데이터를 처리하는 기능       |
| SequenceInputStream   | 없음                 | 두 개의  스트림을 하나로 연결                                |
| LineNumberInputStream | 없음                 | 읽어 온 데이터의 라인 번호를 카운트<br />(JDK1.1부터 LineNumberReader로 대체) |
| ObjectInputStream     | ObjectOutputStream   | 데이터를 객체단위로 읽고 쓰는데 사용.<br />주로 파일을 이용하며 객체 직렬화와 관련있음 |
| 없음                  | PrintStream          | 버퍼를 이용하며, 추가적인 print관련 기능<br />(print, printf, println메서드) |
| PushbackInputStream   | 없음                 | 버퍼를 이용해서 읽어온 데이터를 다시 되돌리는 기능<br />(unread, push back to buffer) |

모든 보조스트림은 InputStream과 OutputStream의 자손들이므로 입출력방법이 같다.

![Image](https://github.com/user-attachments/assets/d4a3401a-1b72-4894-8432-0966512d1243)

<br/>

<br/>

<br/>

## 1.5 문자기반 스트림 - Reader, Writer

입출력 단위가 **문자**(char, 2byte)인 스트림, 문자기반 스트림의 최고 조상이다.

<br/>

```
InputStream  -------> Reader
OutputStream -------> Writer
```

### 바이트기반 스트림과 문자기반 스트림 비교

| 바이트기반 스트림                                            | 문자기반 스트림                      |
| ------------------------------------------------------------ | ------------------------------------ |
| FileInputStream<br />FileOuputStream                         | FileReader<br />FileWriter           |
| ByteArrayInputStream<br />ByteArrayOuputStream               | CharArrayReader<br />CharArrayWriter |
| PipedInputStream<br />PipedOutputStream                      | PipedReader<br />PipedWriter         |
| StringBufferInputStream(deprecated)<br />StringBufferOutputStream(deprecated) | StringReader<br />StringWriter       |

<br/>

<br/>

### 읽고 쓰는 메서드 비교

| InputStream                                                  | Reader                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract int read()<br/>int read(byte[] b)<br/>int read(byte[] b, int off, int len) | int read()<br/>int read(char[] cbuf)<br/>abstract int read(char[] cbuf, int off, int len) |

| OutputStream                                                 | Writer                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| abstract void write(int b)<br/>void write(byte[] b)<br/>void write(byte[] b, int off, int len) | void write(int c)<br/>void write(char[] cbuf)<br/>abstract void write(char[] cbuf, int off, int len)<br/>void write(String str)<br/>void write(String str, int off, int len) |

<br/>

<br/>

### 보조스트림 비교

| 바이트기반 보조스트림                         | 문자기반 보조스트림                |
| --------------------------------------------- | ---------------------------------- |
| BufferedInputStream<br />BufferedOuputtStream | BufferedReader<br />BufferedWriter |
| FilterInputStream<br />FilterOutputStream     | FilterReader<br />FilterWriter     |
| LineNumberInputStream(deprecated)             | LineNumberReader                   |
| PushbackInputStream                           | PushbackReader                     |

<br/>

<br/>

<br/>

<br/>

# 2. 바이트기반 스트림

## 2.1 InputStream과 OutputStream

![Image](https://github.com/user-attachments/assets/a8b122d2-ee44-451d-98e8-6c9be2c8a6bb)

`flush()`는 버퍼가 있는 출력스트림의 경우에만 의미가 있으며, OutputStream에 정의된 `flush()`는 아무런 일도 하지 않는다.

프로그램이 종료될때, 사용하고 닫지 않은 스트림을 JVM이 자동으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후 에는 `close()`를 호출해서 반드시 닫아줘야 한다.

ByteArrayInputStream과 같이 **메모리를 사용하는 스트림**과 System.in, System.out과 같은 **표준 입출력 스트림**은 닫아 주지 않아도 됨

<br/>

<br/>

<br/>

## 2.2 ByteArrayInputStream과 ByteArrayOutputStream

> 위 클래스는 자주 사용되지는 않음

메모리, 즉 메모리내의 **바이트배열에 데이터를 입출력 하는데 사용하는 스트림**이다.

주로 다른 곳에 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 가비지컬렉터에 의해 자동적으로 자원을 반환하므로 `close()`를 이용해서 **스트림을 닫지 않아도 된다.**

<br/>

<br/>

#### 예제1

`read()`와 `write()`를 사용하는 가장 기본적인 방법을 보여준다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEX1 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = null;
        ByteArrayOutputStream output = null;

        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();

        int data = 0;


        while ((data = input.read()) != -1) {
            output.write(data); // void write(int b)
        }
        outSrc = output.toByteArray();  // 스트림의 내용을 byte배열로 반환한다.

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/* 
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제2

예제1은 `read()`와 `write(int b)`를 사용하기에  한 번에 1byte만 읽고 쓰므로 작업효율이 떨어지기에 배열을 사용하여 입출력 작업이 보다 효율적으로 이루어지도록함

- byte배열과 `int read(byte[] b, int off, int len)` 와 `void write(byte[] b, int off, int len)`를 사용하여 한 번에 배열의 크기만큼 읽고 쓸 수 있게함

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Arrays;

public class IOEX2 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        byte[] temp = new byte[10];

        // input 스트림에서 최대 temp.length만큼 바이트를 읽어 temp 배열의 0번째 인덱스부터 저장
        input.read(temp, 0, temp.length); // 읽어 온 데이터를 배열 temp에 담는다.
        
        // temp 배열의 5번째 인덱스부터 5개의 바이트를 output 스트림에 쓴다.
        output.write(temp, 5, 5); 

        outSrc = output.toByteArray(); //  출력 스트림(output)에 쓰인 데이터들을 outSrc 배열로 복사

        System.out.println("Input Source :" + Arrays.toString(inSrc));
        System.out.println("temp :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
/*
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Output Source :[5, 6, 7, 8, 9]
*/
```

<br/>

<br/>

#### 예제3

`read()`나 `write()`이 **IOException**을 발생시킬 수 있기에 try-catch문으로 감싸줌

`available()`은 스트림으로부터 **blocking없이 읽어 올 수 있는 바이트의 수를 반환**한다.

> 블락킹(blocking)이란 데이터를 읽어 올 때 데이터를 기다리기 위해 멈춰있는 것을 뜻한다.
>
> 예를 들어 사용자가 데이터를 입력하기 전까지 기다리고 있을 때 블락킹 상태에 있다고 한다.

```java
import java.io.*;
import java.util.Arrays;

public class IOEx3 {
    public static void main(String[] args) {
        byte[] inSrc = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        byte[] outSrc = null;
        byte[] temp = new byte[4]; // 이전 예제와 배열의 크기가 다르다.

        ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        System.out.println("Input Source :" + Arrays.toString(inSrc));

        try {
            while (input.available() > 0) {
                input.read(temp);
                output.write(temp);

                outSrc = output.toByteArray();
                printArrays(temp, outSrc);
            }
        } catch (IOException e) {}
    }

    static void printArrays(byte[] temp, byte[] outSrc) {
        System.out.println("temp          :" + Arrays.toString(temp));
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
```

**결과**

```
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6, 7]
```

결과를 보면 예상과 다른데 그 이유는 마지막에 읽은 배열의 9번째와 10번째 요소값인 8과 9만을 출력해야하는데  temp에 남아 있던 6,7까지 출력했기 때문이다. 보다 나은 성능을 위해서 temp에 담긴 내용을 지우고 쓰는 것이 아니라 그냥 기존의 내용 위에 덮어쓴다.

그래서 temp의 내용은 `[4,5,6,7]`에서 8과 9을 읽고 난 후에는 `[8,9,6,7]`이 된다.

원하는 결과를 얻기위해서는 다음과 같이 출력해야함

- `int len = input.read(temp)`은 읽어온 데이터의 개수를 반환하고
- `output.write(temp, 0, len)`은 읽어 온 만큼 write한다.

![Image](https://github.com/user-attachments/assets/2ef4ff87-d0e0-45a6-95ed-09850ce0b162)

```java
Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
temp          :[0, 1, 2, 3]
Output Source :[0, 1, 2, 3]
temp          :[4, 5, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7]
temp          :[8, 9, 6, 7]
Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]		// 올바른 출력이 됨
```

<br/>

<br/>

<br/>

## 2.3 FIleInputStream과 FileOutputStream

파일에 입출력을 하기 위한 스트림

> 자주 사용됨

### FIleInputStream 생성자

| 생성자                                | 설명                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| FileInputStream(String name)          | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileInputStream을 생성한다. |
| FileInputStream(File file)            | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileInputStream(FileDescriptor fdObj) | 파일 디스크립터(fdObj)로 FIleInputStream을 생성한다.         |

### FileOutputStream의 생성자

| 생성자                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| FileOutputStream(String name)                 | 지정된 파일이름(name)을 가진 실제 파일과 연결된 FileOutputStream을 생성한다. |
| FileOutputStream(File file)                   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(String name, boolean append) | 두번째 인자인 append를 true로 하면, 출력 시 기존의 파일의 마지막에 덧붙인다, false면 기존의 파일내용을 덮어쓰게 된다. |
| FileOutputStream(File file, boolean append)   | 파일의 이름이 String이 아닌 File인스턴스로 지정해주어야 한다는 점을 제외하고 위 생성자와 같다. |
| FileOutputStream(FileDescriptor fdObj)        | 파일 디스크립터(fdObj)로 FIleOutputStream을 생성한다.        |

<br/>

<br/>

#### 예제1

커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 간단한 예제.

```java
import java.io.*;

public class FileViewer {
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream(args[0]);	// args[0]에는 이 파일의 경로
        int data = 0;

        /*
        read()의 반환값이 int(4byte) 이긴 하지만, 더 이상 입력값이 없음을 알리는 -1을 제외하고 
        0~255(1byte)범위의 정수값이기 때문에, char형(2byte)로 변환해도 손실되는 값이 없다.
        */
        
        while((data=fis.read())!=-1){
            char c = (char)data;
            System.out.print(c);
        }
    }
}
```

read()가 한 번에 1byte씩 파일로부터 데이터를 읽어 들이긴 하지만, 데이터의 범위가 십진수로 0~255(16진수로는 0x00~0xff)범위의 정수값이고, 또 읽을 수 있는 입력값이 더 이상 없음을 알릴 수 있는 값(-1)도 필요하다. 그래서 다소 크긴 하지만 정수형중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한다.

<br/>

<br/>

#### 예제2

단순히 FileCopy.java의 내용을 `read()`로 읽어서, `write(int b)`로 FileCopy.bak에 출력하는 예제

> 이처럼 텍스트파일을 다루는 경우에는 FileInputStream/FIleOutputStream보다 문자기반의 스트림인 FIleReader/FileWriter를 사용하는 것이 더 좋다.

```java
import java.io.*;


public class FileCopy {
    public static void main(String[] args) {
        try{
            FileInputStream fis = new FileInputStream(args[0]);	// FileCopy.java의 경로
            FileOutputStream fos = new FileOutputStream(args[1]); // FileCopy.bak의 경로

            int data = 0;
            while((data=fis.read())!=-1){
                fos.write(data);
            }
            fis.close();
            fos.close();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
```

> FileOutputStream fos = new FileOutputStream(args[1], true)와 같이 생성자의 두번째 매개변수의 값을 true로 하면 기존 파일의 마지막 내용에 덧붙인다.

![Image](https://github.com/user-attachments/assets/69f915f4-06b3-49aa-bc66-63adba9ef64e)

<br/>

<br/>

<br/>

<br/>

# 3. 바이트기반의 보조스트림

## 3.1 FilterInputStream과 FilterOutputStream

- 모든 바이트기반 보조스트림의 최고조상
- **보조스트림은** 자체적으로 입출력을 수행할 수 없기 때문에 **기반스트림을 필요**로 한다.

<br/>

### FilterInputStream/FilterOutputStream클래스 분석

- FilterInputStream/FilterOutputStream의 모든 메서드는 **단순히 기반스트림의 메서드를 그대로 호출**할 뿐이다.
- 상속을 통해 원하는 작업을 수행하도록 읽고 쓰는 메서드를 오버라이딩 해야함
- FilterInputStream의 생성자는 접근 제어자가 protected이기에 인스턴스를 생성해서 사용할 수 없고 상속을 통해서 오버라이딩되어야 한다.
- FilterOutputStream의 생성자가 protected가 아니라 public인 이유는 출력때 그대로 출력하는 것은 의미가 있기 때문이다.(항등함수)

```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected FilterInputStream(InputStream in) { 
        this.in = in; 
    }
    
    public int read() throws IOEXception{
        return in.read();
    }
    ...
}
  

public class FilterOutputStream extends OutputStream {
    protected OutputStream out;
    
    public FilterOutputStream(OutputStream out) { 
        this.out = out;
    }    
    
    public void write(int b) throws IOException {
        out.write(b);
    }
    ...
}
```

### Volatile

>  각 스레드가 같은 변수에 대해 읽기, 쓰기 동작을 수행할 시 각자의 `CPU 캐시` 에 `메인 메모리` 의 값과 다른 값을 갖고 있을 수 있게 된다.
>
> `volatile` 변수에 값을 쓰면 → 즉시 메인 메모리에 반영됨.
>
> 다른 스레드가 `volatile` 변수를 읽으면 → 항상 메인 메모리에서 최신 값을 읽음.
>
> > 모든 스레드가 항상 같은 공유 변수의 값을 읽어올 수 있도록 보장함 -> 가시성이 보장됨(원자성은 보장x)

<br/>

<br/>

### **FilterInputStream의 자손**

- BufferedInputStream, DataInputStream, PushbackInputStream 등

### **FilterOutputStream의 자손**

- BufferedOutputStream, DataOutputStream, PrintStream 등

<br/>

<br/>

<br/>

## 3.2 BufferedInputStream과 BufferedOutputStream

- 스트림의 입출력 효율을 높이기 위해 버퍼(byte[])를 사용하는 보조스트림

###  BufferedInputStream 생성자

| 생성자                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| BufferedInputStream(InputStream in, int size) | 주어진 InputStream인스턴스를 입력소스(input source)로 하며 지정된 크기(byte단위)의 버퍼를 갖는 BufferedInputStream 인스턴스를 생성한다. |
| BufferedInputStream(InputStream in)           | 주어진 InputStream인스턴스를 입력소스(input source)로 하며 버퍼의 크기를 지정해주지 않으므로 기본적으로 8192byte 크기의 버퍼를 갖게 된다. |

프로그램에서 read메서드를 호출하면, BufferedInputSteram은 입력소스로 부터 버퍼 크기만큼의 데이터를 읽어다 자신의 내부 버퍼에 저장한다. 

이제 프로그램에서는 버퍼에 저장된 데이터를 읽으면 된다. 외부의 입력소스로 부터 읽는 것보다 내부의 버퍼로 부터 읽는 것이 훨씬 빠르기 떄문에 그만큼 작업 효율이 높아진다. 

프로그램에서 버퍼에 저장된 모든 데이터를 다 읽고 그다음 데이터를 읽기 위해 read메서드가 호출되면, BufferdInputStream은 입력소스로부터 다시 버퍼크기 만큼의 데이터를 읽어다 버퍼에 저장해 놓는다. 이와 같은 작업이 반복됨

<br/>

<br/>

### BufferedOutputStream 생성자

| 메서드/생성자                                    | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| BufferedOutputStream(OutputStream out, int size) | 주어진 OutputStream 인스턴스를 출력소스(output source)로 하며 지정된 크기(단위 byte)의 버퍼를 갖는 BufferedOutputStream인스턴스를 생성한다. |
| BufferedOutputStream(OutputStream out)           | 주어진 OutputStream 인스턴스를 출력소스(output source)로 하며 버퍼의 크기를 지정해주지 않으므로 기본적으로 8192 byte 크기의 버퍼를 갖게 된다. |
| flush()                                          | 버퍼의 모든 내용을 출력소스에 출력한 다음, 버퍼를 비운다.    |
| close()                                          | flush()를 호출해서 버퍼의 모든 내용을 출력소스에 출력하고, BufferedOutputStream인스턴스가 사용하던 모든 자원을 반환한다. |

프로그램에서 write메서드를 이용한 출력이 BufferedOutputStream의 버퍼에 저장된다. 버퍼가 가득 차면, 그 때 버퍼의 모든 내용을 출력소스에 출력한다.  그리고는 버퍼를 비우고 다시 프로그램으로부터 출력을 저장할 준비를 한다.

버퍼가 가득 찼을 때만 출력소스에 출력을 하기 떄문에, 마지막 출력부분이 출력소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다. 그래서 프로그램에서 모든 출력작업을 마친 후 BufferedOuptStream에 close()나 flush()를 호출해서 마지막에 버퍼에 있는 모든 내용이 출력소스에 출력되도록 해야 한다.

> BufferedOutputStream인스턴스의 참조변수에 null을 지정함으로써 사용하던 자원들이 반환되게 한다.

<br/>

<br/>

#### 예제

크기가 5인 BufferdOutputStream을 이용해서 파일 123.txt에 1부터 9까지 출력하는 예제

```java
import java.io.*;

public class BufferedOutputStreamEx1 {
    public static void main(String[] args) {
        try{
            FileOutputStream fos = new FileOutputStream("src/123.txt");

            BufferedOutputStream bos = new BufferedOutputStream(fos, 5);
            // 파일에 1부터 9까지 출력한다.
            for(int i='1'; i<='9';i++){
                bos.write(i);
            }
            fos.close();
        }catch (IOException e){e.printStackTrace();}
    }
}
```

**결과**

```
12345
```

1부터 9까지 출력해야되는데 5까지만 출력되어있다. 그 이유는 **버퍼에 남아있는 데이터가 출력되지 못한 상태로 프로그램이 종료**되었기 때문이다.

![Image](https://github.com/user-attachments/assets/f5e99b58-3716-4c8b-b6d9-b03b1494ccc4)

`fos.close()`로 스트림을 닫아주긴 했지만, BufferdOutputStream의 버퍼에 있는 내용이 출력되지 않음

`bos.close()`와 같이해서 보조스트림인 BufferdOutputStream의 `close()`를 호출해 주어야 버퍼에 남아있던 모든 내용이 출력된다.

아래의 코드는 BufferedOutputStream의 조상인 FilterOutputStream의 소스코드이다. BufferdOutputStream은 `close()`를 오버라이딩  없이 그대로 상속받음

```java
public class FilterOutputStream extends OutputStream{
    protected OutputStream out;
    public FilterOutputStream(OutputStream out){
        this.out = out;
    }
    ...
    public void close() throws IOException{
        try{
            flush();	// 버퍼의 모든 내용을 출력소스에 호출 한다음, 버퍼를 비운다.
        } catch(IOException ignored){}
        out.close();	// 기반 스트림의 close()를 호출한다.
    }
}
```

<br/>

<br/>

<br/>

## 3.3 DataInputStream과 DataOutputStream

- **기본 자료형의 단위로 읽고 쓰는 보조스트림**
- DataOutputStream은 기본자료형을 **이진데이터**로 저장한다.
  - int 값 10을 저장하면 **4바이트의 이진 값**이 그대로 기록된다.
    - 이진 데이터를 16진수 형식으로 표현하면 `00 00 00 0A`와 같이 보인다.
- 각 자료형의 크기가 다르므로, 출력한 순서대로 같은 자료형을 사용해 읽어야 한다.

### DataInputStream의 생성자와 메서드

| 메서드/생성자                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DataInputStream(InputStream in)                              | 주어진 InputStream인스턴스를 기반스트림으로 하는<br />DataInputStream인스턴스를 생성한다. |
| boolean readBoolean()<br />byte        readByte()<br />char        readChar()<br />short      readShort()<br />int           readInt()<br />long        readLong()<br />float       readFloat()<br />double   readDouble()<br />int           readUnsignedByte()<br />int           readUnsignedShort() | 각 타입에 맞게 값을 읽어 온다.<br />더 이상 읽을 값이 없으면 EOFException을 발생시킨다. |
| void readFully(byte[] b)<br />void readFully(byte[] b, int off, int len) | 입력스트림에서 지정된 배열의 크기만큼 또는 지정된 위치에서 len만큼 데이터를 <br />읽어온다. 파일의 끝에 도달하면 EOFException을 발생하고, I/O에러가 발생하면 IOException이 발생 |
| String readUTF()                                             | UTF-8형식으로 쓰여진 문자를 읽는다.<br />더 이상 읽을 값이 없으면 EOFException을 발생시킨다. |
| static String readUTF(DataInput in)                          | 입력스트림(in)에서 UTF-8형식의 유니코드를 읽어온다.          |
| int skipBytes(int n)                                         | 현재 읽고 있는 위치에서 지정된 숫자(n) 만큼을 건너뛴다.      |

<br/>

### DataOutputStream의 생성자와 메서드

| 메서드/생성자                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DataOutputStream(OutputStream out)                           | 주어진 OutputStream인스턴스를 기반스트림으로 하는<br />DataOutputStream인스턴스를 생성한다. |
| void writeBoolean(boolean b)<br/>void writeByte(int b)<br/>void writeChar(int c)<br/>void writeShort(int s)<br/>void writelnt(int I)<br/>void writeLong(long I)<br/>void writeFloat(float f)<br/>void writeDouble(double d) | 각 자료형에 알맞은 값들을 출력한다.                          |
| void writeUTF(String s)                                      | UTF형식으로 문자를 출력한다.                                 |
| void writeChars(String s)                                    | 주어진 문자열을 출력한다. writeChar(int c)메서드를 여러번 호출한 결과와 같다. |
| int size()                                                   | 지금까지 DataOutputStream에 쓰여진 byte의 수를 알려준다.     |

<br/>

<br/>

#### 예제1

FileOutputStream을 기반으로 하는 DataOutputStream을 생성한 후, DataOutputStream의 메서들을 이용해서 sample.dat파일에 값들을 출력하는 예제

```java
import java.io.*;

public class DataOutputStreamEx1 {
    public static void main(String[] args) {
        FileOutputStream fos = null;
        DataOutputStream dos = null;

        try{
            fos = new FileOutputStream("src/sample.dat");
            dos = new DataOutputStream(fos);
            dos.writeInt(10);			// int 4바이트 저장 (00 00 00 0A)
            dos.writeFloat(20.0f); 		// float 4바이트 저장 (41 A0 00 00)
            dos.writeBoolean(true);		// boolean 1바이트 저장 (01)

            dos.close();

        }catch (IOException e){e.printStackTrace();}
    }
}
```

출력한 값들은 이진 데이터(binary data)로 저장된다. 파일을 16진수 코드로 볼 수 있는 UltraEdit과 같은 프로그램이나 ByteArrayOutputStream을 사용하면 이진데이터를 확인할 수 있다.

<br/>

<br/>

#### 예제2

```java
import java.io.*;
import java.util.Arrays;

public class DataOutputStreamEx2 {
    public static void main(String[] args) {
        ByteArrayOutputStream bos = null;
        DataOutputStream dos = null;

        byte[] result = null;

        try {
            bos = new ByteArrayOutputStream();
            dos = new DataOutputStream(bos);
            dos.writeInt(10);			// int 4바이트 출력 (00 00 00 0A)
            dos.writeFloat(20.0f);		// float 4바이트 출력 (41 A0 00 00)
            dos.writeBoolean(true);		// boolean 1바이트 출력 (01)


            result = bos.toByteArray();

            String[] hex = new String[result.length];

            for (int i = 0; i < result.length; i++) {
                if (result[i] < 0) {
                    hex[i] = String.format("%02X", result[i] + 256);	// 음수 값을 부호 없는 값으로 변환
                } else {
                    hex[i] = String.format("%02X", result[i]);	// 양수는 그대로 변환
                }
            }
            System.out.println("10진수 :" + Arrays.toString(result)); // [0, 0, 0, 10, 65, -96, 0, 0, 1]
            System.out.println("16진수 : " + Arrays.toString(hex));	// [00, 00, 00, 0A, 41, A0, 00, 00, 01]

            dos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

`writeInt(10)`에 의해서 출력된 값 : 첫 번째 4byte

| 인덱스 | 값 (10진수) | 값 (16진수) |
| ------ | ----------- | ----------- |
| 0      | 0           | 00          |
| 1      | 0           | 00          |
| 2      | 0           | 00          |
| 3      | 10          | 0A          |

`writeFloat(20.0f)`에 의해서 출력된 값 : 두 번째 4byte

| 인덱스 | 값 (10진수) | 값 (16진수) |
| ------ | ----------- | ----------- |
| 4      | 65          | 41          |
| 5      | -96         | A0          |
| 6      | 0           | 00          |
| 7      | 0           | 00          |

`writeBoolean(true)`에 의해서 출력된 값 : 마지막 1byte

| 인덱스 | 값(10진수) | 값(16진수) |
| ------ | ---------- | ---------- |
| 8      | 1          | 01         |

<br/>

### 값이 음수일때 256을 더한 이유

![Image](https://github.com/user-attachments/assets/3f9f9cc1-4020-4443-8362-d6fe47596e03)

부호 비트가 있으면 범위는 -128~127, 부호 비트가 없으면 범위는 0~255가 된다.

결국 같은 데이터지만 자바의 자료형인 byte의 범위가 부호 있는 1byte 정수의 범위인 -128~127이기 때문에 -1로 인식한다는 것이다. 그래서 이 값을 0~255사이의 값으로 변환하려면 256을 더해주어야 한다. 

다음에 `String.format()`을 사용해서 10진 정수를 16진수 정수로 변환하여 출력함

<br/>

<br/>

#### 예제3

예제1을 실행해서 만들어진 sample.dat를 읽어서 화면에 출력하는 예제

- **여러 가지 종류의 자료형으로 출력한 경우 읽을 때는 반드시 순서대로 읽어야한다.**

```java
import java.io.*;

public class DataInputStreamEx1 {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("src/sample.dat");
            DataInputStream dis = new DataInputStream(fis);

            System.out.println(dis.readInt());
            System.out.println(dis.readFloat());
            System.out.println(dis.readBoolean());
            dis.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
/* 결과
10
20.0
true
*/
```

### DataInputStream과 DataOutputStream 사용 장점

#### 1. **데이터 변환 과정이 필요 없음**

- **문자열로 저장하면 → 숫자로 변환해야 함** (`Integer.parseInt("100")` 필요)
- **DataOutputStream을 사용하면 → 그대로 읽을 수 있음** (`readInt()`만 호출하면 됨)
- 변환 과정이 없으므로 **빠르고 간편함**

<br/>

#### 2. **자리수를 따질 필요 없음**

- 문자열 `"100200300"`으로 저장하면 자리수를 구분해야 함
- `writeInt(100); writeInt(200); writeInt(300);` 하면
  **100(4B) → 200(4B) → 300(4B)** 순서로 저장되므로
  `readInt(); readInt(); readInt();` 만 하면 원래 데이터 그대로 읽을 수 있음

<br/>

✅결론

**DataOutputStream / DataInputStream을 사용하면 더 효율적이고 빠르게 데이터를 저장하고 읽을 수 있다!**

<br/>

<br/>

#### 예제4

int형 배열 score의 값들을 DatatOutputStream을 이용해서 score.dat파일에 출력하는 예제

```java
import java.io.*;

public class DataOutputStreamEx3 {
    public static void main(String[] args) {
        int[] score = {100, 90, 95, 85, 50};

        try {
            FileOutputStream fos = new FileOutputStream("src/score.dat");
            DataOutputStream dos = new DataOutputStream(fos);

            for (int i = 0; i < score.length; i++) {
                dos.writeInt(score[i]);
            }
            dos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### sccore.dat의 실제 저장된 내용

int의 크기가 4byte이므로 모두 20byte의 데이터가 저장되어 있다. 밑줄 아래의 숫자는 10진수로 변환한 결과

> 16진수 두자리가 1byte

!![Image](https://github.com/user-attachments/assets/b58a63ef-2c94-4ee8-b631-b4e4b141a603)

<br/>

<br/>

#### 예제5

예제4에서 만든 파일을 읽어서 데이터의 총합을 구하는 예제

```java
import java.io.*;

public class DataInputStreamEx2 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        DataInputStream dis = null;
        int sum = 0;
        int score = 0;
        try {
            fis = new FileInputStream("src/score.dat");
            dis = new DataInputStream(fis);

            while (true) {
                score = dis.readInt();
                System.out.println(score);
                sum += score;
            }
        } catch (EOFException e) {
            System.out.println("점수의 총합은 " + sum + "입니다.");
        } catch (IOException ie) {
            ie.printStackTrace();
        } finally {
            try {
                if (dis != null) {
                    dis.close();
                }
            } catch (IOException ie) {
                ie.printStackTrace();
            }
        }
    }
}
/* 결과
100
90
95
85
50
점수의 총합은 420입니다.
*/
```

- DataInputStream의 `readInt()`와 같이 데이터를 읽는 메서드는 **더 이상 읽을 데이터가 없으면 EOFException을 발생시키기에** 다른 입력스트림들과는 달리 무한반복문과 catch문을 이용해서 데이터를 읽는다.
- 원래 while문으로 작업을 마친 후에 스트림을 닫아 줘야 하는 데, 무한 반복문이기 때문에 finally블록에서 스트림을 닫도록 처리함
- 참조변수 dis가 null일때 `close()`를 호출하면 NullPointerException이 발생하므로 null인지 체크한 후 닫아줘야함
- `close()`는 IOException을 발생시킬 수 있으므로 try-catch블록으로 감싸주었다.

<br/>

<br/>

#### 예제6

지금까지 try블럭 내에서 스트림을 닫아주었지만, 작업도중에 예외가 발생해서 스트림을 닫지 못하고 try블럭을 빠져나갈 수 있기에 finally블럭을 이용해서 닫아주어야 한다. 그런데 코드가 너무 복잡해져서 이때까지 그냥 간단히 try블럭에서 닫았음

JDK1.8부터는 **try-with-resources**문을 이용해서 `close()`를 직접 호출하지 않아도 자동호출되도록 할 수있는데, 이를 사용하면 훨씬 간결해짐

```java
try (자원 선언) {
    // 자원을 사용한 코드
} catch (ExceptionType e) {
    // 예외 처리 코드
}
```

```java
import java.io.*;

public class DataInputStreamEx3 {
    public static void main(String[] args) {
        int sum = 0;
        int score = 0;


        try (FileInputStream fis = new FileInputStream("src/score.dat");
             DataInputStream din = new DataInputStream(fis)) {
            while (true) {
                score = din.readInt();
                System.out.println(score);
                sum += score;
            }

        } catch (EOFException e) {
            System.out.println("점수의 총합은 " + sum + "입니다.");
        } catch (IOException ie) {
            ie.printStackTrace();
        }
    }
}

```

<br/>

<br/>

<br/>

## 3.4 SequenceInputStream

- 여러 개의 입력스트림을 연속적으로 연결해서 하나의 스트림처럼 다룰 수 있게 해준다.

> SequneceInputStream은 다른 보조스트림들과는 달리 InputStream을 바로 상속 받아서 구현함

| 생성자                                                   | 설명                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| SequenceInputStream(Enumeration e)                       | Enumeration에 저장된 순서대로 입력스트림을 하나의 스트림으로 연결한다. |
| SequenceInputStream(InputStream s1,<br />InputStream s2) | 두 개의 입력스트림을 하나로 연결한다.                        |

<br/>

사용 예1

```java
Vector files = new Vector();
files.add(new FileInputStream("file.001"));
files.add(new FileInputStream("file.002"));
SequenceInputStream in = new SequenceInputStream(files.elements());
```

사용 예2

```java
FileInputStream file1 = new FileInputStream("file.001");
FileInputStream file2 = new FileInputStream("file.002");
SequenceInputStream in = new SequnenceInputStream(file1, file2);
```

<br/>

#### 예제

```java
import java.io.*;
import java.util.*;

public class SequenceInputStreamEx {
    public static void main(String[] args) {
        byte[] arr1 = {0, 1, 2};
        byte[] arr2 = {3, 4, 5};
        byte[] arr3 = {6, 7, 8};
        byte[] outSrc = null;

        Vector<InputStream> v = new Vector<>();
        v.add(new ByteArrayInputStream(arr1));
        v.add(new ByteArrayInputStream(arr2));
        v.add(new ByteArrayInputStream(arr3));

        SequenceInputStream input = new SequenceInputStream(v.elements());
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        int data = 0;
        try {
            while ((data = input.read()) != -1) {
                output.write(data);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        outSrc = output.toByteArray();

        // Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8]
        System.out.println("Output Source :" + Arrays.toString(outSrc));
    }
}
```

<br/>

<br/>

<br/>

## 3.5 PrintStream

- 데이터를 기반스트림에 다양한 형태의 문자로 출력하는 기능을 제공하는 보조스트림
- 데이터를 적절한 문자로 출력하는 것이기 때문에 문자기반 스트림의 역할을 수행한다.
  - 그래서 JDK1.1에서 부터 PrintStream보다 향상된 기능의 문자 기반 스트림인 PrintWirter가 추가되었지만,  그동안 매우 빈번히 사용되던 System.out이 PrintStream이다 보니 둘 다 사용할 수 밖에 없게 됨
- PrintStream보단 PrintWriter를 사용하는 것을 권장함
- System클래스의 static 멤버  `System.out`, `System.err`이 **PrintStream이다**.

<br/>![Image](https://github.com/user-attachments/assets/0214eccd-a698-4f67-95c1-90d1378526db)

<br/>

print()나 println()을 이용해서 출력하는 중에 PrintStream의 기반스트림에서 IOException이 발생하면 `checkError()`를 통해서 인지 할 수있다. 

println()이나 print()는 매우 자주 사용되기에 예외를 던지지 않고 내부에서 처리하도록 정의했다.

- 만약 println()이 예외를 던지도록 정의되었다면 println()을사용하는 모든 곳에 try-catch문을 사용해야 할 것이다.

<br/>

> |참고| i  +""와 String.valueOf(i)는 결과는 같지만, 성능은 String.valueOf(i)가 더좋다.
>
> >  StringBuilder 인스턴스를 생성해서 문자열을 합치지게 객체가 추가로 생성되므로 메모리 낭비 발생!
> >
> > ```java
> > String s = new StringBuilder().append(String.valueOf(i)).toString();
> > ```
>
> 
>
> > 불필요한 객체 생성 없이 바로 문자열 반환
> >
> > ```java
> > public static String valueOf(int i) {
> >     return Integer.toString(i);
> > }
> > ```

<br/>

```java
public class PrintStream extends FilterOutputStream implements Appendable, Closeable{
    ...
    private boolean trouble = false;
    
    public void print(int i){
        write(String.valueOf(i));	// write(i+""); 와 같다.
    }
    
    private void write(String s){
       try{
           ...
       }catch(IOException x){
           trouble = true;
       }
    }
    ...
    public boolean checkError(){
        if(out!=null) flush();
        return trouble;
    }
}
```

 <br/>

<br/>

### printf()

printf()는 JDK1.5부터 추가된 것으로, 편리한 형식화된 출력을 지원하게 되었다.

### 정수의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/3fc1c297-9f40-4c97-8498-0fa4d42acc7f)

### 문자열의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/b8e46647-1201-4fdc-b351-45f55d03ecf6)

### 실수의 출력에 사용될 수 있는 옵션

`float f = 1234.56789f`

![Image](https://github.com/user-attachments/assets/d2d15dc9-f95a-4a35-95fd-03f1ffa8e33e)

### 특수문자를 출력하는 옵션

![Image](https://github.com/user-attachments/assets/7d88b7cb-4fcd-48f8-b597-69b59e81092c)

### 날짜와 시간의 출력에 사용될 수 있는 옵션

![Image](https://github.com/user-attachments/assets/4e0ffb52-a9f2-4f92-ba28-57bc7f701b03)

<br/>

```java
public class PrintStreamEx1 {
    public static void main(String[] args) {
       Date d = new Date();

       System.out.printf("지금은 %tH시 %tM분 %tS초입니다.\n",d,d,d);
        System.out.printf("지금은 %1$tH시 %1$tM분 %1$tS초입니다.\n",d);
    }
}

```

위의 두 문장은 같은 결과를 출력하는데, 두 번째 문장의 경우 형식화된 문자열에 사용된 옵션의 개수와 매개변수의 개수가 일치하지 않는 것을 알 수 있다. 

이처럼 `숫자$`를 옵션 앞에 붙여 줌으로써 출력된 매개변수를 지정가능하다. `1$` 라면 첫 번째 매개변수를 의미한다.

<br/>

<br/>

<br/>

<br/>

# 4. 문자기반 스트림

## 4.1 Reader와 Writer

byte배열 대신 char배열을 사용한다는 것 외에는 InputStream/OutputStream의 메서드와 크게 다르지 않다.

### Reader(문자기반 입력스트림의 최고 조상)의 메서드

| 메서드                                        | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| abstract void close()                         | 입력스트림을 닫음으로써 사용하고 있던 자원을 반환한다.       |
| void mark(int readlimit)                      | 현재위치를 표시해놓는다. 후에 reset()에 의해서 표시해 놓은 위치로 다시 돌아갈 수 있다 |
| boolean markSupported()                       | mark()와 reset()을 지원하는지를 알려 준다.                   |
| int read()                                    | 입력소스로부터 하나의 문자를 읽어 온다. char의 범위인 0~65535범위의 정수를 반환하며,<br/>입력스트림의 마지막 데이터에 도달하면, -1을 반환한다. |
| int read(char[] c);                           | 입력소스로부터 매개변수로 주어진 배열 c의 크기만큼 읽어서 배열 c에 저장한다. <br />읽어 온 데이터의 개수 또는 -1을 반환한다 |
| abstract int read(char[] c, int off, int len) | 입력소스로부터 최대 len개의 문자를 읽어서 , 배열 c의 지정된 위치(off)부터 읽은 만큼 저장한다. 읽어 온 데이터의 개수 또는 -1을 반환한다. |
| boolean ready()                               | 입력소스로부터 데이터를 읽을 준비가 되어있는지 알려 준다.    |
| void reset()                                  | 입력소스에서의 위치를 마지막으로 mark()가 호출되었던 위치로 되돌린다. |
| long skip(long n)                             | 현재 위치에서 주어진 문자 수(n)만큼을 건너뛴다.              |

<br/>

### Writer(문자기반 출력스트림의 최고 조상)의 메서드

| 메서드                                                  | 설명                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| abstract void close()                                   | 출력스트림를 닫음으로써 사용하고 있던 자원을 반환한다        |
| abstract void flush()                                   | 스트림의 버퍼에 있는 모든 내용을 출력소스에 쓴다.(버퍼가 있는 스트림에만 해당됨) |
| void write(int b)                                       | 주어진 값을 출력소스에 쓴다.                                 |
| void write(char[] c)                                    | 주어진 배열 c에 저장된 모든 내용을 출력소스에 쓴다.          |
| abstract void write(char[] c, int off, int len)         | 주어진 배열 c에 저장된 내용 중에서 off번째부터 len길이만큼만 출력소스에 쓴다. |
| void write(String str)                                  | 주어진 문자열(str)을 출력소스에 쓴다.                        |
| void write(String str, int off, int len)                | 주어진 문자열(str)의 일부를 출력소스에 쓴다.(off번째 문자부터 len개 만큼의 문자열) |
| Writer append(char c)                                   | 지정된 문자를 출력소스에 추가                                |
| Writer append(CharSequence c)                           | 지정된 문자열(CharSequence)을 출력소스에 추가                |
| Writer append(CharSequence c, <br />int start, int end) | 지정된 문자열(CharSequence)의 일부를 출력소스에 추가<br />(CharBuffer, String, StringBuffer가 CharSequence를 구현) |

<br/>

문자기반 스트림(Reader/Writer 그리고 그 자손들)은 여러 종류의 인코딩과 자바에서 사용하는 유니코드(UTF-16)간의 변환을 자동적으로 처리해준다. 

**Reader는 특정 인코딩을 읽어서 유니코드로 변환하고 Writer는 유니코드를 특정 인코딩으로 변환하여 저장한다.**

<br/>

<br/>

<br/>

## 4.2 FileReader와 FileWriter

문자기반의 파일 입출력, 텍스트 파일의 입출력에 사용한다.

#### 예제1

바이트기반 스트림과 문자기반 스트림 차이점을 보여주기 위한 예제

```java
import java.io.*;

public class FileReaderEx1 {
    public static void main(String[] args) {
        try {
            String fileName = "src/test.txt";
            FileInputStream fis = new FileInputStream(fileName);
            FileReader fr = new FileReader(fileName);
            int data = 0;

            // FileInputStream을 이용해서 파일내용을 읽어 화면에 출력한다.
            while ((data = fis.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
            fis.close();

            // FileReader를 이용해서 파일내용을 읽어 화면에 출력한다.
            while ((data = fr.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
            fr.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**결과**

**FileInputStream**을 사용했을 때는 **한글이 깨져서 출력**되는 것을 알 수있다.

> **바이트(byte) 단위로 읽고, 인코딩 정보를 모름** → 한글 깨짐

```java
Hello, ìëíì¸ì?
Hello, 안녕하세요?
```

<br/>

<br/>

#### 예제2

파일의 공백을 모두 없애는 예제

입력스트림으로부터 읽은 데이터를 변환해서 출력스트림에 쓰는 작업의 예를 보여 주기 위한 것

```java
import java.io.*;

public class FileConversion {
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader("src/input.txt");
            FileWriter fw = new FileWriter("src/result.txt");

            int data = 0;
            while ((data = fr.read()) != -1) {
                if (data != '\t' && data != '\n' && data != ' ' && data != '\r')
                    fw.write(data);
            }
            fr.close();
            fw.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

input.txt

```
안   녕   하
세
요

ㅇㅇㅇ
```

result.txt

```
안녕하세요ㅇㅇㅇ
```

<br/>

<br/>

<br/>

## 4.3 PipedReader와 PipedWriter

- 프로세스(쓰레드)간의 통신(데이터를 주고 받음)에 사용한다.
- 다른 스트림과는 달리 **입력과 출력스트림을 하나의 스트림으로 연결**(connect)해서 **데이터를 주고받는다**.
- 스트림을 생성한 다음 어느 한쪽 쓰레드에서 `connect()`를 호출해서 입력스트림과 출력스트림을 연결한다.
- 입출력을 마친 후에는 어느 한쪽 스트림만 닫아도 나머지 스트림은 자동으로 닫힌다.

#### 예제

두 쓰레드가 PipedReader/PipedWriter를 이용해서 서로 메시지를 주고받는 예제

- 쓰레드를 시작하기전에 PipedReader/PipedWriter를 연결해야함
- StringWriter는 CharArrayWriter처럼 메모리를 사용하는 스트림인데 내부적으로 String Buffer를 가지고 있어서 출력하는 내용이 여기 저장된다.

```java
import java.io.*;

public class PipedReaderWriter {
    public static void main(String[] args) {
        InputThread inThread = new InputThread("InputThread");
        OutputThread outThread = new OutputThread("OutputThread");

        // PipedReader와 PipedWriter를 연결한다.
        inThread.connect(outThread.getOutput());

        inThread.start();
        outThread.start();
    }
}

class InputThread extends Thread {
    PipedReader input = new PipedReader();
    StringWriter sw = new StringWriter();

    InputThread(String name) {
        super(name);    // Thread(String name);
    }

    public void run() {
        try {
            int data = 0;

            while ((data = input.read()) != -1) {
                sw.write(data);
            }
            System.out.println(getName() + " received : " + sw.toString());

        } catch (IOException e) {
        }
    }

    public PipedReader getInput() {
        return input;
    }

    public void connect(PipedWriter output) {
        try {
            input.connect(output);
        } catch (IOException e) {
        }
    }
}

class OutputThread extends Thread {

    PipedWriter output = new PipedWriter();

    OutputThread(String name) {
        super(name);
    }

    public void run() {
        try {
            String msg = "Hello";
            System.out.println(getName() + " sent : " + msg);
            output.write(msg);
            output.close();
        } catch (IOException e) {}
    }

    public PipedWriter getOutput() {
        return output;
    }

    public void connect(PipedReader input) {
        try {
            output.connect(input);
        } catch (IOException e) {}
    }
}
/* 
OutputThread sent : Hello
InputThread received : Hello
*/
```

<br/>

<br/>

<br/>

## 4.4 StringReader와 StringWriter

- CharArrayReader/CharArrayWriter와 같이 **입출력 대상이 메모리인 스트림**
- StringWriter에 출력되는 데이터는 내부의 **StringBuffer에 저장**된다.

```
StringBuffer getBuffer()	StringWriter에 출력한 데이터가 저장된 StringBuffer를 반환한다.
String toString()			StringWriter에 출력된(StringBuffer에 저장된) 문자열을 반환한다.
```

<br/>

#### 예제

```java
import java.io.*;

public class StringReadeerWriterEx {
    public static void main(String[] args) {
        String inputData = "ABCD";
        StringReader input = new StringReader(inputData);
        StringWriter output = new StringWriter();

        int data=0;

        try{
            while((data=input.read())!=-1){
                output.write(data);
            }
            System.out.println("Input Data :"+inputData);
            System.out.println("Output Data :"+output.toString());
            System.out.println("Output Data :"+output.getBuffer().toString());
        }catch (IOException e){}

    }
}
/*
Input Data :ABCD
Output Data :ABCD
Output Data :ABCD
*/
```

<br/>

<br/>

<br/>

<br/>

# 5. 문자기반의 보조스트림

## 5.1 BufferedReader와 BufferedWriter

- 버퍼를 이용해서 입출력의 효율을 높일 수 있도록 하는 보조스트림
- 라인(line)단위의 입출력이 편하다.

### BufferedReader의 메서드

`String readLine()` 

- 파일에서 한 줄씩 읽어오며, 줄 구분자(개행 문자)는 포함하지 않는다.
- 파일의 끝에 도달하면 `null`을 반환한다.

### BufferedWriter의 메서드

`void newLine()` 

- 라인 구분자(개행문자)를 출력한다.

<br/>

#### 예제

BufferedReader의 readLine()을 이용해서 파일을 라인단위로 읽은 다음 indexOf()를 이용해서 `;`를 포함하고 있는지 확인하여 출력하는 예제

```java
import java.io.*;

public class BufferedReaderEx1 {
    public static void main(String[] args) {
        try{
            FileReader fr = new FileReader("src/BufferedReaderEx1.java");
            BufferedReader br = new BufferedReader(fr);

            String line = "";
            for(int i=1; (line = br.readLine())!=null;i++){
                if(line.indexOf(";")!=-1)
                    System.out.println(i+":"+line);
            }
            br.close();
        }catch (IOException e){}
    }
}
```

**결과**

```
1:import java.io.*;
6:            FileReader fr = new FileReader("src/BufferedReaderEx1.java");
7:            BufferedReader br = new BufferedReader(fr);
9:            String line = "";
10:            for(int i=1; (line = br.readLine())!=null;i++){
11:                if(line.indexOf(";")!=-1)
12:                    System.out.println(i+":"+line);
14:            br.close();
```

<br/>

<br/>

<br/>

## 5.2 InputStreamReader와 OutputStreamWriter

- **바이트기반 스트림을 문자기반 스트림으로 연결시켜주는 역할**을 한다.
- 바이트기반 스트림의 데이터를 **지정된 인코딩의 문자데이터로 변환하는 작업**을 수행한다.

> InputStreamReader/OutputStreamWirter는 Reader/Writer의 자손이다.

<br/>

### InputStreamReader의 생성자와 메서드

| 생성자/메서드                                           | 설명                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| InputStreamReader(InputStream in)                       | OS에서 사용하는 기본 인코딩의 문자로 변환하는 InputStreamReader를 생성한다. |
| InputStreamReader(InputStream in,<br />String encoding) | 지정된 인코딩을 사용하는 InputStreamReader를 생성한다.       |
| String getEncoding()                                    | InputStreamReader의 인코딩을 알려준다.                       |

<br/>

### OutputStreamWriter의 생성자와 메서드

| 생성자/메서드                                         | 설명                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| OutputStreamWriter(OutputStream out)                  | OS에서 사용하는 기본 인코딩의 문자로 변환하는 OutputStreamWriter를 생성한다. |
| OutputStreamWriter(OutputStream out, String encoding) | 지정된 인코딩을 사용하는 OutputStreamWriter를 생성한다.      |
| String getEncoding()                                  | OutputStreamWriter의 인코딩을 알려 준다.                     |

<br/>

**한글 윈도우에서 중국어로 작성된 파일을 읽을때:**

- 한글 Windows의 기본 인코딩(MS949)과 중국어 파일 인코딩(예: GB2312)이 다름  
  -> 인코딩 지정 없이 읽으면 **OS의 기본 인코딩을 사용하여 파일의 바이트를 문자로 변환하기에 글자가 깨짐**

**해결 방법:**
파일의 인코딩을 명시적으로 지정  

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream("chinese.txt"), "GB2312");
```

<br/>마찬가지로 OutputStreamWriter를 이용해서 파일에 텍스트 데이터를 저장할 때 생성자 OutputStreamWriter(OutputStream out, String encoding)를 이용해서 인코딩을 지정하지 않으면 OS에서 사용하는 인코딩으로 데이터를 저장할것이다.

<br/>

<br/>

### OS인코딩 종류 알기

시스템 속성에서 `sun.jnu.encoding`의 값을 보면 OS에서 사용하는 인코딩의 종류를 알 수 있다.

```java
Properties prop = System.getProperties();
System.out.println(prop.get("sun.jnu.encoding"));	// MS949
```

<br/>

<br/>

#### 예제

BufferedReader의 readLine()을 이용해서 사용자의 화면입력을 라인단위로 입력받으면 편리하다. 

그래서 BufferedReader와 InputStream인 System.in을 연결하기 위해 InputStreamReader를 사용했다.

> JDK 1.5부터는 Scanner가 추가되어 이와 같은 방식을 간단히 처리가능

```java
import java.io.*;

public class InputStreamReaderEx {
    public static void main(String[] args) {
        String line = "";

        try {
            InputStreamReader isr = new InputStreamReader(System.in);
            BufferedReader br = new BufferedReader(isr);

            System.out.println("사용중인 OS의 인코딩 :" + isr.getEncoding());

            do {
                System.out.print("문장을 입력하세요. 마치시려면 q를 입력하세요.>");
                line = br.readLine();
                System.out.println("입력하신 문장 : " + line);
            } while (!line.equalsIgnoreCase("q"));
            // br.close();  // System.in과 같은 표준입출력은 닫지 않아도됨
            System.out.println("프로그램을 종료합니다.");
        } catch (IOException e) {
        }
    }
}
```

**결과**

```
사용중인 OS의 인코딩 :UTF8
문장을 입력하세요. 마치시려면 q를 입력하세요.>ㅁㄴㅇ
입력하신 문장 : ㅁㄴㅇ
문장을 입력하세요. 마치시려면 q를 입력하세요.>asd
입력하신 문장 : asd
문장을 입력하세요. 마치시려면 q를 입력하세요.>q
입력하신 문장 : q
프로그램을 종료합니다.
```

<br/>

<br/>

<br/>

<br/>

# 6. 표준입출력과 File

## 6.1 표준입출력 - System.in, System.out, System.err

**표준입출력** : 콘솔(console, 도스창)을 통한 데이터 입력과 콘솔로의 데이터 출력을 의미한다.

자바에선 표준 입출력(standard I/O)을 위해 3가지 입출력 스트림을 제공한다.

- 이 들은 자바 어플리케이션의 실행과 동시에 사용할 수 있게 자동적으로 생성됨
  - 개발자가 별도로 스트림을 생성하는 코드를 작성하지 않아도 된다는 뜻

```
System.in	콘솔로부터 데이터를 입력받는데 사용
System.out	콘솔로 데이터를 출력하는데 사용
System.err	콘솔로 데이터를 출력하는데 사용
```

![Image](https://github.com/user-attachments/assets/32446bb3-c3f4-4f98-8ff0-27c44f011f05)

<br/>

### java.lang.System 클래스

in, out, err의 인스턴스 : BufferedInputStream, BufferdOutputStream

```java
public final class System{
    public final static InputStream in = null;
    public final static PrintStream out = null;
    public final static PrintStream err = null;
}
```

<br/>

#### 예제

```java
import java.io.*;

public class StandardIoEx1 {
    public static void main(String[] args) {
        try{
            int input =0;
            
            while((input=System.in.read())!=-1){
                System.out.println("input : "+ input+ ", (char)input :"+(char)input);
            }
        }catch (IOException e){}
    }
}
```

**결과**

사용자의 입력을 받을때, Enter키도 사용자 입력으로 간주되어 매 입력마다 `\n`이 붙기에 이 들을 제거해주어야 해주는 불편함이 있다.

이러한 불편함을 제거하려면, System.in에 BufferedReader를 이용해서 `readLine()`을 통해 라인단위로 데이터를 입력받으면 된다.

```
hello
input : 104, (char)input :h
input : 101, (char)input :e
input : 108, (char)input :l
input : 108, (char)input :l
input : 111, (char)input :o
input : 10, (char)input :

^D

Process finished with exit code 0
```

<br/>

<br/>

<br/>

## 6.2 표준입출력의 대상변경 - setOut(), setErr(), setIn()

초기에는 System.in, System.out, System.err의 **입출력대상이 콘솔화면이지만**, `setIn()`, `setOut()`, `setErr()`를 사용하면 **입출력을 콘솔 이외에 다른 입출력 대상으로 변경하는 것이 가능**하다.

| 메서드                                  | 설명                                            |
| --------------------------------------- | ----------------------------------------------- |
| static void **setOut**(PrintStream out) | System.out의 출력을 지정된 PrintStream으로 변경 |
| static void **setErr**(PrintStream err) | System.err의 출력을 지정한 PrintStream으로 변경 |
| static void **setIn**(InputStream in)   | System.in의 입력을 지정한 InputStream으로 변경  |

> 그러나 JDK1.5부터 Scanner클래스가 제공되면서 System.in으로부터 데이터를 입력받아 작업하는 것이 편해졌다.

<br/>

#### 예제1

System.out, System.err모두 출력대상이 콘솔이기 때문에 같은 결과를 얻음

```java
public class StandardIOEx2 {
    public static void main(String[] args) {
        System.out.println("out : Hello World!");
        System.err.println("err : Hello World!");
    }
}
/*
out : Hello World!
err : Hello World!
*/
```

<br/>

#### 예제2

System.out의 출력소스를 test.txt파일로 변경한 예제

```java
import java.io.*;

public class StandardIOEx3 {
    public static void main(String[] args) {
        PrintStream ps = null;
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream("src/test.txt");
            ps = new PrintStream(fos);
            System.setOut(ps);  // System.out의 출력대상을 test.txt 로변경
        } catch (IOException e) {
            System.err.println("File not found.");
        }
        System.out.println("Hello by System.out");
        System.err.println("Hello by System.err");
    }
}
```

콘솔

```
Hello by System.err
```

test.txt

```
Hello by System.out
```

<br/>

<br/>

### 커맨드라인에서 표준입출력의 대상을 간단히 바꿀 수 있는 방법

`>`사용

- System.out에 출력하는 것은 output.txt에 저장된다.
- 기존에 output.txt파일이 있었다면 기존의 내용은 삭제됨

```
C:\jdk1.8\work\ch15>java StandardIOEx2 > output.txt
err : Hello World!

C:\jdk1.8\work\ch15>type output.txt
out : Hello World!
```

> `>>`를 사용하면 기존 내용의 마지막에 새로운 내용이 추가된다.

<br/>

`<` 사용

- 표준입력을 output.txt로 지정한다.
- 즉, 콘솔이 아닌 output.txt로부터 데이터를 입력받는다.

```j
C:\jdk1.8\work\ch15>java StandardIOEx2 < output.txt
out : Hello World!
out : Hello World!
```

<br/>

<br/>

<br/>

## 6.3 RandomAccessFile

- **하나의 스트림으로 파일에 입출력을 모두 수행할 수 있는 스트림**

- InputStream이나 OutputStream으로부터 상속받지 않고, DataInput, DataOutput인터페이스를 모두 구현했기에 **읽기와 쓰기 모두 가능**하다.

  ![Image](https://github.com/user-attachments/assets/1e222121-bfe9-4d0b-892a-418f1892418c)

  > DataInputStream은 DataInput, DataOutputStream은 DataOutputStream인터페이스를 구현했다.
  >
  > > 이 두 클래스의 기본자료형을 읽고 쓰기 위한 메서드들은 모두 이 2개의 인터페이스에 정의되어있는 것들이다.

- 파일의 **어느 위치에나 읽기/쓰기가 가능**하다.(다른 입출력 클래스들은 입출력소스에 순차적으로 읽기/쓰기를 한다)

  ```
  이것을 가능하게 하기 위해 내부적으로 파일 포인터를 사용하는데, 입출력 시에 작업이 수행되는 곳이 바로 파일 포인터가 위치한 곳이 된다.
  
  파일 포인터의 위치는 제일 첫부분(0부터 시작)이며, 읽기 또는 쓰기를 수행할 때마다 작업이 수행된 다음 위치로 이동하게 된다.
  
  순차적으로 읽기나 쓰기를 한다면, 파일 포인터를 이동시키기 위해 별도의 작업이 필요하지 않지만, 파일의 임의의 위치에 있는 내용에 대해서 작업하고자 한다면, 먼저 파일 포인터를 원하는 위치로 옮긴 다음 작업을 해야한다.
  ```

> 사실 모든 입출력에 사용되는 클래스들은 입출력 시 다음 작업이 이루어질 위치를 저장하고 있는 포인터를 내부적으로 갖고 있다.
>
> 다만 내부적으로만 사용될 수 있기 때문에 **작업자가 포인터의 위치를 마음대로 변경할 수 없다는 것이 RandomAccessFile과 다른 점**

<br/>

<br/>

| 생성자/메서드                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| RandomAccessFile(File file, String mode)<br/>RandomAccessFile(String fileName, String mode) | 주어진 file에 읽기 또는 읽기 쓰기를 하기 위한 RandomAccessFile<br />인스턴스를 생성한다. mode의 값은 `r`, `rw`, `rws`,`rwd`가 지정가능<br />`r` - 파일로부터 읽기(r)만을 수행<br />`rw` - 파일에 읽기(r)와 쓰기(w)<br />`rws`와 `rwd`는 기본적으로 `rw`와 같은데, 출력내용이 파일에<br />지연 없이 바로 쓰이게 한다.<br />`rwd`는 파일 내용만 즉시 반영<br /> `rws`는 파일 내용 + 파일의 메타정보를 즉시 반영 |
| FileChannel getChannel()                                     | 파일의 파일 채널을 반환                                      |
| FileDescriptor getFD()                                       | 파일의 파일 디스크립터를 반환                                |
| long getFilePointer()                                        | 파일 포인터의 위치를 알려 준다.                              |
| long length()                                                | 파일의 크기를 얻을 수 있다.(단위 byte)                       |
| void seek(long pos)                                          | 파일 포인터의 위치를 변경한다. 위치는 파일의 첫 부분부터 <br />pos크기만큼 떨어진 곳이다.(단위 byte) |
| void setLength(long newLength)                               | 파일의 크기를 지정된 길이로 변경한다.(byte단위)              |
| int skipBytes(int n)                                         | 지정된 수만큼의 byte를 건너뛴다.                             |

> `rw` mode로 RandomAccessFile의 인스턴스를 생성할 때, 지정된 파일이 없으면 새로운 파일을 생성

<br/>

<br/>

#### 예제1

파일에 출력작업이 수행되었을 때 파일 포인터의 위치가 어떻게 달라지는지 보여주는 예제

- int가 4byte이기에 `writeInt()` 호출 후 파일 포인터의 위치가 0에서 4로 바뀜
- long이 8byte이기에 `writeLong()` 호출 후 파일 포인터의 위치가 4에서 12로 바뀜

```java
import java.io.*;

public class RandomAccessFileEx1 {
    public static void main(String[] args) {
        try {
            RandomAccessFile raf = new RandomAccessFile("test.dat", "rw");
            System.out.println("파일 포인터의 위치: " + raf.getFilePointer());	// 0
            raf.writeInt(100);
            System.out.println("파일 포인터의 위치: " + raf.getFilePointer());	// 4
            raf.writeLong(100L);
            System.out.println("파일 포인터의 위치: " + raf.getFilePointer());  // 12
        }catch (IOException e){}
    }
}
```

<br/>

<br/>

#### 예제2

int 배열 score에 저장된 데이터를 score2.dat에 저장한 다음, 저장된 내용을 `readInt()`로 읽어서 출력하는 예제

```java
import java.io.*;

public class RandomAccessFileEx2 {
    public static void main(String[] args){

        //            번호, 국어, 영어,  수학
        int [] score = {1, 100,  90,   90,
                        2,  70,  90,  100,
                        3, 100, 100,  100,
                        4,  70,  60,   80,
                        5,  70,  90,  100};

        try{
            RandomAccessFile raf = new RandomAccessFile("score.dat","rw");
            for(int i=0; i<score.length;i++){
                raf.writeInt(score[i]);
            }
            while (true){
                System.out.println(raf.readInt());
            }
        }catch (EOFException e){

        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
```

**결과**

score2.dat파일은 생성되지만 화면에 아무 것도 출력되지 않는다. 

그 이유는 `writeInt()`를 수행하면서 **파일 포인터의 위치가 파일의 마지막으로 이동되었기 때문**이다. 

그다음 `readInt()`를 호출했으므로 파일의 앞부분이 아닌 **마지막부분부터 읽기 시작하기 때문에 아무것도 읽지 못하고 EOFException이 발생**해서 무한 반복문을 벗어나게 된다.

이처럼 RandomAccessFile을 `rw`모드로 생성해서 작업할 때는 이러한 점을 주의해야함

<br/>

#### 해결방법!

`seek(long pos)`를 이용해서 파일포인터의 위치를 다시 처음으로 이동시킨 다음에 `readInt()`를 호출하면됨

```java
raf.seek(0);
while (true){
    System.out.println(raf.readInt());
}
```

<br/>

<br/>

#### 예제3

이전 예제에서 데이터를 저장한 score2.dat파일에서 국어과목의 점수만을 합계를 내는 예제

```java
import java.io.*;

public class RandomAccessFileEx3 {
    public static void main(String[] args) {

        int sum = 0;
        try {
            RandomAccessFile raf = new RandomAccessFile("score.dat", "r");
            raf.seek(4);
            while (true) {
                sum += raf.readInt();
                raf.skipBytes(12);
            }

        } catch (EOFException e) {
            System.out.println(sum);

        } catch (IOException e) {
        }
    }
}
```

다른 버젼

```java
import java.io.*;

public class RandomAccessFileEx4 {
    public static void main(String[] args) {

        int sum = 0;
        try {
            RandomAccessFile raf = new RandomAccessFile("score.dat", "r");
            int i =4;

            while (true) {
                raf.seek(i);
                sum += raf.readInt();
                i+=16;
            }

        } catch (EOFException e) {
            System.out.println(sum);

        } catch (IOException e) {
        }
    }
}
```

<br/><br/><br/>

## 6.4 File

- 파일과 디렉토리를 다루는데  사용되는 클래스

### File의 생성자와 경로와 관련된 메서드

| 생성자/메서드                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| File(String fileName)                                        | 주어진 문자열(fileName)을 이름으로 갖는 파일을 위한 File인스턴스를 생성한다. <br />파일 뿐만 아니라 디렉토리도 같은 방법으로 다룬다.<br/>여기서 fileName은 주로 경로(path)를 포함해서 지정해주지만, <br />파일 이름만 사용해도 되는 데 이 경우 프로그램이 실행되는 위치가 경로(path)로 간주된다. |
| File(String pathName, String fileName)<br />File(File pathName, String fileName) | 파일의 경로와 이름을 따로 분리해서 지정할 수 있도록 한 생성자. <br />이 중 두번째 것은 경로를 문자열이 아닌 File인스턴스인 경우를 위해서 제공된 것이다. |
| File(URL uri)                                                | 지정된 uri로 파일을 생성                                     |
| String getName()                                             | 파일이름을 String으로 반환한다.                              |
| String getPath()                                             | 파일의 경로(path)를 String으로 반환한다.                     |
| String getAbsolutePath()<br />File getAbsoluteFile()         | 파일의 절대경로를 String으로 반환한다.<br/>파일의 절대경로를 File로 반환한다. |
| String getParent()<br />File getParentFile()                 | 파일의 조상 디렉토리를 String으로 반환한다.<br/>파일의 조상 디렉토리를 File로 반환한다. |
| String getCanonicalPath()<br/>File getCanonicalFile()        | 파일의 정규경로를 String으로 반환한다.<br/>파일의 정규경로를 File로 반환한다. |

<br/>

### 경로와 관련된 File의 멤버변수

| 멤버변수                      | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| static String pathSeparator   | OS에서 사용하는 경로(path) 구분자, 원도우 ";",  유닉스 ":"   |
| static char pathSeparatorChar | OS에서 사용하는 경로(path) 구분자.<br/>윈도우에서는 ';',  유닉스 ':' |
| static String separator       | OS에서 사용하는 이름 구분자. 윈도우 "\\", 유닉스 "/"         |
| static char separatorChar     | OS에서 사용하는 이름 구분자. 원도우 '\\', 유닉스 '/'         |

파일의 경로(path)와 디렉토리나 파일의 이름을 구분하는데 사용 되는 구분자가 OS마다 다를 수 있기 때문에 OS독립적으로 프로그램을 작성하기 위해서는 반드시 위의 멤버변수들을 이용해야한다. 

만일 윈도우에서 사용하는 구분자를 코드에 직접 적어 놓았다면, 이 코드는 다른 OS에서는 오류를 일으킬 수 있다.

<br/>

<br/>

#### 예제

File인스턴스를 생성하고 메서드를 이용해서 파일의 경로와 구분자 등의 정보를 출력하는 예제

```java
import java.io.*;

public class FileEx1 {
    public static void main(String[] args) throws IOException {
        File f = new File("C:\\Users\\dlwls\\Desktop\\Java Code\\Chapter15\\src\\FileEx1.java");
        String fileName = f.getName();
        int pos = fileName.lastIndexOf(".");

        System.out.println("경로를 제외한 파일이름 - "+f.getName());	// FileEx1.java
        System.out.println("확장자를 제외한 파일이름 - "+fileName.substring(0,pos));	// FileEx1
        System.out.println("확장자 - "+fileName.substring(pos+1));	// java

        // C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx1.java
        System.out.println("경로를 포함한 파일이름 - "+f.getPath());
        
        // C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx1.java
        System.out.println("파일의 절대경로 - "+f.getAbsolutePath());
        
        // C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx1.java
        System.out.println("파일의 정규경로 - "+f.getCanonicalPath());
        
        //  C:\Users\dlwls\Desktop\Java Code\Chapter15\src
        System.out.println("파일이 속해 있는 디렉토리 - "+f.getParent());
        System.out.println();
        
        System.out.println("File.pathSepartor - "+File.pathSeparator);	// ;
        System.out.println("File.pathSeparatorChar - "+File.pathSeparatorChar);	// ;
        System.out.println("File.separator - "+File.separator);			// \
        System.out.println("File.separatorChar - "+File.separatorChar);	// \
        System.out.println();
        
        // C:\Users\dlwls\Desktop\Java Code\Chapter15
        System.out.println("user.dir="+System.getProperty("user.dir"));

    }
}
```

**절대경로**(absolute path) : 파일시스템의 root부터 시작하는 파일의 전체 경로

- 하나의 파일에 대해 둘 이상의 절대 경로가 존재할 수 있다.(현재 디렉토리를 의미하는 `.`와 같은 기호나 링크를 포함하고 있는경우)
- `C:\jdk1.8\work\ch15\FileEx1.java`, `C:\jdk1.8\work\ch15\.\FileEx1.java` 가 있다.

<br/>

**정규경로**(canonical path) : 기호나 링크 등을 포함하지 않는 유일한 경로

- `C:\jdk1.8\work\ch15\FileEx1.java` 단 하나

<br/>

`System.getProperty("user.dir")`

- 현재 프로그램이 실행중인 디렉토리를 알 수 있다.

<br/>

**생성자를 사용해서 File인스턴스를 생성하는 다양한 방법**

```java
File f = new File("C:\\Users\\dlwls\\Desktop\\Java Code\\Chapter15\\src\\FileEx1.java");

File f = new File("C:\\Users\\dlwls\\Desktop\\Java Code\\Chapter15\\src", "FileEx1.java");

File dir = new File("C:\\Users\\dlwls\\Desktop\\Java Code\\Chapter15\\src");
File f = new File(dir, "FileEx1.java");
```

<br/>

File인스턴스를 생성했다고 해서 파일이나 디렉토리가 생성되는 것은 아니다. 파일,디렉토리명으로 지정된 문자열이 유효하지 않더라도 컴파일 에러나 예외가 발생하지 않음

새로운 파일을 생성하기 위해서는 File인스턴스를 생성한 다음, **출력스트림을 생성하거나** `createNewFile()`을 호출해야한다.

```java
// 기존에 없는 파일을 새로 생성할 때 :
File f = new File("C:\\Users\\dlwls\\Desktop\\Java Code\\Chapter15\\src", "NewFile.java");
f.createNewFile();	// 새로운 파일이 생성됨
```

<br/>

<br/>

### File의 메서드

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean canRead()                                            | 읽을 수 있는 파일인지 검사한다.                              |
| boolean canWrite()                                           | 쓸 수 있는 파일인지 검사한다.                                |
| boolean canExecute()                                         | 실행할 수 있는 파일인지 검사한다.                            |
| int compareTo(File pathname)                                 | 주어진 파일 또는 디렉토리를 비교한다.<br />같으면 0, 다르면 1 또는 -1을 반환<br />(Unix시스템에서는 대소문자 구별, Windows에서는 구별 X) |
| boolean exists()                                             | 파일이 존재하는지 검사한다.                                  |
| boolean isAbsolute()                                         | 파일 또는 디렉토리가 절대경로명으로 지정되었는지 확인한다.   |
| boolean isDirectory()                                        | 디렉토리인지 확인한다.                                       |
| boolean isFile()                                             | 파일인지 확인한다.                                           |
| boolean isHidden()                                           | 파일의 속성이 '숨김(Hidden)'인지 확인한다. <br />또한 파일이 존재하지 않으면 false를 반환한다. |
| boolean createNewFile()                                      | 아무런 내용이 없는 새로운 파일을 생성한다.(파일이 이미 존재하면 생성되지 않는다.) |
| static File createTempFile(String prefix, String suffix)     | 임시파일을 시스템의 임시 디렉토리에 생성한다.<br/>`System.out.println(File.createTempFile("work", ".tmp"));`<br />결과 : `C:\windows\TEMP\work14247.tmp` |
| static File createTempFile(String prefix, String suffix, File directory) | 임시파일을 시스템의 지정된 디렉토리에 생성한다.              |
| boolean delete()                                             | 파일을 삭제한다.                                             |
| void deleteOnExit()                                          | 응용 프로그램 종료시 파일을 삭제한다. <br />주로 실행 시 작업에 사용된 임시파일을 삭제하는데 사용된다 |
| boolean equals(Object obj)                                   | 주어진 객체(주로 File인스턴스)가 같은 파일인지 비교한다.<br/>(Unix시스템에서는 대소문자를 구별하며, Windows에서는 구별하지 않는다.) |
| long lastModified()                                          | 파일의 마지막으로 수정된 시간을 밀리초 단위의 `long` 값으로 반환 |
| long length()                                                | 파일의 크기를 반환한다.                                      |
| String[] list()                                              | 디렉토리의 파일목록(디렉토리 포함)을 String배열로 반환한다.  |
| String [] list(FilenameFilter filter)                        | FilenameFilter인스턴스에 구현된 조건에 맞는 파일을 String배열로 반환한다 |
| File[] listFiles()<br />File[] listFiles(FileFilter filter)<br />File[] listFiles(FilenameFilter f) | 디렉토리의 파일목록(디렉토리 포함)을 File배열로 반환한다.<br />(filter가 지정된 경우에는 filter의 조건과 일치하는 파일만 반환) |
| static File[] listRoots()<br />long getFreeSpace()<br />long getTotalSpace()<br />long getUsableSpace() | 컴퓨터의 파일시스템의 root의 목록(floppy, CD-ROM, HDD drive)을 반환(예: A:\\, C:\\, D:\\)<br />get으로 시작하는 메서드들은 File이 root일 때, 비어있는 공간, 전체공간, 사용가능한 공간을 byte단위로 반환 |
| boolean mkdir()<br />boolean mkdirs()                        | 파일에 지정된 경로로 디렉토리(폴더)를 생성. 성공하면 true<br />mkdirs는 필요하면 부모 디렉토리까지 생성 |
| boolean renameTo(File dest)                                  | 지정된 파일(dest)로 이름을 변경                              |
| **boolean setExcecutable**(boolean executable)<br />**boolean setExcecutable**(boolean executable, boolean ownerOnly)<br />**boolean setReadable**(boolean readable)<br />**boolean setReadable**(boolean readable, boolean ownerOnly)<br />**boolean setReadOnly**()<br />**boolean setWritable**(boolean writable)<br />**boolean setWritable**(boolean writable, boolean ownerOnly) | 파일의 속성을 변경한다.<br />OwnerOnly가 true면, 파일의 소유자만 해당 속성을 변경할 수 있다. |
| boolean setLastModified(long t)                              | 파일의 마지막으로 수정된 시간을 지정된 시간(t)으로 변경      |
| Path toPath()                                                | 파일을 Path로 변환해서 반환                                  |
| URI toURI()                                                  | 파일을 URI로 변환해서 반환                                   |

<br/>

<br/>

#### 예제2

지정한 디렉토리(폴더)에 포함된 파일과 디렉토리의 목록을 보여주는 예제

```java
import java.io.*;

public class FileEx2 {
    public static void main(String[] args) {
        if(args.length !=1){
            System.out.println("USAGE : java FileEx2 DIRECTORY");
            System.exit(0);
        }

        File f = new File(args[0]); // "C:/Users/dlwls/Desktop/Java Code/Chapter15"
    
        if(!f.exists() || !f.isDirectory()){
            System.out.println("유효하지 않은 디렉토리입니다.");
            System.exit(0);
        }
        File[] files = f.listFiles();	// 디렉토리 안의 파일뿐만 아니라, 폴더(디렉토리)도 포함하여 File배열로 반환

        for(int i=0; i< files.length;i++){
            String fileName = files[i].getName();
            System.out.println(files[i].isDirectory() ? "["+fileName+"]" : fileName);
        }
    }
}
```

결과

```
.gitignore
[.idea]
Chapter15.iml
[out]
score.dat
[src]
test.dat
```

<br/>

<br/>

#### 예제3

이전 에제를 발전시켜 서브디렉토리와 그에 퐆함된 파일과 디렉토리의 목록까지 보여주도록함

```java
import java.io.*;
import java.util.ArrayList;

public class FileEx3 {
    static int totalFiles = 0;
    static int totalDirs = 0;

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("USAGE : java FileEx3 DIRECTORY");
            System.exit(0);
        }

        File dir = new File(args[0]); // C:\Users\dlwls\Desktop\Java Code\Chapter15

        if (!dir.exists() || !dir.isDirectory()) {
            System.out.println("유효하지 않은 디렉토리입니다.");
            System.exit(0);
        }

        printFileList(dir);

        System.out.println();
        System.out.println("총 " + totalFiles + "개의 파일");
        System.out.println("총 " + totalDirs + "개의 디렉토리");
    }

    public static void printFileList(File dir) {
        System.out.println(dir.getAbsoluteFile() + "디렉토리");
        File[] files = dir.listFiles();

        ArrayList<Integer> subDir = new ArrayList<>();	//  디렉토리(폴더)의 인덱스를 저장

        for (int i = 0; i < files.length; i++) {
            String filename = files[i].getName();

            if (files[i].isDirectory()) {
                filename = "[" + filename + "]";
                subDir.add(i);
            }
            System.out.println(filename);
        }

        int dirNum = subDir.size();
        int fileNum = files.length - dirNum;

        totalFiles += fileNum;
        totalDirs += dirNum;

        System.out.println(fileNum + "개의 파일, "+dirNum +"개의 디렉토리");
        System.out.println();

        for(int i=0; i< subDir.size();i++){
            int index = subDir.get(i);
            printFileList(files[index]);
        }
    }
}
```

결과

```
C:\Users\dlwls\Desktop\Java Code\Chapter15디렉토리
.gitignore
[.idea]
Chapter15.iml
[out]
score.dat
[src]
test.dat
4개의 파일, 3개의 디렉토리

C:\Users\dlwls\Desktop\Java Code\Chapter15\.idea디렉토리
.gitignore
misc.xml
modules.xml
workspace.xml
4개의 파일, 0개의 디렉토리

C:\Users\dlwls\Desktop\Java Code\Chapter15\out디렉토리
[production]
0개의 파일, 1개의 디렉토리

C:\Users\dlwls\Desktop\Java Code\Chapter15\out\production디렉토리
[Chapter15]
0개의 파일, 1개의 디렉토리

C:\Users\dlwls\Desktop\Java Code\Chapter15\out\production\Chapter15디렉토리
123.txt
BufferedOutputStreamEx1.class
BufferedReaderEx1.class
DataInputStreamEx1.class
DataInputStreamEx2.class
DataInputStreamEx3.class
DataOutputStreamEx1.class
DataOutputStreamEx2.class
DataOutputStreamEx3.class
FileConversion.class
FileCopy.bak
FileCopy.class
FileEx1.class
FileEx2.class
FileEx3.class
FileReaderEx1.class
FileViewer.class
input.txt
InputStreamReaderEx.class
InputThread.class
IOEX1.class
IOEX2.class
IOEx3.class
OutputThread.class
PipedReaderWriter.class
PrintStreamEx1.class
RandomAccessFileEx1.class
RandomAccessFileEx2.class
RandomAccessFileEx3.class
RandomAccessFileEx4.class
result.txt
sample.dat
score.dat
SequenceInputStreamEx.class
StandardIoEx1.class
StandardIOEx2.class
StandardIOEx3.class
StringReadeerWriterEx.class
test.txt
39개의 파일, 0개의 디렉토리

C:\Users\dlwls\Desktop\Java Code\Chapter15\src디렉토리
123.txt
BufferedOutputStreamEx1.java
BufferedReaderEx1.java
DataInputStreamEx1.java
DataInputStreamEx2.java
DataInputStreamEx3.java
DataOutputStreamEx1.java
DataOutputStreamEx2.java
DataOutputStreamEx3.java
FileConversion.java
FileCopy.bak
FileCopy.java
FileEx1.java
FileEx2.java
FileEx3.java
FileReaderEx1.java
FileViewer.java
input.txt
InputStreamReaderEx.java
IOEX1.java
IOEX2.java
IOEx3.java
PipedReaderWriter.java
PrintStreamEx1.java
RandomAccessFileEx1.java
RandomAccessFileEx2.java
RandomAccessFileEx3.java
RandomAccessFileEx4.java
result.txt
sample.dat
score.dat
SequenceInputStreamEx.java
StandardIoEx1.java
StandardIOEx2.java
StandardIOEx3.java
StringReadeerWriterEx.java
test.txt
37개의 파일, 0개의 디렉토리


총 84개의 파일
총 5개의 디렉토리
```

<br/>

<br/>

#### 예제4

현재 디렉토리에 속한 파일과 디렉토리의 이름과 크기 등 상세정보를 보여주는 예제

```java
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class FileEx4 {
    public static void main(String[] args) {
        String currDir = System.getProperty("user.dir");
        File dir = new File(currDir);

        File[] files = dir.listFiles();

        for (int i = 0; i < files.length; i++) {
            File f = files[i];
            String name = f.getName();
            SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mma");
            String attribute = "";
            String size = "";

            if (files[i].isDirectory()) {
                attribute = "DIR";
            } else {
                size = f.length() + ""; // 파일의 크기를 반환
                attribute = f.canRead() ? "R" : " ";
                attribute += f.canWrite() ? "W" : " ";
                attribute += f.isHidden() ? "H" : " ";
            }
            System.out.printf("%s %3s %6s %s\n", 
                              df.format(new Date(f.lastModified())), attribute, size, name);
        }
    }
}

```

**결과**

```
2025-02-06 20:44오후 RW     344 .gitignore
2025-02-09 03:14오전 DIR        .idea
2025-02-06 20:44오후 RW     433 Chapter15.iml
2025-02-06 20:44오후 DIR        out
2025-02-08 23:58오후 RW      80 score.dat
2025-02-09 03:17오전 DIR        src
2025-02-08 23:51오후 RW      12 test.dat
```

<br/>

<br/>

#### 예제5

이전의 파일의 속성을 보여주는 예제에 정렬기능을 추가한 예제이다.

시간, 파일 크기, 이름으로 오름차순 또는 내림차순으로 파일목록을 정렬하여 볼 수 있다.

```java
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;


public class FileEx5 {
    public static void main(String[] args) {
        if (args.length != 1 || args[0].length() != 1 || "tTlLnN".indexOf(args[0]) == -1) {
            System.out.println("USAGE : java FileEx5 SORT_OPTION ");
            System.out.println("SORT_OPTION :");
            System.out.println("t  Time ascending sort");
            System.out.println("T  Time descending sort");
            System.out.println("l  Length ascending sort");
            System.out.println("L  Length descending sort");
            System.out.println("n  Name ascending sort");
            System.out.println("N  Name descending sort");
            System.exit(0);
        }
        final char option = args[0].charAt(0);

        String currDir = System.getProperty("user.dir");
        File dir = new File(currDir);
        File[] files = dir.listFiles();

        Comparator comp = new Comparator() { // 정렬기준 설정
            @Override
            public int compare(Object o1, Object o2) {
                long time1 = ((File) o1).lastModified();
                long time2 = ((File) o2).lastModified();

                long length1 = ((File) o1).length();
                long length2 = ((File) o2).length();

                String name1 = ((File) o1).getName().toLowerCase();
                String name2 = ((File) o2).getName().toLowerCase();

                int result = 0;
                switch (option) {
                    case 't':
                        if (time1 - time2 > 0) result = 1;
                        else if (time1 - time2 == 0) result = 0;
                        else if (time1 - time2 < 0) result = -1;
                        break;
                    case 'T':
                        if (time1 - time2 > 0) result = -1;
                        else if (time1 - time2 == 0) result = 0;
                        else if (time1 - time2 < 0) result = 1;
                        break;
                    case 'l':
                        if (length1 - length2 > 0) result = 1;
                        else if (length1 - length2 == 0) result = 0;
                        else if (length1 - length2 < 0) result = -1;
                        break;
                    case 'L':
                        if (length1 - length2 > 0) result = -1;
                        else if (length1 - length2 == 0) result = 0;
                        else if (length1 - length2 < 0) result = 1;
                        break;
                    case 'n':
                        result = name1.compareTo(name2);
                        break;
                    case 'N':
                        result = name2.compareTo(name1);
                        break;
                }
                return result;
            }// compare
            public boolean equals(Object o){return false;} // not used.
        };
        Arrays.sort(files,comp);

        for(int i=0; i<files.length;i++){
            File f= files[i];
            String name = f.getName();
            SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm");
            String attribute = "";
            String size ="";

            if(files[i].isDirectory()){
                attribute = "DIR";
            }else {
                size = f.length() +"";
                attribute = f.canRead() ? "R" : " ";
                attribute += f.canWrite() ? "W" : " ";
                attribute += f.isHidden() ? "H" : " ";
            }
            System.out.printf("%s %3s %6s %s\n", 
                              df.format(new Date(f.lastModified())), attribute, size,name);
        }

    }
}
```

**결과**

```
USAGE : java FileEx5 SORT_OPTION 
SORT_OPTION :
t  Time ascending sort
T  Time descending sort
l  Length ascending sort
L  Length descending sort
n  Name ascending sort
N  Name descending sort

T를 입력했을때
2025-02-09 03:59 DIR        src
2025-02-09 03:59 DIR        .idea
2025-02-08 23:58 RW      80 score.dat
2025-02-08 23:51 RW      12 test.dat
2025-02-06 20:44 DIR        out
2025-02-06 20:44 RW     433 Chapter15.iml
2025-02-06 20:44 RW     344 .gitignore
```

<br/>

<br/>

#### 예제6

재귀호출을 이용해서 지정한 디렉토리와 서브디렉토리가 포함된 확장자가 `java`, `txt`, `bak`인 모든 파일의 내용을 읽어서 지정한 키워드가 포함된 라인을 출력하는 예제

파일의 내용을 라인단위로 읽기 위해서 BufferedReader의 `readLine()`을 이용함

```java
import java.io.*;

public class FileEx6 {
    static int found = 0;

    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println("USAGE : javva FileEx6 DIRECTORY KEYWORD");
            System.exit(0);
        }

        File dir = new File(args[0]);
        String keyword = args[1];

        if (!dir.exists() || !dir.isDirectory()) {
            System.out.println("유효하지 않은 디렉토리입니다.");
            System.exit(0);
        }
        try {
            findInFiles(dir, keyword);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println();
        System.out.println("총 " + found + "개의 라인에서 '" + keyword + "'을/를 발견하였습니다. ");
    }

    public static void findInFiles(File dir, String keyword) throws IOException {
        File[] files = dir.listFiles();  

        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {	// 디렉토리면, 재귀호출
                findInFiles(files[i], keyword);
            } else { // 파일인 경우
                String filename = files[i].getName(); // 파일의 이름
                String extension = filename.substring(filename.lastIndexOf(".") + 1); // 파일의 확장자
                extension = "," + extension + ","; 
                
                // 지원하지 않는 확장자(java, txt, bak가 아닌 경우)의 파일은 읽거나 검색하지 않음.
                if (",java,txt,bak,".indexOf(extension) == -1) continue;	

                
                /* 파일의 절대경로(C:\Users\dlwls\Desktop\Java Code\Chapter15\src) + 
                 File.separator(\) + filename(FileEx2.java)
                 */
                filename = dir.getAbsolutePath() + File.separator + filename; 

                FileReader fr = new FileReader(files[i]); 
                BufferedReader br = new BufferedReader(fr);

                String data = "";
                int lineNum = 0;
                while ((data = br.readLine()) != null) { // 파일의 내용을 한 줄씩 읽음
                    lineNum++;

                    if (data.indexOf(keyword) != -1) { // 현재 줄에 keyword가 포함되어 있으면 실행
                        found++;
                        System.out.println("[" + filename + "(" + lineNum + ")" + "]" + data);
                    }
                }
                br.close();

            }
        }
    }
}
```

**결과**

```
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx2.java(8)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx2.java(15)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx3.java(11)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx3.java(18)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx5.java(17)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx6.java(9)]            System.exit(0);
[C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileEx6.java(17)]            System.exit(0);

총 7개의 라인에서 'exit'을/를 발견하였습니다. 
```

<br/>

```java
extension = "," + extension + ","; 
if (",java,txt,bak,".indexOf(extension) == -1) continue;
```

구분자를 `,`로 하여 확장자를 붙여서 문자열을 만든 다음,` indexOf()`로 이 문자열에 확장자가 포함되었는지 확인하고 없으면 넘어가도록 되어 있다. 

확장자의 뒤쪽이나 앞쪽에만 구분자를 붙이면 확장자가 `ava`와 같이 부분적으로 일치하는 경우 문제가 생김

<br/>

<br/>

#### 예제7

FilenameFilter를 구현해서 `String[] list(FilenameFilter filter)`와 함께 사용해서 특정 조건에 맞는 파일의 목록을 얻는 에제

```java
@FunctionalInterface
public interface FilenameFilter {
    boolean accept(File dir, String name);
}
```

```java
import java.io.*;

public class FileEx7 {
    public static void main(String[] args) {
        if(args.length!=1){
            System.out.println("USAGE : java FileEx7 pattern");
            System.exit(0);
        }
        String currDir = System.getProperty("user.dir") +"/src";

        File dir = new File(currDir);
        final String pattern = args[0];

        // String[] list (FilenameFilter filter)
        String[] files = dir.list( (dir1, name) -> {
            return name.contains(pattern);});

        /*
        String[] files = dir.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.indexOf(pattern)!=-1;
            }
        });
        */
        
        for(int i=0;i<files.length;i++){
            System.out.println(files[i]);
        }
    }
}
/*
FileEx1.java
FileEx2.java
FileEx3.java
FileEx4.java
FileEx5.java
FileEx6.java
FileEx7.java
RandomAccessFileEx1.java
RandomAccessFileEx2.java
RandomAccessFileEx3.java
RandomAccessFileEx4.java
*/
```

<br/>

<br/>

#### 예제8

재귀 호출을 이용해서 지정된 디렉토리와 하위 디렉토리에 있는 파일 중에서 지정된 확장자를 가진 파일을 `delete()`를 호출해서 삭제하는 예제. `delete()`는 해당 파일을 삭제하는데 성공하면 true 실패하면 false 반환

```java
import java.io.*;

public class FileEx8 {
    static int deletedFiles = 0;

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("USAGE : java FileEx8 Extension");
            System.exit(0);
        }
        
       // C:\Users\dlwls\Desktop\Java Code\Chapter15\out\production\Chapter15
        String curDir = System.getProperty("user.dir");

        File dir = new File(curDir);
        String ext = "." + args[0]; // .bak

        delete(dir, ext);
        System.out.println(deletedFiles + "개의 파일이 삭제되었습니다.");
    }

    public static void delete(File dir, String ext) {
        File[] files = dir.listFiles();

        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {
                delete(files[i], ext);
            } else {
                String filename = files[i].getAbsolutePath();

                if (filename.endsWith(ext)) {
                    System.out.println(filename);
                    if (files[i].delete()) {
                        System.out.println("- 삭제 성공");
                        deletedFiles++;
                    } else {
                        System.out.println("- 삭제 실패");
                    }
                }
            }
        }
    }
}
```

**결과**

```
C:\Users\dlwls\Desktop\Java Code\Chapter15\out\production\Chapter15\FileCopy.bak
- 삭제 성공
C:\Users\dlwls\Desktop\Java Code\Chapter15\src\FileCopy.bak
- 삭제 성공
2개의 파일이 삭제되었습니다.
```

<br/><br/>

#### 예제9

`renameTo(File f)`를 이용해서 파일의 이름을 바꾸는 예제 

파일이름이 `1.jpg`, `2.jpg`와 같이 숫자로 되어 있는 경우, 파일이름으로 정렬을 하면 `1.jpg` 다음에 `11.jpg`가 오기 때문에 이것을 바로잡기 위해 파일이름 앞에 `0000`을 붙여서 `00001.jpg`다음에 `00002.jpg`가 오게 함

```java
import java.io.*;

public class FileEx9 {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java FileEx9 DIRECTORY");
            System.exit(0);
        }
        File dir = new File(args[0]);

        if (!dir.exists() || !dir.isDirectory()) {
            System.out.println("유효하지 않은 디렉토리입니다.");
            System.exit(0);
        }
        File[] list = dir.listFiles();
        for (int i = 0; i < list.length; i++) {
            String fileNmae = list[i].getName(); 	// 1.jpg
            //파일명
            String newFileName = "0000" + fileNmae;	// 00001.jpg
            
            // 파일 이름에서 7자만큼 잘라내기 위해 시작할 위치를 나타냄
            newFileName = newFileName.substring(newFileName.length()-7); // 001.jpg
            list[i].renameTo(new File(dir, newFileName));
        }
    }
}
```

<br/>

<br/>

#### 예제10

지정한 파일을 지정한 크기로 잘라서 여러 개의 파일로 만드는 예제

매번 데이터를 읽을 때마다 `i` 값이 증가하며, `i % VOLUME == 0` 조건을 만족하면 **새로운 파일을 생성**

즉, **지정된 크기(`VOLUME`)**만큼 데이터를 읽으면 새로운 출력 파일을 만들고, 이전 파일을 닫고 새 파일을 열어서 기록을 시작한다.

```java
import java.io.*;

public class FileSplit {
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: java FileSplit filename SIZE_KB");
            System.exit(0);
        }
        final int VOLUME = Integer.parseInt(args[1]) * 1000; // KB -> B

        try {
            String filename = args[0];
            FileInputStream fis = new FileInputStream(filename);
            BufferedInputStream bis = new BufferedInputStream(fis);

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;

            int data = 0;	// 파일에서 읽은 데이터를 저장하는 변수
            int i = 0;		// 읽은 데이터의 총 크기(바이트 수)를 추적하는 변수
            int number = 0; // 생성된 출력 파일의 번호

            while ((data = bis.read()) != -1) {
                if (i % VOLUME == 0) {	// 분할 크기마다 새 파일 생성
                    if (i != 0) {
                        bos.close();	// 이전 출력 스트림을 닫고 새로운 출력 스트림을 생성
                    }
                    fos = new FileOutputStream(filename + "_." + ++number);
                    bos = new BufferedOutputStream(fos);
                }
                bos.write(data);		// // 한 바이트씩 새로운 파일에 기록
                i++;	// 읽은 바이트 수 추적
            }
            bis.close();
            bos.close();
        } catch (IOException e) {
        }
    }
}
```

**결과**

```
2025-02-09 오후 11:09			5,000 temp.dat
2025-02-09 오후 11:10			1,000 temp.dat_.1
2025-02-09 오후 11:10			1,000 temp.dat_.2
2025-02-09 오후 11:10			1,000 temp.dat_.3
2025-02-09 오후 11:10			1,000 temp.dat_.4
2025-02-09 오후 11:10			1,000 temp.dat_.5
```

<br/>
<br/>

#### 예제11

이전 예제에서 나눈 파일을 다시 합치는 예제

- 임시파일이 생성되는 곳을 지정하지 않으면, 시스템 속성인 `java.io.tmpdir`에 지정된 디렉토리가 된다.

```java
import java.io.*;

public class FileMerge {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java FileMerge filename");
            System.exit(0);
        }

        String mergeFilename = args[0]; // temp.dat

        try {
            // C:\Users\dlwls\AppData\Local\Temp\~mergetemp1419022901622814702.tmp
            File tempFile = File.createTempFile("~mergetemp", ".tmp");
            tempFile.deleteOnExit(); // 프로그램 종료 시 이 임시 파일을 자동으로 삭제

            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tempFile));

            BufferedInputStream bis = null;

            int number = 1;
            File f = new File(mergeFilename + "_." + number);

            while (f.exists()) {
                f.setReadOnly();    // 작업중에 파일의 내용이 변경되지 않도록한다.
                bis = new BufferedInputStream(new FileInputStream(f));

                int data = 0;
                while ((data = bis.read()) != -1) {
                    bos.write(data);
                }
                f = new File(mergeFilename + "_." + ++number);
            }
            bos.close();
            
            // 작업을 마치고 나면 기존 파일 삭제하고 임시파일의 이름을 기존 파일의 이름으로 변경한다.
            File oldFile = new File(mergeFilename); // temp.dat
            if (oldFile.exists())
                oldFile.delete();
            tempFile.renameTo(oldFile); 
           /*
            renameTo가 실패하여 임시 파일의 이름이 바뀌지 않는다면,
            JVM 종료 시 deleteOnExit()에 의해 임시 파일이 삭제될 것
            */
            
        } catch (IOException e) {
        }
    }
}
```
<br/>
<br/>
<br/>
<br/>
