# Chapter 12 지네릭스, 열거형, 애너테이션

## 1.1 지네릭스(Generics)란?

지네릭스는 **객체의 타입을 컴파일 시에 체크**(compile-time type check) 해주는 기능이다. (JDK1.5부터 도입)

- 객체의 타입 안정성을 높이고 형변환의 번거러움이 줄어듦
- 타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다는 뜻

```
지네릭스 장점
	1. 타입 안정성을 제공한다.
	2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
```

<br/>
<br/>
<br/>

## 1.2 지네릭 클래스의 선언

```java
class Box{
    Object item;
    
    void setItem(Object item) {this.item = item;}
    Object getItem() {return item;}
}
```

위 Box 클래스를 아래와 같이 지네릭 클래스로 바꿀 수 있음

```java
class Box<T>{	// 지네릭 타입 T를 선언
	T item;
    
    void setItem(T item) {this.item = item;}
    T getItem()	{return item;}
}
```

<br/>

Box클래스의 객체를 생성할 때는 다음과 같이 하면됨

```java
Box<String> b = new Box<String>();	// 타입 T 대신, 실제 타입 지정
b.setItem(new Object());	// 에러. String이외의 타입은 지정불가
b.setItem("ABC");	// OK
String item = b.getItem();	// (String)b.getItem()처럼 형 변환 할 필요가 없음
```

<br/>
<br/>
지네릭이 도입되기전 이전의 코드와 호환을 위해, 지네릭 클래스이지만 예전의 방식대로 객체를 생성하는 것이 허용됨

다만 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고가 발생

> 만약 타입변수 T에 Object타입을 지정하면, 타입을 지정하지 않은 것이 되므로 경고 발생 x

```java
Box b = new Box();	// OK. T는 Object로 간주
b.setItem("ABC");	// 경고. unchecked or unsafe operation
b.setItem(new Ojbect());	// 경고. unchecked or unsafe operation
```

<br/><br/>

### 지네릭스 용어

```java
class Box<T>{}
```

```
Box<T> 지네릭 클래스. T의 Box 또는 T Box 라고 읽는다.
T 	   타입 변수 또는 타입 매개변수(T는 타입 문자)
Box	   원시 타입(raw type)
```

<br/>

```java
Box<String> b = new Box<String>();
```

위 와 같이 타입 매개변수에 타입을 지정하는 것을 **지네릭타입 호출**이라고 한다.

지정된 타입 String을 **매개변수화된 타입**(parameterized type)이라고 한다.

> 용어가 길기에 대입된 타입이라는 용어를 사용할 것이다.

<br/>

<br/>

### 지네릭스 제한

지네릭 클래스 Box의 객체를 생성할때, 객체별로 다른 타입을 지정하는 것은 적절하다. 

지네릭스는 이처럼 인스턴스별로 다르게 동작하도록 하려고 만든 기능이니

```java
Box<Apple> appleBox = new Box<Apple>();	// OK. Apple 객체만 저장가능
Box<Grape> grapeBox	= new Box<Grape>();	// OK. Grape 객체만 저장가능
```

<br/>

그러나 모든 객체에 동일하게 동작해야하는 **static멤버에 타입 변수 T를 사용할 수 없다**.

 T는 **인스턴스를 생성할 때** 구체적인 타입으로 결정됨

static 멤버는 매개변수화된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다. 

즉, `Box<Apple>.item`과 `Box<Grape>.item`이 달라선 안됨

```java
class Box<T>{
    static T item; // 에러
    static int compare(T t1, T t2){} // 에러
}
```

<br/>

<br/>

#### 지네릭 타입의 배열(객체)을 생성하는 것도 허용 x

왜냐하면 new 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. 그런데 `Box<T>`클래스를 컴파일하는 시점에는 T가 어떤 타입이 될지 전혀 알 수없다. instanceof연산자도 같은 이유로 T를 피연산자로 사용할 수없다.

```java
class Box<T>{
    T[] itemArr;	// OK. T타입의 배열을 위한 참조변수는 가능
    
    T[] toArray(){
        T[] tmpArr = new T[itemArr.length];	// 에러. 지네릭 배열 생성 불가. 
        return tmp Arr;
    }
}
```

만약 꼭 지네릭 배열을 생성해야된다면 new 연산자재신 Reflection API의 newInstance()와 같이 동적으로 객체를  생성하는 메서드로 배열을 생성하거나, Object 배열을 생성해서 복사한 다음에 T[]로 형변환하는 방법을 이용

<br/>

<br/>

<br/>

## 1.3 지네릭 클래스의 객체 생성과 사용

```java
class Box<T>{
    ArrayList<T> list = new ArrayList<T>();
    
    void add(T item)	{list.add(item);}
    T get(int i)	{return list.get(i);}
    ArrayList<T> getList()	{return list;}
    int size()	{return list.size();}
    public String toString() {return list.toString();}
}
```

`Box<T>`의 객체를 생성할 때는 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다.

```java
Box<Apple> appleBox = new Box<Apple>();	// ok
Box<Apple> appleBox = new Box<Grape>()	// 에러
```

<br/>

두 타입이 상속관계에 있어도 마찬가지이다. Apple이 Friut의 자손일때

```java
Box<Fruit> appleBox = new Box<Apple>();	// 에러, 대입된 타입이 다르다.
```

<br/>

단, 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다. FriutBox는 Box의 자손일때

```java
Box<Apple> appleBox = new FriutBox<Apple>();	// OK. 다형성
```

<br/>

JDK1.7부터 추정이 가능한 경우 타입을 생략할 수 있다.

```java
Box<Apple> appleBox = new Box<>();	// OK
```

<br/>

생성된 `Box<T>`의 객체에 `void add(T item)`으로 객체를 추가할 때, 대입된 타입과 다른 타입의 객체는 추가할 수 없다.

```java
Box<Apple> appleBox = new Box<>();
appleBox.add(new Apple());	// OK
appleBox.add(new Grape());	// 에러. Box<Apple>에는 Apple객체만 추가기능
```

<br/>

타입 T가 Fruit인 경우 `void add(Fruit item)`가 되므로 Fruit의 자손들은  이 메서드의 매개변수가 될 수있다.

```java
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());	// OK
fruitBox.add(new Apple());	// OK
```

<br/>

<br/>

<br/>

## 1.4 제한된 지네릭 클래스

지금까지 타입 문자로 사용할 타입을 명시하면 한 종류의 타입만 저장할 수 있도록 제한할 수 있는 것을 알았다. 

그래도 여전히 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없다.

```java
FruitBox<Toy> fruitBox = new FruitBox<Toy>();
fruitBox.add(new Toy());	// OK. 과일상자에 장난감을 담을 수있다.
```

<br/>

하지만 나는FruitBox에 장난감이 아니라 Fruit클래스의 자손들만 담고 싶다.

이때 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하는 방법은 다음과 같다.

다음과 같이 지네릭 타입에 **extends**를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한 가능하다.

```java
class FruitBox<T extends Fruit>{	// Fruit의 자손만 타입으로 지정가능
    ArrayList<T> list = new ArrayList<T>();
    ...
}
```

<br/>

여전히  한 종류의 타입만 담을 수 있지만, Fruit클래스의 자손들만 담을 수 있다는 제한이 추가됨

```java
FruitBox<Apple> appleBox = new FruitBox<Apple>();	// OK
FruitBox<Toy> toyBox = new FruitBox<Toy>();	// 에러. Toy는 Fruit의 자손이 아님
```

<br/>

만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하면 이때도 **extends**를 사용

```java
interface Eatable {}
class FruitBox<T extends Eatable>{...}
```

<br/>

클래스 Fruit의 자손이면서 Eatable인터페이스도 구현해야한다면 다음과 같이 `&`기호로 연결

```java
// Fruit의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입가능
class FruitBox<T extends Fruit & Eatable>{...}
```

<br/>

<br/>

<br/>

## 1.5 와일드 카드(wildcard)

매개변수에 과일박스를 대입하면 주스를 만들어서 반환하는 Juicer클래스

```java
class Juicer{
    static Juice makeJuice(FruitBox<Fruit> box){	// <Fruit>로 지정
        String tmp = "";
        for(Fruit f : box.getList())
            tmp += f + " ";
        return new Juice(tmp);
    }
}
```

`Juicer` 클래스는 지네릭 클래스가 아니며, 설령 지네릭 클래스라고 하더라도 정적 메서드에는 타입 매개변수 `T`를 사용할 수 없다. 

따라서 아예 지네릭스를 적용하지 않던가, 위와 같이 타입 매개변수 대신, 특정 타입(Fruit)을 지정해줘야 한다.

<br/>

### 문제점

`makeJuice()` 메서드는 `FruitBox<Fruit>` 타입만 매개변수로 받을 수 있기 때문에, 다음과 같은 코드에서 문제가 발생한다.

```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
	...
System.out.println(Juicer.makeJuice(fruitBox));	// OK. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox));	// 에러. FruitBox<Apple>
```

`FruitBox<Apple>` 타입은 `FruitBox<Fruit>`와 호환되지 않으므로 컴파일 오류가 발생한다. 

이를 해결하기 위해 `makeJuice()` 메서드를 여러 개 정의할 수도 있지만, 지네릭 타입만 다른 메서드 오버로딩은 허용되지 않는다.

```java
class Juicer{
    static Juice makeJuice(FruitBox<Fruit> box){	// <Fruit>로 지정
        String tmp = "";
        for(Fruit f : box.getList())
            tmp += f + " ";
        return new Juice(tmp);
    }
    
    static Juice makeJuice(FruitBox<Apple> box){	// <Apple>로 지정
        String tmp = "";
        for(Fruit f : box.getList())
            tmp += f + " ";
        return new Juice(tmp);
    }
}
```

위 코드는 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기에 컴파일 에러가 발생한다.

지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거허버린다. 그래서 위의 두 메서드는 오버로딩이 아니라 메서드 중복 정의이다.

<br/>

### 해결책: 와일드 카드

와일드 카드(`?`)를 사용하면 이러한 문제를 해결할 수 있다. 와일드 카드는 어떠한 타입이라도 대입할 수 있도록 허용하며, `extends`와 `super` 키워드를 통해 제한을 줄 수 있습니다.

<br/>

#### 와일드 카드의 종류

- `<? extends T>`: 상한 제한(upper bound). `T`와 그 자손들만 허용.
- `<? super T>`: 하한 제한(lower bound). `T`와 그 조상들만 허용.
- `<?>`: 제한 없음. 모든 타입 허용. (`<? extends Object>`와 동일)

<br/>

#### 수정된 `makeJuice()`메서드

와일드 카드를 사용하면 다음과 같이 수정할 수 있다.

```java
static Juice makeJuice(FruitBox<? extends Fruit> box){	// <Fruit>로 지정
        String tmp = "";
        for(Fruit f : box.getList())
            tmp += f + " ";
        return new Juice(tmp);
    }
```

이제 `FruitBox<Fruit>`뿐만 아니라 `FruitBox<Apple>`이나 `FruitBox<Grape>`도 매개변수로 사용할 수 있다.

```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
	...
System.out.println(Juicer.makeJuice(fruitBox));	// OK. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox));	// OK. FruitBox<Apple>
```

<br/>

#### <? extends Object>

매개변수의 타입을 `FruitBox<? extends Object>`로 하면, 모든 종류의 FruitBox가 이 메서드의 매개변수로 가능해진다.

대신, 전과 달리 box의 요소가 Fruit의 자손이라는 보장이 없으므로 아래의 for문에서 box에 저장된 요소를 Fruit타입의 참조변수로 못받는다.

```java
static Juice makeJuice(FruitBox<? extends Object> box){
    String tmp = "";
    
    for(Fruit f : box.getList())
        tmp += f + " ";	// 에러. Fruit이 아닐 수 있음
    return new Juice(tmp);
}
```

그러나 실제로 테스트 해보면 문제없이 컴파일되는데 그 이유는 지네릭 클래스 FruitBox를 제한했기 때문이다.

```java
class FruitBox<T extends Fruit>	extends Box<T>
```

컴파일러는 위 문장으로부터 모든 FruitBox의 요소들이 Fruit의 자손임을 알고 있으므로 문제 삼지 않는것이다.

<br/>

<br/>

#### 예제1

```java
package FruitBoxEx3;

import java.util.ArrayList;
class Fruit               { public String toString() { return "Fruit"; }}
class Apple extends Fruit { public String toString() { return "Apple"; }}
class Grape extends Fruit { public String toString() { return "Grape"; }}

class Box<T>{
    ArrayList<T> list = new ArrayList<>();
    void add(T item)    {list.add(item);}
    T get(int i)    {return list.get(i);}
    ArrayList<T> getList() {return list;}
    int size()  {return list.size();}
    public String toString()  {return list.toString();};
}
class FruitBox<T extends Fruit> extends Box<T>{}

class Juice{
    String name;
    Juice(String name) { this.name = name + "Juice"; }
    public String toString() { return name; }
}
class Juicer{
    static Juice makeJuice(FruitBox<? extends Fruit> box){
        String tmp = "";
        for(Fruit f : box.getList()){
            tmp += f + " ";
        }
        return new Juice(tmp);
    }
}

public class FruitBoxEx3 {
    public static void main(String[] args) {
        FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
        FruitBox<Apple> appleBox = new FruitBox<Apple>();

        fruitBox.add(new Apple());
        fruitBox.add(new Grape());
        appleBox.add(new Apple());
        appleBox.add(new Apple());

        System.out.println(Juicer.makeJuice(fruitBox));		// Apple Grape Juice
	
        System.out.println(Juicer.makeJuice(appleBox));		// Apple Apple Juice
    }

}
```

<br/>

<br/>

#### 예제2

```java
package FruitBoxEx4;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

class Fruit{
    String name;
    int weight;

    Fruit(String name, int weight){
        this.name = name;
        this.weight = weight;
    }
    public String toString(){ return name+"("+weight+")"; }
}
class Apple extends Fruit{
    Apple(String name, int weight){
        super(name, weight);
    }
}
class Grape extends Fruit{
    Grape(String name, int weight){
        super(name, weight);
    }
}
class AppleComp implements Comparator<Apple> {
    public int compare(Apple t1, Apple t2) {
        return t2.weight - t1.weight;
    }
}
class GrapeComp implements Comparator<Grape>{
    public int compare(Grape t1, Grape t2) {
        return t2.weight - t1.weight;
    }
}
class FruitComp implements Comparator<Fruit>{
    public int compare(Fruit t1, Fruit t2) {
        return t1.weight - t2.weight;
    }
}

public class FruitBoxEx4 {
    public static void main(String[] args) {
        FruitBox<Apple> appleBox = new FruitBox<Apple>();
        FruitBox<Grape> grapeBox = new FruitBox<Grape>();

        appleBox.add(new Apple("GreenApple",300));
        appleBox.add(new Apple("GreenApple",100));
        appleBox.add(new Apple("GreenApple",200));

        grapeBox.add(new Grape("GreenGrape",400));
        grapeBox.add(new Grape("GreenGrape",300));
        grapeBox.add(new Grape("GreenGrape",200));

        Collections.sort(appleBox.getList(),new AppleComp());
        Collections.sort(grapeBox.getList(),new GrapeComp());
        System.out.println(appleBox);	// [GreenApple(300), GreenApple(200), GreenApple(100)]
        System.out.println(grapeBox);	// [GreenGrape(400), GreenGrape(300), GreenGrape(200)]
        
        Collections.sort(appleBox.getList(), new FruitComp());
        Collections.sort(grapeBox.getList(), new FruitComp());
        System.out.println(appleBox);	// [GreenApple(100), GreenApple(200), GreenApple(300)]
        System.out.println(grapeBox);	// [GreenGrape(200), GreenGrape(300), GreenGrape(400)]
    }
}

class Box<T>{
    ArrayList<T> list = new ArrayList<>();
    void add(T item)    {list.add(item);}
    T get(int i)    {return list.get(i);}
    ArrayList<T> getList() {return list;}
    int size()  {return list.size();}
    public String toString()  {return list.toString();};
}
class FruitBox<T extends Fruit> extends Box<T>{}
```

<br/>

#### Collections.sort()

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

`<T>`는 메서드에 선언된 지네릭 타입이다. 이런 메서드를 지네릭 메서드라고 한다. 

<br/>

Comparator의 지네릭 타입에 하한 제한이 걸려있는 와일드 카드가 사용되었는데 만약 와일드 카드가 없다고 가정해보자

```java
static <T> void sort(List<T> list, Comparator<T> c)
```

<br/>

위 상태에서 타입 매개변수 T에 Apple이 대입되면 아래와 같이 될 것이다.

```java
static void sort(List<Apple> list, Comparator<Apple> c)
```

이것은 `List<Apple>`을 정렬하기 위해서는 `Comparator<Apple>`이 필요하다는 것을 의미한다.

그래서 `Comparator<Apple>`을 구현한 클래스를 정의하면 다음과 같이된다.

```java
class AppleComp implements Comparator<Apple>{
    public int compare(Apple t1, Apple t2){
        return t2.weight - t1.weight;
    }
}
```

<br/>

하지만 Apple대신 Grape이 대입된다면 `List<Grape>`을 정렬하기 위해 `Comparator<Grape>`이 필요하다.

```java
class GrapeComp implements Comparator<Grape>{
    public int compare(Grape t1, Grape t2){
        return t2.weight - t1.weight;
    }
}
```

**문제점**

1. AppleComp와 타입만 다를 뿐 완전히 같은 코드이다. 즉, 코드의 중복이 생김
2. Fruit의 자손이 생길 때마다 위와 같은 코드를 작성해야함

<br/>

**해결 방법**

타입 매개변수에 하한 제한의 와일드 카드를 적용하면 된다. 앞서 sort()는 원래 그러고 정의 되어있음

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

T에 Apple이 대입되면 다음과 같이 된다.

```java
static void sort(List<Apple> list, Comparator<? super Apple> c)
```

<br/>

매개변수의 타입이 `Comparartor<? super Apple>`의 의미는 Comparator의 타입 매개변수로 Apple과 그 조상이 가능하다는 뜻이다.

```
Comparator<? super Apple> : Comparator<Apple>, Comparator<Fruit>, Comparator<Object>

Comparator<? super Grape> : Comparator<Grape>, Comparator<Fruit>, Comparator<Object>
```

<br/>

그래서 FruitComp를 만들면, `List<Apple>`과 `List<Grape>` 모두를 정렬 할 수 있다.

비교의 대상이 되는 weight는 Apple과 Grape의 조상인 Fruit에 정의되어 있기때문에 가능한 것이기도 함

```java
class FruitComp implements Comparator<Fruit>{
    public int compare(Fruit t1, Fruit t2){
        return t1.weight - t2.weight;
    }
}

// List<Apple>과 List<Grape>를 모두 Comparator<Fruit>로 정렬
Collections.sort(appleBox.getList(), new FruitComp());
Collections.sort(grapeBox.getList(), new FruitComp());
```

<br/>

<br/>

<br/>

## 1.6 지네릭 메서드

메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라 한다. 지네릭 타입의 선언 위치는 반환 타입 바로 앞

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

<br/>

지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다.

즉, 지네릭 클래스 FruitBox에 선언된 T와 지네릭 메서드 sort()에 선언된 T는 타입 문자만 같을 뿐 서로 다른 것이다.

또한 static 멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다.

> 메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 됨

```java
class FruitBox<T>{
	...
	static <T> void sort(List<T> list, Comparator<? super T> c)
    ...
}
```

<br/>

<br/>

```java
static Juice makeJuice(FruitBox<? extends Fruit> box){
	String tmp = "";
    for(Fruit f : box.getList())
        tmp += f + " ";
    return new Juice(tmp);
}

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
	...
System.out.println(Juicer.makeJuice(fruitBox));
System.out.println(Juicer.makeJuice(appleBox));
```

위 makeJuice를 지네릭 메서드로 바꾸면 다음과 같다.

```java
static <T extends Fruit> Juice makeJuice(FruitBox <T> box){
    String tmp = "";
    for(Fruit f : box.getList())
        tmp += f + " ";
    return new Juice(tmp);
}

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
	...
// 이 메서드를 호출할 때는 아래와 같이 타입 변수에 타입을 대입해야 한다.        
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Apple>makeJuice(appleBox));

// 그러나 대부분의 경우 컴파일러가 타입을 추정할 수 있기에 생략 가능
System.out.println(Juicer.makeJuice(fruitBox));
System.out.println(Juicer.makeJuice(appleBox));
```

<br/>

주의할 점은 지네릭 메서드를 호출할 때, 대입된 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름을 생략할 수 없다.

같은 클래스 내에 있는 멤버들끼리는 참조변수나 클래스이름, 즉 this.이나 클래스이름.을 생략하고 메서드 이름만으로 호출이 가능하지만, 대입된 타입이 있을 때는 반드시 써줘야함

```java
System.out.println(<Fruit>makeJuice(fruitBox));	// 에러 클래스 이름 생략 불가
System.out.println(this.<Fruit>makeJuice(fruitBox));	// OK
System.out.println(Juicer.<Fruit>makeJuice<fruitBox));	// OK
```

<br/>

지네릭 메서드는 매개변수의 타입이 복잡할 때도 유용하다.

```java
public static void printAll(ArrayList<? extends Product> list, ArrayList<? extends Product> list2{
    for(Unit u : list){
        System.out.println(u);
    }
}
```

만일 위와 같은 코드가 있다면 타입을 별도로 선언함으로써 아래와 같이 코드를 간략히 할 수있다.

```java
public static <T extends Product> void printAll(ArrayList<T> list, ArrayList<T> list2{
    for(Unit u : list){
        System.out.println(u);
    }
}
```

<br/>

<br/>

Collections클래스의 sort()인데, 이전과 달리 매개변수가 하나짜리이다.

```java
public static <T extends Comparable<? super T>> void sort(List<T> list)
```

`List<T`>  

- 타입 T를 요소로 하는 List를 매개변수로 허용한다.

`<T extends Comparable<? super T>>` 

- 타입 T가 `Comparable`을 구현한 객체이면서,  T 또는 T의 조상타입만 받는다는 뜻

<br/>

<br/>

<br/>

## 1.7 지네릭 타입의 형변환

지네릭 타입과 원시 타입(raw type)간의 형변환이 가능하다. 다만 경고가 발생할 뿐

```java
Box 		box    = null;
Box<Object> objBox = null;

box	   = (Box)objBox;		// OK. generic type -> raw type 경고 발생
objBox = (Box<Object>)box;	// OK. raw type -> generic type 경고 발생
```

<br/>

<br/>

대입된 타입이 다른 지네릭간의 형변환은 불가능하다.

```java
Box<Object> objBox = null;
BOx<String> strBox = null;

objBox = (Box<Object>)strBox;	// 에러
strBox = (Box<String>)objBox;	// 에러
```

<br/>

<br/>

```java
Box<? extends Object> wBox = new Box<String>();
```

위 의 문장은 형변환이 가능하다. 그래서 전에 배운 makeJuice메서드의 매개변수에 다형성이 적용될 수 있었던 것

```java
// 매개변수로 FruitBox<Fruit>, FruitBox<Apple>, FruitBox<Grape>등이 가능
static Juice makeJuice(FruitBox<? extends Fruit> box) { ... }

FruitBox<? extends Fruit> box = new FruitBox<Fruit>();	// OK
FruitBox<? extends Fruit> box = new FruitBox<Apple>();	// OK
FruitBox<? extends Fruit> box = new FruitBox<Grape>();	// OK
```

<br/>

반대로의 형변환도 성립하지만, 확인되지 않은 형변환이라는 경고 발생.

`FruitBox<? extends Fruit>` 에 대입될 수 있는 타입이 여러 개인데다, `FruitBox<Apple>`를 제외한 다른 타입은 `FruitBox<Apple>`로 형변환될 수 없기 때문

```java
FruitBox<? extends Fruit> box = null;
// OK. 미확인 타입으로 형변환 경고
FruitBox<Apple> appleBox = (FruitBox<Apple>)box;
```

<br/>

<br/>

java.util.Optional 클래스의 실제 소스코드의 일부

```java
public final class Optional<T>{
    private static final Optional<?> EMPTY = new Optional<>();
    private final T value;
    ...
    public static<T> Optional<T> empty(){
        Optional<T> t = (Optional<T>)EMPTY;
        retrun t;
    }
}
```

<br/>

상수를 선언하는 문장을 분석하면 다음과 같다.

```java
   Optional<?> EMPTY = new Optional<>();
-> Optional<? extends Object> EMPTY = new Optional<Object>();


Optional<?> EMPTY = new Optional<?>();	// 에러 미확인 타입의 객체는 생성불가
Optional<?> EMPTY = new Optional<Object>();	// OK
Optional<?> EMPTY = new Optional<>();	// OK. 위의 문장과 동일
```

위의 문장에서 EMPTY 타입을 `Optional<Object>`가 아닌 `Optional<?>`로 한 이유는 `Optional<T>`로 형변환이 가능하기 때문이다.

```java
Optional<?>		 wopt = new Optional<Object>();
Optional<Object> oopt = new OPtional<Object>();

Optional<String> sopt = (Optional<String>)wopt;	// OK. 형변환 가능
Optional<String> sopt = (Optional<String>)oopt;	// 에러. 형변환 불가
```

empty() 반환 타입이 `Optional<T>`이므로 EMPTY를 `Optional<T>`로 형변환 해야하는데 `Optional<Object>`는 `Optional<T>`로 형변환이 불가능하다.

```java
Optional<Object> -> Optional<T>	// 형변환 불가능.
Optional<?> -> Optional<T> // 형변환 가능. 경고발생
```

<br/>

<br/>

다음과 같이 와일드 카드가 사용된 지네릭 타입끼리도 다음과 같은 경우에는 형변환이 가능하다.

```java
FruitBox<? extends Object> objBox = null;
FruitBox<? extends String> strBox = null;

strBox = (FruitBox<? extends String>)objBox;	// OK. 미확정 타입으로 형변환 경고
objBox	= (FruitBox<? extends Object>)strBox;	// OK. 미확정 타입으로 형변환 경고
```

하지만 와일드 카드는 타입이 확정된 타입이 아니므로 컴파일러는 미확정 타입으로 형변환하는 것이라고 경고한다.

<br/>

<br/>

## 1.8 지네릭 타입의 제거

지네릭은 타입 안정성을 보장하며, 실행시간에 오버헤드가 발생하지 않도록 하기위해 JDK 1.5부터 도입된 문법으로, 이전 자바에서는 지네릭 타입 파라미터 없이 자바를 코딩해왔다. 그래서 이전의 자바 버전의 코드와 호환성을 위해 지네릭 코드는 컴파일되면 지네릭 타입은 사라지게 된다. 
즉, 클래스 파일(.class)에는 지네릭 타입에 대한 정보는 존재하지 않는 것이다.

<br/>

### 지네릭 타입 소거 과정

컴파일러는 지네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 필요한 곳에 형변환을 넣어주고 최종적으로 컴파일 코드에 Type Erasure로 지네릭 타입을 제거하게 된다. 

#### 1. 지네릭 타입의 경계(bound)를 제거

- 지네릭 타입 `<T extends Fruit>` 이면,  T는 Fruit 로 치환된다.
- 지네릭 타입 `<T>` 는 Object로 치환된다.
- 그리고 클래스 옆의 선언은 제거된다.

```java
class Box<T extends Fruit>{
    void add(T t){}
}

// 치환 후
class Box{
    void add(Fruit t){}
}
```

<br/>

#### 2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.

List의 get()은 Object타입을 반환하므로 형변환이 필요하다.

```java
T get(int i){
    return list.get(i);
}

// 치환 후
Fruit get(int i){
    return (Fruit)list.get(i);
}
```

<br/>

와일드 카드가 포함되어 있는 경우에는 다음과 같이 적절한 타입으로의 형변환이 추가된다.

```java
static Juice makeJuice(FruitBox<? extends Fruit> box){
    String tmp = "";
    for(Fruit f : box.getList())
        tmp += f + " ";
    return new Juice(tmp);
}

// 치환 후
static Juice makeJuice(FruitBox box) {
    String tmp = "";
    Iterator it = box.getList().iterator();
    while(it.hasNext()){
        tmp += (Fruit)it.next() + " ";
    }
    return new Juice(tmp);
}

```

<br/>

<br/>

<br/>

<br/>

## 2. 열거형(enums)

## 2.1 열거형이란?

열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것(JDK 1.5부터 추가)

열거형이 갖는 값 뿐만 아니라 타입도 관리하기에 논리적인 오류를 줄일 수 있다.

```java
class Card{
    static final int CLOVER = 0;
    static final int HEART = 1;
    static final int DIAMOND = 2;
    static final int SPADE = 3;
    
    static final int TWO = 0;
    static final int THREE = 1;
    static final int FOUR = 2;
        
    final int kind;
    final int num;
}
```

위 코드를 열거형으로 표현하면 아래와 같다.

```java
class Card{
	enum Kind	{ CLOVER, HEART, DIAMOND, SPADE }	//  열거형 Kind를 정의
    enum Value { TWO, THREE, FOUR }	// 열거형 Value를 정의
    
    
    final Kind kind;	// 타입이 int가 아닌 Kind
    final Value value;
}
```

<br/>

기존에는 타입이 달라도 값이 같으면 조건식결과가 true였으나, 자바의 열거형은 **typesafe enum**(타입에 안전한 열거형)이라서 실제 값이 같아도 타입이 다르면 컴파일 에러

```java
if(Card.CLOVER == Card.TWO) // true지만 의미상 false이어야 맞음
if(Card.Kind.CLOVER == Card.Value.TWO) // 컴파일 에러. 값은 같지만 타입이 다름
```

 <br/>

또한 기존에는 상수의 값이 바뀌면 해당 상수를 참조하는 모든 소스를 다시 컴파일 해야 됐으나, 열거형 상수를 사용하면 컴파일하지 않아도됨

<br/>

<br/>

<br/>

## 2.2 열거형의 정의와 사용

```java
enum 열거형이름 { 상수명1, 상수명2, ... }
```

<br/>

### 동서남북 4방향을 상수로 정의하는 열거형 Direction

```java
enum Direction { EAST, SOUTH, WEST, NORTH }
```

<br/>

### 위 열거형에 정의된 상수를 사용하기!

 `열거형이름.상수명`

```java
class Unit{
    int x, y;	// 유닛의 위치
    Direction dir;	// 열거형을 인스턴스 변수로 선언
    
    void init(){
        dir = Direction.EAST;	// 유닛의 방향을 EAST로 초기화
    }
}
```

<br/>

### 열거형 상수간의 비교!

- `==`사용 가능
- `equals()`도 가능
- `<`, `>` 와 같은 비교연산자 사용 불가
- `compareTo()` 사용 가능
  - 왼쪽이 크면 양수
  - 오른쪽이 크면 음수
  - 비교 대상이 같으면 0

```java
if(dir == Direction.EAST){
    x++;
} else if(dir > Direction.WEST){ // 에러. 열거형 상수에 비교연산자 사용불가
    ...
} else if (dir.compareTo(Direction.WEST) > 0){ // compareTo()는 가능
    ...
}
```

<br/>

`switch`문의 조건식에도 열거형 사용 가능

```java
void move(){
    switch(dir) {
        case EAST: X++;	// Direction.EAST라고 쓰면 안됨
            break;
        case WEST: x--;
            break;
        case SOUTH: y++;
            break;
        case NORTH: y--;
            break;
    }
}
```

<br/>

<br/>

### 모든 열거형의 조상 - java.lang.Enum

열거형 Direction에 정의된 모든 상수 출력하기

```java
Direction[] dArr = Direction.values();

for(Direction d : dArr) 	// for(Direction d : Direction.values())
    System.out.printf("%s = %d\n", d.name(), d.ordinal());

// 결과 예시
// EAST = 0, SOUTH = 1, WEST = 2, NORTH = 3
```

<br/>

#### Enum클래스에 정의된 메서드

모든 Enum 타입은 컴파일 시에 java.lang.Enum 클래스를 상속하게 되어있기 때문에, java.lang.Enum 에 선언된 메소드를 이용할 수 있다

| 메서드                                      | 설명                                                      |
| ------------------------------------------- | --------------------------------------------------------- |
| `String name()`                             | 열거형 상수의 이름을 문자열로 반환한다.                   |
| `int ordinal()`                             | 열거형 상수가 정의된 순서를 반환한다.(0부터 시작)         |
| `Class<E> getDeclaringClass()`              | 열거형 Class객체를 반환한다.                              |
| `T valueOf(Class<T> enumType, String name)` | 지정된 열거형에서 name과 일치하는 열거형 상수를 반환한다. |

<br/>

#### 컴파일러가 자동으로 추가해주는 메서드

```java
static E values()	//  열거형의 모든 상수를 배열에 담아 보관한다. 
static E valueOf(String name)	// 열거형 상수의 이름으로 문자열 상수에 대한 참조를 얻을 수 있게 해준다.
```

`values()`와 `valueOf()`는 `Enum` 클래스에 없고, 열거형마다 다르게 동작해야 하기 때문에 컴파일러가 자동으로 열거형 클래스 내부에 생성.

<br/>

```java
// 열거형 선언
public enum Direction {
    NORTH, EAST, SOUTH, WEST;
}
// 컴파일 후 생성된 코드

public final class Direction extends java.lang.Enum<Direction> {
    public static final Direction NORTH = new Direction("NORTH", 0);
    public static final Direction EAST = new Direction("EAST", 1);
    public static final Direction SOUTH = new Direction("SOUTH", 2);
    public static final Direction WEST = new Direction("WEST", 3);

    // 모든 열거형 상수를 배열로 반환 (컴파일러가 자동 추가)
    public static Direction[] values() {
        return new Direction[]{NORTH, EAST, SOUTH, WEST};
    }

    // 주어진 이름에 해당하는 열거형 상수를 반환 (컴파일러가 자동 추가)
    public static Direction valueOf(String name) {
        for (Direction e : values()) {
            if (e.name().equals(name)) {
                return e;
            }
        }
        throw new IllegalArgumentException("No enum constant " + name);
    }

    // 생성자 (열거형은 private)
    private Direction(String name, int ordinal) {
        super(name, ordinal);
    }
}
```

<br/>

#### 예제

```java
enum Direction {EAST, SOUTH, WEST, NORTH}

public class EnumEx1 {
    public static void main(String[] args) {
        Direction d1 = Direction.EAST;
        Direction d2 = Direction.valueOf("WEST");
        Direction d3 = Enum.valueOf(Direction.class, "EAST");

        System.out.println("d1=" + d1);		// d1=EAST
        System.out.println("d2=" + d2);		// d2=WEST 
        System.out.println("d3=" + d3);		// d3=EAST

        System.out.println("d1==d2 ? " + (d1 == d2));	// d1==d2 ? false
        System.out.println("d1==d3 ? " + (d1 == d3));	// d1==d3 ? true
        System.out.println("d1.equals(d3) ? " + (d1.equals(d3)));	// d1.equals(d3) ? true
        System.out.println("d1.comapreTo(d3) ? " + (d1.compareTo(d3)));	// d1.comapreTo(d3) ? 0
        System.out.println("d1.compareTo(d2) ? " + (d1.compareTo(d2)));	// d1.compareTo(d2) ? -2

        switch (d1) {	// The direction is EAST.
            case EAST:
                System.out.println("The direction is EAST.");
                break;
            case SOUTH:
                System.out.println("The direction is SOUTH.");
                break;
            case WEST:
                System.out.println("The direction is WEST.");
                break;
            case NORTH:
                System.out.println("The direction is NORTH.");
            default:
                System.out.println("Invalid direction.");
        }
        Direction [] dArr = Direction.values();

        for(Direction d : dArr){
            System.out.printf("%s = %d\n",d.name(), d.ordinal());
        }
        /*
        	EAST = 0
        	SOUTH = 1
        	WEST = 2
        	NORTH = 3
        */
    }
}
```

<br/>

<br/>

<br/>

## 2.3 열거형에 멤버 추가하기

Enum클래스에 정의된 `ordinal()`이 열거형 상수가 정의된 순서를 반환하지만, 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋다. 이 값은 내부적인 용도로만 사용되기 위한 것이기 때문

<br/>

열거형 상수의 값이 불연속적인 경우는 다음과 같이하면 됨

```java
enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }
```

그리고 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해야 한다.

주의할 점은, 먼저 **열거형 상수를 모두 정의한 다음에 다른 멤버를 추가**해야하고 **열거형 상수의 마지막에 `;`도 추가**해야 한다.

```java
enum Direction{
    EAST(1), SOUTH(5), WEST(-1), NORTH(10);	// 끝에 `;`추가
    
    private final int value;	// 정수를 저장할 필드(인스턴스 변수)를 추가
    Direction(int value) { this.value = value } // 생성자를 추가, private Direction(int value)와 동일
    
    public int getValue() { return value; }
}
```

열거형의 인스턴스 변수는 반드시 final이어야 한다는 제약은 없지만, value는 열거형 상수의 값을 저장하기 위한 것이므로 final을 붙였음

> 열거형 상수는 본질적으로 변하지 않는 값(immutable)을 나타내기에

<br/>

열거형 생성자는 제어자가 묵시적으로 private이다. 그래서 객체 생성 불가

```java
Direction d = new Direction(1);	// 에러. 열거형의 생성자는 외부에서 호출불가
```

<br/>

아래와 같이 열거형 상수에 여러 값을 지정할 수도 있음

```java
enum Direction{
    EAST(1,">"), SOUTH(2,"V"), WEST(3,"<"), NORTH(4,"^");
    
    private final int value;
    private final String symbol;
    
    Direction(int value, String symbol){	// 접근 제어자 private이 생략됨
        this.value = value;
        this.symbol = symbol;
    }
    public int getValue() { return value; }
    public String getSymbol() { return symbol; }
}
```

<br/>

<br/>

#### 예제

```java
package EnumEx2;

enum Direction {

    EAST(1, ">"), SOUTH(2, "V"), WEST(3, "<"), NORTH(4, "^");
    private static final Direction[] DIR_ARR = Direction.values();
    private final int value;
    private final String symbol;

    Direction(int value, String symbol) {
        this.value = value;
        this.symbol = symbol;
    }

    public int getValue() {
        return value;
    }

    public String getSymbol() {
        return symbol;
    }

    public static Direction of(int dir) {
        if (dir < 1 || dir > 4) {
            throw new IllegalArgumentException("Invalid value :" + dir);
        }
        return DIR_ARR[dir - 1];
    }

    // 방향을 회전시키는 메서드. num 값만큼 90도씩 시계방향으로 회전한다.
    public Direction rotate(int num) {
        num = num % 4;	// 한 바퀴는 4칸 회전
        if (num < 0) num += 4;  // num이 음수일 때는 시계반대 방향으로 회전
        
        // value는 현재 방향의 값
        // value - 1로 현재 방향을 0부터 시작하는 인덱스처럼 맞춘다.
        return DIR_ARR[(value - 1 + num) % 4];
    }
    public String toString(){
        return name() + getSymbol();
    }
}

public class EnumEx2 {
    public static void main(String[] args) {
        for(Direction d : Direction.values()) {
            System.out.printf("%s=%d\n", d.name(), d.getValue());
            /*
            EAST=1
            SOUTH=2
            WEST=3
            NORTH=4
            */
        }
        Direction d1 = Direction.EAST;
        Direction d2 = Direction.of(1);

        System.out.printf("d1=%s, %d\n",d1.name(),d1.getValue());	// d1=EAST, 1
        System.out.printf("d2=%s, %d\n",d2.name(),d2.getValue());	// d1=EAST, 1

        System.out.println(Direction.EAST.rotate(1));	// SOUTH
        System.out.println(Direction.EAST.rotate(2));	// WEST
        System.out.println(Direction.EAST.rotate(-1));	// NORTH
        System.out.println(Direction.EAST.rotate(-2));	// WEST
    }
}
```

<br/>

<br/>

### 열거형에 추상 메서드 추가하기

다음 열거형 Transprotation은 운송 수단의 종류 별로 상수를 정의하고 있으며, 각 운송 수단에는 기본요금(BASIC_FARE)이 책정되어 있다

```java
enum Transportation{
    BUS(100), TRAIN(150), SHIP(100), AIRPLANE(300);
    
    private final int BASIC_FARE;
    
    private Transportation(int basicFare){
        this.BASI_FARE = basicFare;
    }
    
    int fare(){
        return BASIC_FARE;
    }
}
```

거리에 따라 요금을 계산하는 방식이 각 운송 수단마다 다를 것이다. 이럴 때, 열거형에 추상 메서드 `fare(int distance)`를 선언하면 각 열거형 상수가 이 추상 메서드를 반드시 구현해야 한다.

```java
enum Transportation{
    BUS(100){
        int fare(int distance){
            return distance * BASIC_FARE;}
        }
    },
	TRAIN(150) { int fare(int distance) { return distance*BASIC_FARE; }},
	SHIP(100) { int fare(int distance) { return distance*BASIC_FARE; }},
	AIRPLANE(300) { int fare(int distance) { return distance*BASIC_FARE; }}; 
    
    abstract int fare(int distance);	// 거리에 따른 요금을 계산하는 추상 메서드
    
	// protected로 해야 각 상수에서 접근가능, 열거형에서 각 상수는 익명 서브클래스처럼 동작한다.
	protected final int BASIC_FARE;		
    
    private Transportation(int basicFare){
        this.BASI_FARE = basicFare;
    }
    
    int getBasicFare(){
        return BASIC_FARE;
    }
}
public class EnumEx3 {
    public static void main(String[] args) {
        System.out.println("bus fare="+Transporation.BUS.fare(100));	// bus fare=10000
        System.out.println("train fare="+Transporation.TRAIN.fare(100)); // train fare=15000
        System.out.println("ship fare="+Transporation.SHIP.fare(100));	// ship fare=10000
        System.out.println("airplane fare="+Transporation.AIRPLANE.fare(100));	// airplane fare=30000
    }
}
```

<br/>

<br/>

<br/>

## 2.4 열거형의 이해

열거형 Direction이 다음과 같이 정의되어 있을 때

```java
enum Direction { EAST, SOUTH, WEST, NORTH }
```

위의 문장을 클래스로 정의한다면 아래와 같다.

- 열거형 상수 하나하나가 Direction 객체
- static 상수 EAST, SOUTH, WEST, NORTH의 값은 객체의 주소이고, 이 값은 변하지 않는 값이므로 `==`로 비교가 가능한 것

```java
class Direction{
    static final Direction EAST = new Direction("EAST");
    static final Direction SOUTH = new Direction("SOUTH");
    static final Direction WEST = new Direction("WEST");
    static final Direction NORTH = new Direction("NORTH");
    
    private String name;
    
    private Direction(String name){
        this.name = name;
    }
}
```

<br/>

<br/>

모든 열거형은 추상 클래스 Enum의 자손이므로, Enum을 흉내 내어 MyEnum을 작성하면 다음과 같다.

```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T>{
    static int id = 0;	// 객체에 붙일 일련번호(0부터 시작)
    
    int ordinal;
    String name = "";
    
    public int ordinal() { return ordinal; }
    
    MyEnum(String name){
        this.name = name;
        ordinal = id++;	// 객체를 생성할 때마다 id의 값을 증가시킨다.
    }
    
    public int compareTo(T t){
        return ordinal - t.ordinal();
    }
}
```

만약 클래스를 `MyEnum<T>`와 같이 선언하였다면, compareTo()를 위와 같이 간단히 작성할 수 없었을 것이다. 타입 T에 ordinal()이 정의되어 있는지 확인할 수 없기 때문이다.

```java
abstract class MyEnum<T> implements Comparable<T>{
   ...
    public int compareTo(T t){
        return ordinal - t.ordinal();	// 에러. 타입 T에 oridnal()이 있나?
    }
}
```

<br/>

<br/>

그리고 추상 메서드를 새로 추가하면, 클래스 앞에도 abstract를 붙여줘야하고 각 static상수들도 추상 메서드를 구현해주어야 한다. 아래의 코드에서는 익명 클래스의 형태로 추상 메서드를 구현했다.

```java
abstract class Direction extedns MyEnum{
    static final Direction EAST = new Direction("EAST"){	// 익명 클래스
        Point move(Point p){ /*내용생략*/ }
    };
    static final Direction SOUTH = new Direction("SOUTH"){
            Point move(Point p){ /*내용생략*/ }
    };
    static final Direction WEST = new Direction("WEST"){
            Point move(Point p){ /*내용생략*/ }
    };
    static final Direction NORTH = new Direction("NORTH"){
            Point move(Point p){ /*내용생략*/ }
    };
        
    private String name;
    
    private Direction(String name){
        this.name = name;
    }
    abstract Point move(Point p);
}
```

<br/>

<br/>

**예제**

```java
import java.util.Comparator;

abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T> {
    static int id = 0;
    int ordinal;
    String name = "";

    public int ordinal() {
        return ordinal;
    }

    MyEnum(String name) {
        this.name = name;
        ordinal = id++;
    }

    public int compareTo(T t) {
        return ordinal - t.ordinal();
    }
}

abstract class MyTransportation extends MyEnum {

    static final MyTransportation BUS = new MyTransportation("BUS", 100) {
        int fare(int distance) {
            return distance * BASIC_FARE;
        }
    };
    static final MyTransportation TRAIN = new MyTransportation("TRAIN", 150) {
        int fare(int distance) {
            return distance * BASIC_FARE;
        }
    };
    static final MyTransportation SHIP = new MyTransportation("SHIP", 100) {
        int fare(int distance) {
            return distance * BASIC_FARE;
        }
    };
    static final MyTransportation AIRPLANE = new MyTransportation("AIRPLANE", 300) {
        int fare(int distance) {
            return distance * BASIC_FARE;
        }
    };


    abstract int fare(int distance);

    protected final int BASIC_FARE;

    private MyTransportation(String name, int basicFare) {
        super(name);
        BASIC_FARE = basicFare;
    }

    public String name() {
        return name;
    }

    public String toString() {
        return name;
    }
}

public class EnumEx4 {
    public static void main(String[] args) {
        MyTransportation t1 = MyTransportation.BUS;
        MyTransportation t2 = MyTransportation.BUS;
        MyTransportation t3 = MyTransportation.TRAIN;
        MyTransportation t4 = MyTransportation.SHIP;
        MyTransportation t5 = MyTransportation.AIRPLANE;

        System.out.printf("t1=%s, %d\n",t1.name(), t1.ordinal());	// t1=BUS, 0
        System.out.printf("t2=%s, %d\n",t2.name(), t2.ordinal());	// t2=BUS, 0
        System.out.printf("t3=%s, %d\n",t3.name(), t3.ordinal());	// t3=TRAIN, 1
        System.out.printf("t4=%s, %d\n",t4.name(), t4.ordinal());	// t4=SHIP, 2
        System.out.printf("t5=%s, %d\n",t5.name(), t5.ordinal());	// t5=AIRPLANE, 3
        System.out.println("t1==t2 ? "+(t1==t2));					// t1==t2 ? true
        System.out.println("t1.compareTo(t3)="+t1.compareTo(t3));	// t1.compareTo(t3)=-1
    }
}
```

<br/>

<br/>

<br/>

<br/>

## 3. 애너테이션(annotation)

## 3.1 애너테이션이란?

어노테이션은 다른 프로그램에게 유용한 정보를 제공하기 위해 사용되는 것으로 주석과 같은 의미를 가진다.

**어노테이션의 역할**

- 컴파일러에게 문법 에러를 체크하도록 정보를 제공한다.
- 프로그램을 빌드할 때 코드를 자동으로 생성할 수 있도록 정보를 제공한다.
- 런타임에 특정 기능을 실행하도록 정보를 제공한다.

<br/>

어노테이션은 @를 사용하여 작성하며, 해당 타겟에 대한 동작을 수행하는 프로그램 외에는 다른 프로그램에게 영향을 주지 않는다.

```java
@Test // 이 메서드가 테스트 대상임을 테스트 프로그램에게 알린다.
public void method(){
	...
}
```

> JDK에서 제공하는 에너테이션은 java.lang.annotation패키지에 포함되어 있다.

<br/>

<br/>

**표준 애너테이션 **: 자바에서 기본적으로 제공하는 에너테이션

| 애너테이션           | 설명                                                |
| -------------------- | --------------------------------------------------- |
| @Override            | 컴파일러에게 오버라이딩하는 메서드라는 것을 알린다. |
| @Deprecated          | 앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.   |
| @SuppressWarnings    | 컴파일러의 특정 경고메시지가 나타나지 않게 해준다.  |
| @SafeVarargs         | 지네릭스 타입의 가변인자에 사용한다.(JDK1.7)        |
| @FunctionalInterface | 함수형 인터페이스라는 것을 알린다.(JDK1.8)          |
| @Native              | native메서드에서 참조되는 상수 앞에 붙인다.(JDK1.8) |

<br/>

**메타 애너테이션**: 에너테이션을 정의하는데 사용되는 에너테이션의 에너테이션

| 에너테이션  | 설명                                                       |
| ----------- | ---------------------------------------------------------- |
| @Target     | 애너테이션이 적용가능한 대상을 지정하는데 사용             |
| @Documented | 애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다. |
| @Inherited  | 애너테이션이 자손 클래스에  상속되도록 한다.               |
| @Retention  | 에너테이션이 유지되는 범위를 지정하는데 사용한다.          |
| @Repeatable | 애너테이션을 반복해서 적용할 수 있게 한다.(JDK1.8)         |

<br/>

<br/>

<br/>

## 3.2 표준 애너테이션

### @Override

메서드 앞에만 붙일 수 있는 에너테이션으로, **조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할**을 한다.

아래와 같이 메서드 앞에 @Override라고 애너테이션을 붙이면, 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면, 에러메시지를 출력한다.

```java
class Parent{
    void parentMethod(){}
}


class Child extends Parent{
    @Override
    void parentmethod() {}	// 오버라이딩하려 했으나 실수로 이름을 잘못 적음
}
```

**결과**

```
C:\Users\dlwls\Desktop\Java Code\Chapter12\Annotation\AnnotationEx1.java:16:5
java: method does not override or implement a method from a supertype
```

<br/>

<br/>

### @Deprecated

필드나 메서드에 @Deprecated를 붙여서 사용하는데 이 에너테이션이 붙인 대상은 **다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다**는 것을 나타낸다.

java.util. Date클래스의 getDate()를 보면 아래와 같이 적혀있다. 이 메서드 대신 JDK1.1부터 추가된 Calendar클래스의 set()을 사용하라는 얘기다.  즉, 기존의 것 대신 새로 추가된 개선된 기능을 사용하도록 유도하는 것

```java
@Deprecated
public int getDate() {
    return normalize().getDayOfMonth();
}
Deprecated As of JDK version 1.1, replaced by Calendar.set(Calendar. DAY_OF_MONTH, int date).
```

<br/>

**예제**

```java
class NewClass{
    int newField;
    
    int getNewField(){return newField;}

    @Deprecated
    int oldField;
    
    @Deprecated
    int getOldField(){return oldField;}
}

public class AnnotationEx2 {
    public static void main(String[] args) {
        NewClass nc = new NewClass();

        nc.oldField = 10;
        System.out.println(nc.getOldField());
    }
}

```

만약 @Deprecated가 붙은 대상을 사용하는 코드를 작성하면, 컴파일할 때 아래와 같은 메시지가 나타난다.

그래도 컴파일도 실행도 잘되었다. 왜냐하면 @Deprecated가 붙은 대상을 사용하지 않도록 권할 뿐 강제성은 없기에

```
c:\jdk1.8\work\ch12>javac AnnotationEx2.java
Note: AnnotationEx2.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details

c:\jdk1.8\work\ch12>java AnnotationEx2
10
```

메시지대로 -Xlint:deprecation옵션을 붙여서 다시 컴파일하면 자세한 내용을 보여준다.

```
c:\jdk1.8\work\ch12>javac -Xlint:deprecation AnnotationEx2.java
```

<br/>

<br/>

### @FunctionalInteface

함수형 인터페이스를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킨다.

> 함수형 인터페이스는 추상 메서드가 하나뿐이어야 한다는 제약이 있다.

```java
@FunctionalInteface
public interface Runnable{
    public abstract void run();
}
```

<br/>

<br/>

### @SuppressWarnings

컴파일러의 경고메세지가 나타나지 않게 한다.

보통 경고가 많을 때, 확인된 경고는 해당 어노테이션을 붙여서 **로그가 지저분해지는 것을 막고** 불필요한 경고로 인해 **중요한 경고를 알아보지 못하는 것을 방지**하기 위해 사용한다.

**종류**

- `@SuppressWarnings("all")` : 모든 경고를 무시
- `@SuppressWarnings("deprecation")` : @Deprecated가 붙은 대상을 사용해서 발생하는 경고 무시
- `@SuppressWarnings("rawtypes")` : 제네릭 타입을 사용하지 않은 raw type에 대한 경고를 무시
- `@SuppressWarnings("unchecked")` : 제네릭 타입 캐스팅과 관련된 컴파일러 경고를 무시
- `@SuppressWarnings("varargs")` : 가변인자의 타입이 제너릭 타입일때 발생하는 경고 무시

<br/>

둘 이상의 경고를 동시에 억제하려면 다음과 같이 하면됨

```java
@SuppressWarnings({"deprecation", "unchecked", "varargs"})
```

<br/>

<br/>

### @SafeVarargs

**static**이나 **final**이 붙은 메서드와 생성자에만 붙일 수 있다

- 즉, 오버라이드 될 수 있는 메서드에는 사용할 수 없다.

<br/>

**refiable 타입** : Compile 후에도 제거되지 않는 타입

**non-refiable 타입** : Compile 후에 제거되는 타입

- 대부분의 Generics 타입처럼 Compile 후에 제거되는 타입들이 있다>



메서드에 선언된 가변인자(varargs)의 타입이 **non-reifiable 타입**일 경우,
해당 메서드를 **선언 · 호출**하는 부분에서 `unchecked` 경고가 발생

- 메서드를 선언하는 부분에만 **@SafeVarargs **를 붙이면 호출하는 부분에서 발생하는 경고도 억제

<br/>

#### 예시 - java.util.Arrays의 asList()

```java
public static <T> List<T> asList(T... a){
    return new ArrayList<T>(a);	// ArrayList(E[] array)를 호출. 경고 발생
}
```

asList()의 매개변수가 가변인자인 동시에 지네릭 타입이다. 메서드에 선언된 타입 T는 컴파일과정에서 Object[]가 된다.

Object[]에는 모든 타입의 객체가 들어 있을 수 있으므로, 이 배열로 `ArrayList<T>`를 생성하는 것은 위험하다고 경고하는 것이다.

그러나 asList()가 호출되는 부분을 컴파일러가 체크해서 타입 T가 아닌 다른 타입이 들어가지 못하게 할 것이므로 위 코드는 문제 x

이럴 때는 메서드 앞에 **@SafeVarargs**를 붙여서 이 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에게 알려서 경고가 발생하지 않도록 해야한다.

 **@SafeVarargs** 는 "varargs" 경고는 억제하지 못하기 때문에, **' @SuppressWarning '** 를 같이 붙인다

- 가능하면 이 두 애너테이션은 항상 같이 사용하자

```java
@SafeVarargs                  // 'unchecked' 경고 억제
@SuppressWarnings("varargs")  // 'varargs'경고 억제
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a); 
}
```

<br/>

<br/>

### @Native

native method에 의해 참조되는 상수 필드(constant field)에 붙이는 애너테이션이다.

아래는 java.lang.Long클래스에 정의된 상수

```java
@Native public static final long MIN_VALUE = 0x8000000000000000L;
```

<br/>

native method는 JVM이 설치된 OS의 메서드를 말한다. 보통 c로 작성되어 있는데, 자바에서는 메서드의 선언부만 정의하고 구현은 하지 않음

```java
public class Object{
    private static native void registerNatives();	// 네이티브 메서드
    
    static{
        registerNatives();	// 네이티브 메서드 호출
    }
    
    protected native Object clone() throws CloneNotSupportedException;
    public final native Class<?> getClass();
    ...
}
```

네이티브 메서드를 호출하면 실제로 호출되는 것은 OS의 메서드이다.

> 그냥 native method 선언해놓고 호출한다고 되는 것은 아니고 자바에 정의된 네이티브 메서드와 OS의 메서드를 연결해주는 작업이 추가로 필요함
>
> > 이 역할은 JNI(java native interface)가 함

<br/>

<br/>

<br/>

## 3.3 메타 애너테이션

**애너테이션을 위한 애너테이션**, 즉 애너테이션에 붙이는 애너테이션이다.

애너테이션의 적용대상(target)이나 유지기간(retention)등을 지정하는데 사용된다.

<br/>

### @Target

에너테이션이 적용가능한 대상을 지정하는데 사용된다.

아래는 @SuppressWarnings를 정의한 것인데, 이 애너테이션에 적용할 수 있는 대상을 @Target으로 지정하였다.

```java
@Target({TYPE, FILED, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings{
    String[] value();
}
```

<br/>

**@Target으로 지정할 수 있는 애너테이션 적용대상의 종류**

| 대상 타입       | 의미                            |
| --------------- | ------------------------------- |
| ANNOTATION_TYPE | 애너테이션                      |
| CONSTRUCTOR     | 생성자                          |
| FIELD           | 필드(멤버변수, enum 상수)       |
| LOCAL_VARIABLE  | 지역변수                        |
| METHOD          | 메서드                          |
| PACKAGE         | 패키지                          |
| PARAMETER       | 매개변수                        |
| TYPE            | 타입(클래스,인터페이스, enum)   |
| TYPE_PARAMETER  | 제너릭 타입 매개변수(JDK1.8)    |
| TYPE_USE        | 타입이 사용되는 모든 곳(JDK1.8) |

<br/>

#### 예제

```java
package Annotation;

import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Target;

@Target({FIELD, TYPE, TYPE_USE})    // 적용 대상이 FIELD, TYPE, TYPE_USE
public @interface MyAnnotation{
}

@MyAnnotation   // 적용 대상이 TYPE인 경우
class MyClass{
    @MyAnnotation   // 적용 대상이 FIELD인경우
    int i;
    
    @MyAnnotation   // 적용 대상이 TYPE_USE 인경우
    MyClass mc;
}
```

<br/>

<br/>

### @Retention

에너테이션이 유지(retention)되는 기간을 지정하는데 사용된다.

에너테이션의 유지 정책(retention policy)의 종류

| RetentionPolicy | 의미                                             |
| --------------- | ------------------------------------------------ |
| SOURCE          | 소스 파일에만 존재. 클래스파일에는 존재하지 않음 |
| CLASS           | 클래스 파일에 존재. 실행시에 사용불가 .default   |
| RUNTIME         | 클래스 파일에 존재. 실행시에 사용가능            |

<br/>

####  SOURCE

@Override나 @SuppressWarnings처럼 컴파일러가 사용하는 애너테이션은 SOURCE

```java
@TARGET(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override{}
```

<br/>

#### RUNTIME

유지정책을 RUNTIME으로 하면, 실행 시에 reflection을 통해 클래스 파일에 저장된 애너티에션의 정보를 읽어서 처리할 수 있다.

@FuctionalInteface는 컴파일러가 체크해주는 애너테이션이지만, 실행 시에도 사용되므로 RetentionPolicy가 RUNTIME으로 되어 있다.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @inteface FunctionalInterface{}
```

<br/>

#### CLASS

Compiler가 애너테이션의 정보를 class 파일에 저장할 수 있게 한다. 하지만, class 파일이 JVM에 로딩될 때는 애너테이션의 정보가 무시되어 실행 시에 애너테이션에 대한 정보를 얻을 수 없다 

   -> 이것이 ' CLASS ' 가 잘 사용되지 않는 이유

<br/>

<br/>

### @Documented

애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다

- @Override  와  @SuppressWarnings  를 제외한 표준 애너테이션에는 이 메타 애너테이션이 붙어 있다

<br/>

<br/>

### @Inherited

애너테이션이 sub class에 상속되도록 한다.

@Inherited가 붙은 애너테이션을 super class에 붙이면, sub class도 이 애너테이션이 붙은 것과 같이 인식

```java
@Inherited
@interface SupperAnno{}

@SuperAnno
class Parent{}

class Child extends Parent{}	// child에 애너테이션이 붙은 것으로 인식
```

<br/>

<br/>

### @Repeatable

보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데, 이 메타 애너테이션이 붙은 애너테이션은 **여러 번** 붙일 수 있다

```java
@Repeatable(ToDOs.class)	// ToDo 에너테이션을 여러 번 반복해서 쓸수 있게한다.
@interface ToDo{
    String value();
}
```

위와 같이 @ToDo라는 에너테이션이 정의되어 있을 때, 다음과 같이 MyClass클래스에 @ToDo를 여러번 붙이는 것이 가능

```java
@ToDo("delete test codes.")
@ToDo("override inherited methods")
class Myclass{
    ...
}
```

같은 이름의 애너테이션이 여러 개가 하나의 대상에 적용될 수 있기 때문에, 이 애너테이션들을 하나로 묶어서 다룰 수 있는 에너테이션도 추가로 정의해야 한다.

```java
@interface ToDos {  // 여러 개의 ToDo 애너테이션을 담을 컨테이너 애너테이션 ToDos
    ToDo[] value(); // ToDo 애너테이션 배열타입의 요소를 선언. 이름이 반드시 value이어야 한다!
}

@Repeatable(ToDos.class)  // 괄호 안에 컨테이너 애너테이션을 지정
@interface ToDo {
    String value();
}
```

<br/>

<br/>

<br/>

## 3.4 애너테이션 타입 정의하기

```java
@interface 애너테이션이름{
	타입 요소이름();	// 애너테이션의 요소를 선언한다.
	...
}
```

### 애너테이션의 요소

**애너테이션의 요소** : 에너테이션 내에 선언된 메서드

```java
@interface TestInfo{
    int	count();
    String testBy();
    String[] testTools();
    TestType testType(); // enum TestType { FIRST, FINAL }
    DateTime testDate();	// 자신이 아닌 다른 애너테이션을 포함할 수 있다.
}
@interface DateTime{
    String yymmdd();
    String hhmmss();
}
```

애너테이션의 요소는 추상 메서드의 형태이며, 상속을 통해 구현하지 않아도 된다. 다만, 애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해주어야 한다. 요소의 이름도 같이 적어주므로 순서는 상관x

```java
@TestInfo(
    count = 3, testBy = "Kim",
    testTools = {"JUnit", "AutoTester"},
    testType = TestType.FIRST,
    testDate = @DateTime(yymmdd="160101", hhmmss="235959")
)
public class NewClass{..}
```

<br/>

<br/>

애너테이션의 각 요소는 null을 제외한 기본값을 가질 수있다.

```java
@interface TestInfo{
    int count() default 1;	// 기본값을 1로 지정
}
@TestInfo	// @TestInfo(count=1)
public class NewClass{...}
```

<br/>

<br/>

애너테이션 요소가 오직 하나뿐이고 이름이 value인경우, 요소의 이름을 생략하고 값만 적어도됨

```java
@interface TestInfo{
    String value()
}
@TestInfo("passed")	// @TestInfo(value = "passed")와 동일
public class NewClass{...}
```

<br/>

<br/>

요소의 타입이 배열인 경우, 괄호{}를 사용해서 여러 개의 값을 지정 가능

```java
@interface TestInfo{
    String[] testTools();
}

@TestInfO(testTools = {"JUnit", "AutoTester"})	// 값이 여러 개인 경우
@TestInfO(testTools = "JUnit")	// 값이 하나일 때는 {} 생략 가능
@TestInfO(testTools = {})	// 값이 없을 때는 {}가 반드시 필요
```

<br/>

<br/>

기본값을 지정할 때도 {}사용 가능

```java
@interface TestInfo{
    String[] info()	default {"aaa", "bbb"};
    String[] info2() default "ccc";
}
@TestInfo	// @TestInfo(info = {"aaa","bbb"}, info2="ccc") 와 동일
@TestInfo(info2 = {})	// @TestInfo(info = {"aaa","bbb"}, info2={}) 와 동일
class NewClass{...}
```

<br/>

<br/>

요소의 타입이 배열일 때도 요소의 이름이 vaule이면, 요소의 이름을 생략할 수 있다.

```java
@interface SuppressWarnings{
    String[] value();
}

// @SuppressWarnings(value = {"deprecation", "unchecked"})
@SuppressWarnings({"deprecation", "unchecked"})
class NewClass{ ... }
```

<br/>

<br/>

### java.lang.annotation.Annotation

모든 애너테이션의 조상은 Annotation.

그러나 애너티에션은 상속이 허용되지 않으므로 명시적으로 Annotation을 조상으로 지정 불가

```java
@interface TestInfo extends Annotation{	// 에러
    int count();
    String testedBy();
    ...
}
```

 <br/>

<br/>

#### Annotation인터페이스 소스

```java
public interface Annotation {
    boolean equals(Object obj);
    int hashCode();
    String toString();
    Class<? extends Annotation> annotationType();
}
```

위와 같이 정의되어 있기에 모든 애너테이션 객체에 대해 다음과 같은 메서드를 호출하는게 가능

- 아래 코드는 AnnotationTest클래스에 적용된 모든 애너테이션에 대해 toString(), hashCode(), equals()를 호출

```java
Class<AnnotationTest> cls = AnnotationTest.class;
Annotation[] annoArr= AnnotationTest.class>getAnnotations();

for(Annotation a : annoArr){
    System.out.println("toString():"+a.toString());
    System.out.println("hashCode():"+a.hashCode());
    System.out.println("equals():"+a.equals(a));
    System.out.println("annotationType():"+a.annotationType());
}
```

<br/>

<br/>

### Maker Annotation

요소가 하나도 정의되지 않은 애너테이션

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override{}	
```

<br/>

<br/>

### 에너테이션 요소를 선언할 때 규칙

```
- 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다.
- ()안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소를 타입 매개변수로 정의할 수 없다.
```

```java
@interface AnnoTest{
	int id = 10;	// OK 상수 선언. static final int id = 100;
    String major(int i, int j); // 에러. 
    String minor() throws Exception; // 에러.
    ArrayList<T> list();	//에러
}
```

<br/>

<br/>

