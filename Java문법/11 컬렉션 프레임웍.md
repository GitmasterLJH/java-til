# 1. Collections Framework

#### 용어

- **Collection** : 다수의 데이터(즉, 데이터 그룹)
- **Framework** : 표준화된 프로그램 방식
- **Collections Framework** : 데이터 그룹을 저장하는 클래스들을 표준화한 설계
- **Collection 클래스** : 다수의 데이터를 저장할 수 있는 클래스( Vector, Stack 등)

<br/>

<br/>

#### 장점

컬렉션 프레임웍은 컬렉션(data group)을 다루는 데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 상당히 덜어 준다.

인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

<br/>

<br/>

<br/>

## 1.1 컬렉션 프레임웍의 핵심 인터페이스

![image-20250108232916891](https://github.com/user-attachments/assets/833cc979-26df-493d-b6c8-b0341bc4b9ff)



> JDK1.5부터 Iterable인터페이스가 추가되고 이를 Collection 인터페이스가 상속받도록 변경되었으나 이것은 단지 인터페이스들의 공통적인 메서드인 iterator()를 뽑아서 중복을 제거한 것

<br/>

<br/>

| 인터페이스 | 특징                                                         | 구현 클래스                               |
| ---------- | ------------------------------------------------------------ | ----------------------------------------- |
| List       | 순서가 있는 데이터의 집합<br />데이터의 중복을 허용한다.     | ArrayList, LinkedList, Stack, Vector등    |
| Set        | 순서를 유지하지 않는  데이터의 집합<br />데이터의 중복을 허용하지 않는다. | HashSet, TreeSet 등                       |
| Map        | 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합<br />순서는 유지되지 않는다.<br />키는 중복을 허용 x , 값은 중복 허용 o | HashMap, TreeMap, Hashtable, Proterties등 |

<br/>

**Vector**나 **Hashtable**과 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다.

<br/>

<br/>

<br/>

### Collection 인터페이스

List와 Set의 조상인 Collection 인터페이스에 정의된 메서드

![image-20250108232945754](https://github.com/user-attachments/assets/92ee66fb-2e05-4274-8b98-e149f182275a)

> 책에서는 이해를 위해 지네릭스 E대신 Object로 표기함

<br/>

<br/>

<br/>

### List 인터페이스 - 순서 O, 중복 O

![image-20250108232955789](https://github.com/user-attachments/assets/390910df-6cda-4355-9183-85fbc17d9bd6)

List 인터페이스에 정의된 메서드

![image-20250108233002756](https://github.com/user-attachments/assets/752b0ddb-2f1f-4eb5-8625-8ea8d6f04fee)

<br/>

<br/>

<br/>

### Set 인터페이스 - 순서 X, 중복 X

![image-20250108233132436](https://github.com/user-attachments/assets/8fe4dc8b-8af4-4598-a170-f9d2c70bc64e)

Set 인터페이스의 메서드 : Collection 인터페이스와 동일

![image-20250108233238906](https://github.com/user-attachments/assets/3f3e5704-a3bc-4c36-8723-befac5b76213)
<br/>

<br/>

<br/>

### Map 인터페이스 - 순서 X, 중복(키 X, 값 O)

![image-20250108233408257](https://github.com/user-attachments/assets/9a15776a-c38c-4dac-9d2e-afc8eb8a4505)

Map 인터페이스의 메서드

![image-20250108233439565](https://github.com/user-attachments/assets/5d16e8ff-66c3-464f-9891-4267d6401e4c)

`Collection values()`

- Map인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환

`Set keySet()`

- 키(key)는 중복을 허용하지 않기 때문에 Set타입으로 반환

<br/>

<br/>

### Map.Entry 인터페이스

- Map.Entry인터페이스는 Map인터페이스의 내부 인터페이스이다.
- Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.
- Map인터페이스를 구현하는 클래스 에서는 Map.Entry 인터페이스도 함께 구현해야 한다.
- 맵에 저장되는 엔트리의 조작을 위한 메소드가 정의되어있다

```java
public interface Map{
	...
	public static interface Entry{
		Object getKey();
        Object getValue();
        Object setValue(Object value);
        boolean equals(Object o);
        int hashCode();
        ...
	}
}
```

<br/>

<br/>

<br/>

## 1.2 ArrayList

- ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다.
- Vector는 자체적으로 동기화처리가 되어 있으나 ArrayList는 그렇지 않다
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.

![image-20250109012854032](https://github.com/user-attachments/assets/c534b764-cda0-400a-b4cf-9217e7594f94) 

<br/>

ArrayList의 생성자와 메서드

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| ArrayList()                              | 크기가 10인 ArrayList를 생성                                 |
| ArrayList(Collection c)                  | 주어진  컬렉션이 저장된 ArrayList를 생성                     |
| ArrayList(int initialCapacity)           | 지정된 초기용량을 갖는 ArrayList를 생성                      |
| boolean add(Object o)                    | ArrayList의 마지막에 객체를 추가. 성공하면 true              |
| void add(int index, Object element)      | 지정된 위치(index)에 객체를 저장                             |
| boolean addAll(Collection c)             | 주어진 컬렉션의 모든 객체를 저장한다.                        |
| boolean addAll(int index, Collection c)  | 지정된 위치부터 주어진 컬렉션의 모든 객체를 저장한다.        |
| void clear()                             | ArrayList를 완전히 비운다.                                   |
| Object clone()                           | ArrayList를 복제한다.                                        |
| boolean contains(Object o)               | 지정된 객체(o)가 ArrayList에 포함되어 있는지 확인            |
| void ensureCapacity(int minCapacity)     | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.         |
| Object get(int index)                    | 지정된 위치(index)에 저장된 객체를 반환한다.                 |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치를 찾아서 반환한다.                 |
| boolean isEmpty()                        | ArrayList가 비어있는지 확인한다.                             |
| Iterator iterator()                      | ArrayList의 Iterator 객체를 반환                             |
| int lastIndexOf(Object o)                | 객체(o)가 저장된 위치를 끝부터 역방으로 검색해서 반환        |
| ListIterator listIterator()              | ArrayList의 ListIterator을 반환                              |
| ListIterator listIterator(int index)     | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환     |
| Object remove(int index)                 | 지정된 위치(index)에 있는 객체를 제거한다.                   |
| boolean remove(Object o)                 | 지정된 객체를 제거한다.                                      |
| boolean removeAll(Collection c)          | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다. |
| boolean retainAll(Collection c)          | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Object element)    | 주어진 객체(element)를 지정된 위치(index)에 저장한다.        |
| int size()                               | ArrayList에 저장된 객체의 개수를 반환한다.                   |
| voidsort(Comparator c)                   | 지정된 정렬기준(c)으로 ArrayList를 정렬                      |
| List subList(int fromIndex, int toIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.          |
| Object[] toArray()                       | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.        |
| Object[] toArray(Object[] a)             | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다. |
| void trimToSize()                        | 용량을 크기에 맞게 줄인다.(빈 공간 없앰)                     |

<br/>

<br/>

### ArrayListEx1

```java
import java.util.ArrayList;
import java.util.Collections;


public class ArrayListEx1 {

    public static void main(String[] args) {
        ArrayList list1 = new ArrayList(10);
        list1.add(Integer.valueOf(5));
        list1.add(Integer.valueOf(4));
        list1.add(Integer.valueOf(2));
        list1.add(Integer.valueOf(0));
        list1.add(Integer.valueOf(1));
        list1.add(Integer.valueOf(3));


        ArrayList list2 = new ArrayList<>(list1.subList(1,4));
        print(list1,list2);
        /*
        list1: [5, 4, 2, 0, 1, 3]
        list2: [4, 2, 0]
         */

        Collections.sort(list1);
        Collections.sort(list2); // Collections.sort(List l)
        print(list1, list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4]
         */

        System.out.println("list1.containsAll(list2):" +list1.containsAll(list2)); // true

        list2.add("B");
        list2.add("C");
        list2.add(3,"A");
        print(list1,list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4, A, B, C]
         */

        list2.set(3,"AA");
        print(list1,list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4, AA, B, C]
         */

        // list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제
        System.out.println("list1.retainAll(list2) :" + list1.retainAll(list2)); // true
        print(list1,list2);
        /*
        list1: [0, 2, 4]
        list2: [0, 2, 4, AA, B, C]
         */

        // list2에서 list1에 포함돈 객체들을 삭제한다.
        for(int i = list2.size()-1; i>=0; i--){
            if(list1.contains(list2.get(i)))
                list2.remove(i);
        }
        print(list1,list2);
        /*
        list1: [0, 2, 4]
        list2: [AA, B, C]
         */
    }


   static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1: "+list1);
        System.out.println("list2: "+list2);
        System.out.println();
    }
}
```

> Collections는 클래스

<br/>

<br/>

### ArrayListEx2

긴 문자열 데이터를 원하는 길이로 잘라서 ArrayList에 담은 다음 출력하는 예제

```java
import java.util.*;

public class ArrayListEx2 {
    public static void main(String[] args) {
        final int LIMIT = 10; // 자르고자 하는 글자의 개수
        String source = "0123456789abcdefghijABCDEFGHIJ!@#$%^&*()ZZZ";
        int length = source.length();

        List list = new ArrayList(length/LIMIT + 10); // 크기를 약간 여유 있게 잡음

        for(int i=0; i<length;i+=LIMIT){
            if(i+LIMIT < length)
                list.add(source.substring(i,i+LIMIT));
            else
                list.add(source.substring(i));
        }
        for(int i=0; i<list.size();i++){
            System.out.println(list.get(i));
        }
    }
}
```

<br/>

<br/>

### VectorEx1

Vector의 용량(capacity)과 크기(size)에 관한 예제

```java
import java.util.*;

public class VectorEx1 {
    public static void main(String[] args) {
        Vector v = new Vector(5); // 용량(capacity)이 5인 Vector를 생성한다.
        v.add("1");
        v.add("2");
        v.add("3");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :5
        */
        
        v.trimToSize(); // 빈 공간을 없앤다. (capacity와 size가 같아짐)
        System.out.println("=== After trimToSize() ===");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :3
        */

        v.ensureCapacity(6);
        System.out.println("=== After ensureCapacity(6) ===");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :6
        */
        
        
        v.setSize(7);
        System.out.println("=== After setSize(7) ===");
        print(v);
        /*
        [1, 2, 3, null, null, null, null]
        size  :7
        capacity :12
        */

        v.clear();
        System.out.println("=== After clear ===");
        print(v);
        /*
        []
        size  :0
        capacity :12
        */
    }
    static void print(Vector v){
       System.out.println(v);
       System.out.println("size  :"+ v.size());
       System.out.println("capacity : "+v.capacity());
    }
}
```

#### 과정별 크기(size)와 용량(capacity)

<br/>

#### 1. capacity가 5인 Vector인스턴스 V 생성 후, 3개의 객체를 저장

```java
Vector v = new Vector(5);
v.add("1");
v.add("2");
v.add("3");
```

![image-20250109033425862](https://github.com/user-attachments/assets/1b461c89-9177-4d33-b880-592bb84a4b03)

<br/>

<br/>

#### 2. v.trimToSize()를 호출하여 v의 빈공간 없앰

- size와 capacity가 같아진다.
- 배열은 크기를 변경할 수 없기에 새로운 배열을 생성해서 그 주소값을 변수 v에 할당한다.
- 기존의 Vector인스턴스는 더 이상 사용 불가, 후에 **garbage collector**에 의해서 메모리에서 제거됨

```java
v.trimToSize();
```

![image-20250109033509023](https://github.com/user-attachments/assets/ec8b8106-a898-4cdf-bbe7-bfa00a187b5d)

<br/>

<br/>

#### 3. v의 capacity가 최소한 6이 되도록 한다.

- 만약 v의 capacity가 6이상이면 아무 일도 일어나지 않는다.
- 현재는 v의 capacity가 3이므로 크기가 6인 배열을 생성해서 v의 내용을 복사한다.

```java
v.ensureCapacity(6);
```

![image-20250109033642317](https://github.com/user-attachments/assets/3b5b9dc7-c367-48eb-9ac9-3850978fe3d0)

<br/>

<br/>

#### 4. v의 size가 7이 되도록 한다.

- 만약 v의 capacity가 충분하면 아무일도 안일어남
- 지금은 capacity가 6으로 부족하므로 새로운 인스턴스를 생성한다.
  - 자동적으로 기존의 크기보다 2배의 크기로 증가된다.(capacity = 12가 됨)

> 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 된다.

```java
v.setSize(7);
```

![image-20250109033742292](https://github.com/user-attachments/assets/ee88bc5c-f42d-44a9-8b5e-1551c5e1397a)

<br/>

<br/>

#### 5. v의 모든 요소를 삭제한다.

```java
v.clear();
```

![image-20250109033752377](https://github.com/user-attachments/assets/6308316c-7ace-435a-8ff7-82a9c7590964)

> Vector는 Object배열이기 때문에 실제로는 마지막 그림처럼 주소가 저장되어야 더 정확한 것이지만, 편의상 이전의 그림들은 간략하게 표현함

<br/>

<br/>

#### ArrayList나 Vector같이 배열을 이용한 자료구조 특징

- 데이터를 읽어오고 저장하는데 효율이 좋다.
- 용량을 변경해야할 때는 새로운 배열을 생성한후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야하기에 효율이 떨어진다.

따라서 처음 인스턴스를 생성할 때, 용량을 잘 설정해야함

<br/>

<br/>

### MyVector

Vector클래스의 실제코드를 바탕으로 이해하기 쉽게 재구성한 예제

```java
import java.util.*;

public class MyVector implements List {

    Object[] data = null; // 객체를 담기 위한 객체배열
    int capacity = 0; // 용량
    int size = 0; // 크기

    public MyVector(int capacity) {
        if (capacity < 0)
            throw new IllegalArgumentException("유효하지 않은 값입니다. :" + capacity);
        this.capacity = capacity;
        data = new Object[capacity];
    }

    public MyVector() {
        this(10);
    }


    public void ensureCapacity(int minCapacity) {

        if (minCapacity - data.length > 0)
            setCapacity(minCapacity);
    }

    public boolean add(Object obj) {
        ensureCapacity(size + 1);
        data[size++] = obj;
        return true;
    }

    public Object get(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        return data[index];
    }


    public Object remove(int index) {
        Object oldObj = null;

        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        oldObj = data[index];

        // 삭제하고자 하는 객체가 마지막 객체가 아닌경우
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        // 마지막 데이터를 null로 한다.
        data[size - 1] = null;
        size--;
        return oldObj;
    }


    public boolean remove(Object obj) {
        for (int i = 0; i < size; i++) {
            if (obj.equals(data[i])) {
                remove(i);
                return true;
            }
        }
        return false;
    }


    public void trimToSize() {
        setCapacity(size);
    }

    public void setCapacity(int capacity) {
        if (this.capacity == capacity) return;

        Object[] tmp = new Object[capacity];
        System.arraycopy(data, 0, tmp, 0, Math.min(size, capacity));
        size = Math.min(size, capacity);
        data = tmp;
        this.capacity = capacity;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            data[i] = null;
        }
        size = 0;
    }

    public Object[] toArray() {
        Object[] result = new Object[size];
        System.arraycopy(data,0,result,0,size);
        return result;
    }

    public boolean isEmpty() {
        return size==0;
    }


    public int capacity() {
        return capacity;
    }

    public int size() {
        return size;
    }

    public boolean contains(Object o) {
        for(int i=0; i<size;i++){
            if(o.equals(data[i]))
                return true;
        }
        return false;
    }

    public int indexOf(Object o){
        return indexOfRange(o,0,size);
    }

    int indexOfRange(Object o, int start, int end) {
        Object[] es = data;
        if (o == null) {
            for (int i = start; i < end; i++) {
                if (es[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = start; i < end; i++) {
                if (o.equals(es[i])) {
                    return i;
                }
            }
        }
        return -1;
    }

    public int lastIndexOf(Object o) {
        return lastIndexOfRange(o, 0, size);
    }

    int lastIndexOfRange(Object o, int start, int end) {
        Object[] es = data;
        if (o == null) {
            for (int i = end - 1; i >= start; i--) {
                if (es[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = end - 1; i >= start; i--) {
                if (o.equals(es[i])) {
                    return i;
                }
            }
        }
        return -1;
    }
    public Object set(int index, Object element) {
        if(index<0 || index>size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        Object oldValue = data[index];
        data[index] = element;
        return oldValue;
    }

    public void add(int index, Object element) {
        if(index<0 || index>=size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");

        ensureCapacity(size+1);
        if(index!=size-1)
            System.arraycopy(data,index, data,index+1,size-index);
        data[index] = element;
        size++;

    }

    public String toString(){
        if (size == 0) 
            return "[]";
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        
        for (int i = 0; i < size; i++) {
            sb.append(data[i]);
            if (i < size - 1) // 마지막 요소가 아니면 쉼표 추가
                sb.append(", ");
        }
        sb.append(']');
        return sb.toString();
    }
// 아랫부분은 컴파일만 가능하도록 최소한으로 구현한것

    @Override
    public Iterator iterator() {
        return null;
    }

    @Override
    public Object[] toArray(Object[] a) {
        return new Object[0];
    }

    @Override
    public boolean containsAll(Collection c) {
        return false;
    }

    @Override
    public boolean addAll(Collection c) {
        return false;
    }

    @Override
    public boolean addAll(int index, Collection c) {
        return false;
    }

    @Override
    public boolean removeAll(Collection c) {
        return false;
    }

    @Override
    public boolean retainAll(Collection c) {
        return false;
    }

    @Override
    public ListIterator listIterator() {
        return null;
    }

    @Override
    public ListIterator listIterator(int index) {
        return null;
    }

    @Override
    public List subList(int fromIndex, int toIndex) {
        return List.of();
    }
}
```

<br/>

<br/>

#### MyVector클래스에서 0~4 값이 저장되어 있는 상태에서 `remove(2)` 호출 과정

![image-20250109233424356](https://github.com/user-attachments/assets/96574688-0fde-4c2e-b04f-beb4bb61c2be)

1. 삭제할 데이터의 아래에 있는 데이터를 한 칸 씩 위로 복사해서 삭제할 데이터를 덮어쓴다.

   ```java
   System.arraycopy(data, index+1, data, index, size-index-1) // data[3]에서 data[2]로 2개의 데이터를 복사
   ```

2. 데이터가 모두 한 칸씩 위로 이동하였으므로 마지막 데이터는 null로 변경

   ```java
   data[size-1] = null
   ```

3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 1 감소시킨다.

   ```java
   size--;
   ```

<br/>

#### 결론

배열에 객체를 **순차적으로 저장**하거나 객체를 **마지막에 저장된 것부터 삭제**하면 `System.arraycopy()`를 호출하지 않기 때문에 **효율적**이지만 배열의 **중간에 위치한 객체를 추가하거나 삭제**하는 경우 `System.arraycopy()`를 호출해서 데이터의 위치를 이동시켜야 하기 때문에 **효율적이지 못함**

<br/>

<br/>

<br/>

## 1.3 LinkedList

#### ArrayList의 장단점

장점

- 배열은 구조가 간단하며 사용하기 쉽다.
- 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다.

<br/>

단점

- 크기를 변경할 수 없다.
  - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함.
  - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨
- 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
  - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만 배열의 중간에 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.

<br/>

<br/>

### linked list - 배열의 단점을 보안

- 배열과 달리 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있음

![image-20250110001352392](https://github.com/user-attachments/assets/1de8a470-0673-4b16-abd9-d0daabe9c58f)

linked list의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.

```java
class Node{
    Node node;		// 다음 요소의 주소를 저장
    Object obj;		// 데이터를 저장
}
```

<br/>

<br/>

#### 데이터의 삭제 - 단 하나의 참조변경으로 가능

삭제하고자 하는 node의 이전요소가 삭제하고자 하는 node의 다음 요소를 참조하도록 변경하면 됨.

배열처럼 데이터를 이동하기 위해 복사하는 과정이 없으니 처리속도가 빠르다.

![image-20250110001609870](https://github.com/user-attachments/assets/caff0b5a-e0fc-4371-8504-b908e8101772)

<br/>

#### 데이터의 추가 - 한 번의 Node생성과 두 번의 참조변경만으로 가능

새로운 데이터를 추가할때는 새로운 Node를 생성후 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경해주고, 새로운 요소가 그 다음 요소를 참조하도록 변경하면되므로 처리속도가 빠르다.

![image-20250110001735682](https://github.com/user-attachments/assets/0431a8e3-2b22-461f-9ba4-da1f9e3ef0c1)

<br/>

하지만 LinkedList는 이동방향이 단방향이기에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다. 

이점을 보안한 것 :  **doubly linked list**

<br/>

### doubly linked list(이중 연결리스트) - 양방향 접근

링크드 리스트보다 각 요소에 대한 접근과 이동이 쉬움

```java
class Node{
    Node next;		// 다음 요소의 주소를 저장
    Node previous;	// 이전 요소의 주소를 저장
    Object obj;		// 데이터를 저장
}
```

![image-20250110005704010](https://github.com/user-attachments/assets/b9f25854-c407-45cb-acdc-6e004d121021)

실제로 LinkedList클래스는 이름과 달리 링크드 리스트가 아니라 **더블 링크드 리스트**로 구현되어있다.

> 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위해서

<br/>

<br/>

### doubly circular linked list(이중 원형 연결 리스트)

더블 링크드 리스트의 접근성을 보다 향상시킨것으로, 단순히 더블 링크드 리스트의 마지막 Node와 첫 번째 Node를 서로 연결시킨 것이다.

![image-20250110005949283](https://github.com/user-attachments/assets/69fcd701-c470-4b0f-ad22-9c9e04ce8d54)

<br/>

<br/>

### LinkedList 클래스의 생성자와 메서드

| 생성자 또는 메서드                       | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| LinkedList()                             | LinkedList객체를 생성                                        |
| LinkedList(Collection c)                 | 주어진 컬렉션을 포함하는 LinkedList객체를 생성               |
| boolean add(Object o)                    | 지정된 객체(o)를 LinkedList의 끝에 추가                      |
| void add(int index, Object element)      | 지정된 위치(index)에 객체(element)를 추가                    |
| boolean addAll(Collection c)             | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가    |
| boolean addAll(int index, Collection c)  | 지정된 위치(index)에 주어진 컬렉션에 포함된 모든 요소를 추가 |
| void clear()                             | LinkedList의 모든 요소를 삭제                                |
| boolean contains(Object o)               | 지정된 객체가 LinkedList에 포함되어있는지 알려줌             |
| boolean containsAll(Collection c)        | 지정된 컬렉션의 모든 요소가 포함되어있는지 알려줌            |
| Object get(int index)                    | 지정된 위치(index)의 객체를 반환                             |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치(앞에서 몇 번째)를 반환             |
| boolean isEmpty()                        | LinkedList가 비어있는지 알려준다. 비어있으면 true            |
| Iterator iterator()                      | Iterator를 반환                                              |
| int lastIndexOf(Object o)                | 지정된 객체의 위치(index)를 반환(끝부터 역순검색)            |
| ListIterator listIterator()              | ListIterator를 반환                                          |
| ListIterator listIterator(int index)     | 지정된 위치에서부터 시작하는 ListIterator를 반환             |
| Object remove(int index)                 | 지정된 위치(index)의 객체를 LinkedList에서 제거              |
| boolean remove(Object o)                 | 지정된 객체를 LinkedList에서 제거                            |
| boolean removeAll(Collection c)          | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제             |
| boolean retainAll(Collection c)          | 교집합                                                       |
| Object set(int index, Object element)    | 지정된 위치(index)의 객체를 주어진 객체로 바꿈               |
| int size()                               | LinkedList에 저장된 객체의 수를 반환                         |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 변환                              |
| Object[] toArray()                       | LinkedList에 저장된 객체를 배열로 변환                       |
| Object[] toArray(Object[] a)             | LinkedList에 저정된 객체를 주어진 배열에 저장하여 반환       |

<br/>

<br/>

### ArrayList와 LinkedList의 성능 비교1

결과는 밀리초 단위

```
= 순차적으로 추가하기 = 
ArrayList :48
LinkedList :373

= 중간에 추가하기 = 
ArrayList :2457
LinkedList :0

= 중간에서 삭제하기 = 
ArrayList :1599
LinkedList :94

= 순차적으로 삭제하기(데이터를 역순으로 삭제하는것을 의미) = 
ArrayList :0
LinkedList :16

= 접근시간테스트 =
ArrayList :0
LinkedList :76
```

<br/>

#### 1. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.

 ArrayList는 마지막 데이터부터 삭제할 경우 단지 마지막 요소의 값을 null로만 바꾸면 되기에 상당히 빠름

> 단순히 저장하는 시간만을 비교하기 위해 ArrayList를 생성할 때 충분한 초기용량을 확보하였다.
>
> 만약 ArrayList의 크기가 충분하지 않았다면 순차적으로 추가해도 LinekdList가 더 빠를 수 있다.

<br/>

#### 2. 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.

 LinkedList는 각 요소간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠르다.

 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦다.

<br/>

#### 3. 접근시간(access time)은 ArrayList가 빠르다.

ArrayList(배열)의 경우 각 요소들이 연속적으로 메모리상에 존재하기 때문에 간단한 계산만으로 원하는 요소의 주소를 얻어서 저장된 데이터를 곧바로 읽어올 수 있다.

```
인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기
```

만약 `Object [] arr = new Object[5];` 일때 `arr[2]`에 저장된 값을 읽으려 한다면

- n = 2
- 모든 참조형 변수의 크기 = 4byte
- 생성된 배열의 주소 = 0x100
-  arr[2]의 주소는 `0x100 + 2 * 4 = 0x108`이된다.

![image-20250110015220545](https://github.com/user-attachments/assets/1403f7db-994c-4a83-9427-9f5c81183848)



<br/>

하지만 LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다. 즉, 저장된 데이터 개수가 많을수록 접근시간이 길어짐

![image-20250110015631056](https://github.com/user-attachments/assets/ed0488f4-8c6d-4f39-a9fc-e2585058ec85)

<br/>

#### 요약

![image-20250110015713429](https://github.com/user-attachments/assets/673f8c47-26c6-4758-884a-fe58db5375f3)

<br/>

<br/>

<br/>

## 1.4 Stack과 Queue

![image-20250110024842709](https://github.com/user-attachments/assets/a5b0f8be-5587-4ff2-85cf-944e4441b892)

### **Stack** - LIFO(Last In First Out)

**Stack 구현**

- 순차적으로 데이터를 추가하고 삭제하므로 **ArrayList**와 같은 배열기반의 컬렉션 클래스가 적합

<br/>

**Stack의 메서드**

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| boolean empty()          | Stack이 비어있는지 알려준다.                                 |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환.<br />pop()과 달리 Stack에서 객체를 꺼내지는 않음.(비었을때는 EmptyStackException 발생) |
| Object pop()             | Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을때는 EmptyStackException 발생) |
| Object push(Object item) | Stack에 객체(item)를 저장한다.                               |
| int search(Object o)     | Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환, 못찾으면 -1을 반환<br />(배열과 달리 위치는 0이 아닌 1부터 시작) |

<br/>
<br/>

**예제1**

자바에선 스택을 Stack클래스로 구현하여 제공함

```java
import java.util.*;


public class StackQueueEx {
    public static void main(String[] args) {
        Stack st = new Stack();

        st.push("0");
        st.push("1");
        st.push("2");


        System.out.println("Stack");
        while(!st.empty()){
            System.out.println(st.pop());
        }
    }
}
/* 결과
Stack
2
1
0
*/
```

<br/>

<br/>

**예제2**

웹브라우저의 '뒤로', '앞으로' 버튼의 기능을 구현한 것

```java
import java.util.*;

public class StackEx1 {
    public static Stack back = new Stack();
    public static Stack forward = new Stack();

    public static void printStatus(){
        System.out.println("back: "+back);
        System.out.println("forward: "+forward);
        System.out.println("현재화면은 '" + back.peek()+"' 입니다.");
        System.out.println();
    }

    public static void goURL(String url){
        back.push(url);
        if(!forward.empty())
            forward.clear();
    }

    public static void goForward(){
        if(!forward.empty())
            back.push(forward.pop());
    }

    public static void goBack(){
        if(!back.empty())
            forward.push(back.pop());
    }

    public static void main(String[] args) {
        goURL("1.네이트");
        goURL("2.야후");
        goURL("3.네이버");
        goURL("4.다음");

        printStatus();

        goBack();
        System.out.println("= '뒤로' 버튼을 누른 후 =");
        printStatus();

        goBack();
        System.out.println("= '뒤로' 버튼을 누른 후 =");
        printStatus();

        goForward();
        System.out.println("= '앞으로' 버튼을 누른 후 =");
        printStatus();

        goURL("codechobo.com");
        System.out.println("= 새로운 주소로 이동 후 =");
        printStatus();
    }
}
/* 결과
back: [1.네이트, 2.야후, 3.네이버, 4.다음]
forward: []
현재화면은 '4.다음' 입니다.

= '뒤로' 버튼을 누른 후 =
back: [1.네이트, 2.야후, 3.네이버]
forward: [4.다음]
현재화면은 '3.네이버' 입니다.

= '뒤로' 버튼을 누른 후 =
back: [1.네이트, 2.야후]
forward: [4.다음, 3.네이버]
현재화면은 '2.야후' 입니다.

= '앞으로' 버튼을 누른 후 =
back: [1.네이트, 2.야후, 3.네이버]
forward: [4.다음]
현재화면은 '3.네이버' 입니다.

= 새로운 주소로 이동 후 =
back: [1.네이트, 2.야후, 3.네이버, codechobo.com]
forward: []
현재화면은 'codechobo.com' 입니다.
*/
```

<br/>

<br/>

**예제3**

입력한 수식의 괄호가 올바른지 체크하는 예제

`(`를 만나면 스택에 push, `)`를 만나면 스택에서 pop

`)`를 만나서 `(`를 꺼내려 할 때 스택이 비어있거나 수식을 검사하고 난 후에도 스택이 비어있지 않으면 괄호가 잘못된 것

```java
import java.util.*;

public class ExpValidCheck {
    public static void main(String[] args) {
        Stack st = new Stack();

        Scanner sc = new Scanner(System.in);
        String expression = sc.nextLine();

        System.out.println("expression:" + expression);

        try {
            for (int i=0; i<expression.length(); i++) {
                char ch = expression.charAt(i);

                if(ch=='(')
                    st.push(ch+"");
                else if(ch==')')
                    st.pop();
            }

            if(st.isEmpty())
                System.out.println("괄호가 일치합니다.");

        } catch (EmptyStackException e) {
            System.out.println("괄호가 일치하지 않습니다.");
        }
    }
}
/*결과
(2+3)*1
expression:(2+3)*1
괄호가 일치합니다.
*/
```

<br/>

<br/>

**Stack 직접 구현하기**

```java
import java.util.EmptyStackException;
import java.util.Vector;

public class MyStack extends Vector {
    public Object push(Object item) {
        addElement(item);
        return item;
    }

    public Object pop() {
        Object obj = peek();
        // 만약 Stack 이 비어있으면 peek() 메서드가 EmptyStackException을 발생시킨다.
        // 마지막 요소를 삭제한다.
        removeElementAt(size() - 1);
        return obj;
    }

    public Object peek() {
        int len = size();
        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }

    public boolean empty() {
        return size() == 0;
    }
    public int search(Object o){
        int i  = lastIndexOf(o);

        if(i>=0){
            return size() - i;
        }
        return  -1;
    }

}
```

<br/>

<br/>

<br/>

### **Queue** - FIFO(First In First Out)

**Queue 구현**

- **배열기반 컬렉션 클래스**를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 **비효율적**
- 그래서 큐는 데이터의 추가/삭제가 쉬운 **LinkedList**로 구현하는게 더 적합

<br/>

**Queue의 메서드**

| 메서드                  | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. 성공하면 true 반환<br />저장공간이 부족하면 IllegalStateException 발생 |
| Object remove()         | Queue에서 객체를 꺼내 반환. 비어있으면 NoSuchElementException 발생 |
| Object element()        | 삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을때 NoSuchElementException 발생 |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true, 실패하면 false를 반환    |
| Object poll()           | Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환         |
| Object peek()           | 삭제없이 요소를 읽어온다. Queue가 비어있으면 null을 반환     |

<br/>

<br/>

**예제1**

Queue는 인터페이스로만 정의해 놓았기에 이를 구현한 클래스들중 선택해서 사용하면됨

```java
import java.util.*;

public class QueueEx {
    public static void main(String[] args) {
        Queue q = new LinkedList();
        q.offer("0");
        q.offer("1");
        q.offer("2");

        System.out.println("Queue");
        while(!q.isEmpty()){
            System.out.println(q.poll());
        }
    }
}
/* 결과
Queue
0
1
2
*/
```

<br/>

<br/>

**예제2**

유닉스의 history명령어를 Queue로 구현한것

```java
import java.util.*;


public class QueueEx1 {
    static Queue q = new LinkedList();
    static final int MAX_SIZE = 5; // Queue에 최대 5개까지 저장되도록 한다.

    public static void main(String[] args) {
        System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");

        while (true) {
            System.out.print(">>");
            try {
                Scanner s = new Scanner(System.in);
                String input = s.nextLine().trim();

                if ("".equals(input)) continue;
                if (input.equalsIgnoreCase("q")) {
                    System.exit(0);
                } else if (input.equalsIgnoreCase("help")) {
                    System.out.println(" help - 도움말을 보여줍니다.");
                    System.out.println(" q 또는 Q - 프로그램을 종료합니다.");
                    System.out.println(" history - 최근에 입력한 명령어를 " + MAX_SIZE + "개 보여줍니다.");
                } else if(input.equalsIgnoreCase("history")){
                    int i=0;
                    save(input);

                    LinkedList tmp = (LinkedList)q;
                    ListIterator it = tmp.listIterator();

                    while(it.hasNext())
                        System.out.println(++i+"."+it.next());
                }else{
                    save(input);
                    System.out.println(input);
                }

            } catch (Exception e) {
                System.out.println("입력오류입니다.");
            }
        }
    }

    public static void save(String input) {
        if(!"".equals(input))
            q.offer(input);

        if(q.size() > MAX_SIZE)
            q.remove();
    }
}
/* 결과
help를 입력하면 도움말을 볼 수 있습니다.
>>help
 help - 도움말을 보여줍니다.
 q 또는 Q - 프로그램을 종료합니다.
 history - 최근에 입력한 명령어를 5개 보여줍니다.
>>dir
dir
>>ls
ls
>>cd Desktop
cd Desktop
>>history
1.dir
2.ls
3.cd Desktop
4.history
>>
*/
```

<br/>

<br/>

### PriorityQueue

Queue인터페이스의 구현체중 하나로 저장한 순서에 관계없이 **우선순위**(priority)가 높은 것부터 꺼낸다.

null은 저장할 수 없음(저장할 시 NullPointerException 발생)

PriorityQueue는 저장공간으로 배열을 사용하며, 각 요소를 **힙**(heap)이라는 자료구조의 형태로 저장한다.

<br/>

**예제**

저장순서가 3,1,5,2,4인데도  `poll()`의 결과가 1,2,3,4,5인것을 볼 수 있다. (숫자가 작을수록 우선순위가 높음)

객체를 저장하여 크기를 비교할 경우 각 객체의 크기를 비교할 수 있는 방법을 제공해야 한다.

예제에서는 컴파일러가 정수를 Integer로 오토박싱 해주는데 Number의 자손이므로 자체적으로 숫자를 비교하는 방법이 정의되어 있다.

```java
import java.util.*;

public class PriorityQueueEx {
    public static void main(String[] args) {
        Queue pq = new PriorityQueue();
        pq.offer(3);
        pq.offer(1);
        pq.offer(5);
        pq.offer(2);
        pq.offer(4);
        
        // 참조변수 pq를 출력하면 저장한 순서와 다른데 그이유는 힙으로 저장되어있어서
        System.out.println(pq); // [1, 2, 5, 3, 4]  

        Object obj = null;

        while ((obj = pq.poll()) != null) {
            System.out.println(obj); // 1	2	3	4	5
        }
    }
}
```

<br/>

<br/>

### Deque(Double-Ended Queue, 덱, 디큐) : Stack과 Queue의 결합

Queue와 달리, **Deque은 양쪽 끝에 추가/삭제가 가능**하다. 

Deque의 조상은 Queue이며, 구현체로 ArrayDeque, LinkedList등이 있다.

![image-20250112220824871](https://github.com/user-attachments/assets/cdd33922-038c-4b32-a49f-4d880cea0811)

<img src="https://github.com/user-attachments/assets/e613a790-9ec8-43a9-b302-e2e8cc35a115" alt="image-20250112221250508" style="zoom:50%;" />

<br/>

<br/>

<br/>

## 1.5 Iterator, ListIterator, Enumeration

Iterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스

<br/>

### Iterator

컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것

```java
public interface Iterator{
    boolean hasNext();
    Object next();
    void remove();
}

public interface Collection { 
    ...
    public Iterator iterator();
    ...
}
```

컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용.

> Collection을 구현한 List와 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어있음

| 메서드            | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| boolean hasNext() | 읽어 올 요소가 남아있는지 확인. 있으면 treu, 없으면 false    |
| Object next()     | 다음 요소를 읽어온다.                                        |
| void remove()     | next()로 읽어 온 요소를 삭제한다.<br />next()를 호출한 다음에 remove()를 호출할 수 있다. |

<br/>

Iterator인터페이스를 구현하는 클래스에서 `remove()`는 선택적 기능이므로 구현하지 않아도 됨.

대신 다음과 같이 예외를 던져 구현하지 않은 기능이라는 것을 메서드를 호출하는 쪽에 알리는 것이 좋다.

```java
public void remove(){
    throw new UnsupportedOperationException();
}
```

<br/>

<br/>

**ArrayList에 저장된 요소들을 출력하기 위한 코드 예시**

Iterator를 이용해서 컬렉션의 요소를 읽어오는 방법을 표준화함 -> 코드의 일관성을 유지하여 재사용성을 극대화함

```java
Collection c = new ArrayList(); // Collection 인터페이스를 구현한 다른 컬렉션 클래스들도 가능
Iterator it = c.iterator();

while(it.hasNext())
    System.out.println(it.next());
```

>  Set클래스들은 각 요소간의 순서가 유지 되지 않기 때문에 Iterator를 이용해서 읽어와도 처음에 저장된 순서와 같지 않다.

<br/>

**Iterator 구현 예제**

```java
import java.util.*;

public class MyVector2 extends MyVector implements Iterator{
    int cursor = 0; // 앞으로 읽어 올 요소의 위치
    int lastRet = -1;  // 마지막으로 읽어 온 요소의 위치

    public MyVector2(int capacity){
        super(capacity);
    }
    public MyVector2(){
        this(10);
    }
    public String toString(){
        String tmp = "";
        Iterator it = iterator();

        for(int i=0; it.hasNext();i++){
            if(i!=0)
                tmp+=", ";
            tmp+=it.next();
        }
        return "["+tmp+"]";
    }
    public Iterator iterator(){
        cursor = 0; // cursor와 lastRet를 초기화 한다.
        lastRet = -1;
        return this;
    }
    public boolean hasNext(){
        return cursor != size();
    }

    public Object next(){
        Object next = get(cursor);
        lastRet = cursor++;
        return next;
    }

    public void remove(){
        if(lastRet==-1) // 더 이상 삭제할 것(읽어온 값)이 없으면 예외 발생
            throw new IllegalStateException();
        else{
            remove(lastRet);	// 최근에 읽어온 요소를 삭제
            cursor--;			// cursor의 위치를 1감소시킨다.
            lastRet = -1;		// 읽어온 요소가 삭제되었으므로 초기화 한다.
        }
    }

}
```



<br/>

#### Map 인터페이스를 구현한 컬렉션 클래스

key, value를 쌍으로 저장하고 있기 때문에 `iterator()`를 직접 호출할 수 없고, 그 대신 `Set keySet()`, `Set entrySet()`, `Collection values()`의 메서드를 통해서 키와 값을 각각 따로 Set의 형태로 얻어 온 후에 다시 `iterator()`를 호출해야 **Iterator**를 얻을 수있다.

```java
Map map = new HashMap();

Iterator it = map.entrySet().iterator();
```

<br/>

<br/>

### ListIterator와 Enumeration

**Enumeration** : Iterator의 구버전

- 이전 버전과 호환을 위해 남겨둠

| 메서드                    | 설명                           |
| ------------------------- | ------------------------------ |
| boolean hasMoreElements() | 읽어 올 요소가 남아있는지 확인 |
| Object nextElement()      | 다음 요소를 읽어온다.          |

<br/>

<br/>

**ListIterator** : Iterator에 양방향 조회기능추가(List를 구현한 경우만 사용가능)

- Iterator를 상속받아서 기능을 추가함

| 메서드              | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| void add(Object o)  | 컬렉션에 새로운 객체(o)를 추가한다.                          |
| boolean hasNext()   | 읽어 올 다음 요소가 남아있는지 확인                          |
| Object next()       | 다음 요소를 읽어 온다.                                       |
| Object previous()   | 이전 요소를 읽어 온다.                                       |
| int nextIndex()     | 다음 요소의 Index를 반환                                     |
| int previousIndex() | 이전 요소의 Index를 반환                                     |
| void remove()       | next() 또는 previous()로 읽어 온 요소를 삭제한다.            |
| void set(Object o)  | next() 또는 previous()로 읽어 온 요소를 지정된 객체(o)로 변경한다. |

<br/>

**ListIterator예제**

```java
import java.util.*;

public class ListIteratorEx1 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1"); list.add("2"); list.add("3"); list.add("4"); list.add("5");

        ListIterator it = list.listIterator();

        while(it.hasNext()){
            System.out.println(it.next());
        }
        while (it.hasPrevious()){
            System.out.println(it.previous());
        }
    }
}
/* 결과
1	2	3	4	5	5	4	3	2	1
*/
```

<br/>

<br/>

<br/>

## 1.6 Arrays

### 배열의 출력 - toString()

```java
static String toString (boolean [] a)
static String toString (byte [] a)
static String toString (char [] a)
static String toString (short [] a)
static String toString (int [] a)
static String toString (long [] a)
static String toString (float[] a)
static String toString (double [] a)
static String toString (Object [] a)
```

<br/>

<br/>

### 배열의 복사 - copyOf(), copyOfRange()

```java
int[] arr = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr, arr.length); 	// arr2 = [0,1,2,3,4]
int[] arr3 = Arrays.copyOf(arr,3);				// arr3 = [0,1,2]
int[] arr4 = Arrays.copyOf(arr, 7);				// arr4 = [0,1,2,3,4,0,0]
int[] arr5 = Arrays.copyOfRange(arr, 2,4);		// arr5 = [2,3] <- 4는 불포함
int[] arr6=Arrays.copyOfRange(arr, 0,7);		// arr4=[0,1,2,3,4,0,0]
```

<br/>

<br/>

### 배열 채우기 - fill(), setAll()

`fill()`은 배열의 모든 요소를 지정된 값으로 채운다.

`setAll()`은 배열을 채우는데 사용할 **함수형 인터페이스**를 매개변수로 받는다.

```java
int [] arr = new int[5];
Arrays.fill(arr,9);		// arr = [9,9,9,9,9]
Arrays.setAll(arr, () -> (int)(Math.random()*5)+1);	// arr=[1,5,2,1,1]
```

<br/>

<br/>

### 배열의 정렬과 검색 - sort(), binarySearch()

```java
// 정렬 전 결과는 올바르지 않음
int[] arr = {3, 2, 0, 1, 4};
int idx = Arrays.binarySearch(arr,2);	// idx = -5 <- 잘못된 결과

Arrays.sort(arr);	// 배열 arr을 정렬
System.out.println(Arrays.toString(arr));	// [0,1,2,3,4]
int idx = Arrays.binarySearch(arr,2);	// idx = 2 <- 올바른 결과
```

<br/>

<br/>

### 배열의 비교와 출력 - equals(), toString()

**1차원** 배열 - `toString()`, `equals()`

**다차원** 배열 - `deepToString()`, `deepEquals()`

```java
int[] arr = {0,1,2,3,4};
int[][] arr2D = { {11,12}, {21,22} };

System.out.println(Arrays.toString (arr)); // [0, 1, 2, 3, 4]
System. out.println(Arrays.deepToString(arr2D)); // [[11, 12], [21, 22]]
```

<br/>

```java
String[][] str2D = new String [][] { {"aaa","bbb"}, { "AAA", "BBB"} } ;
String[][] str2D2 = new String [][] { {"aaa", "bbb"}, { "AAA", "BBB"} } ;

System.out.println(Arrays.equals(str2D, str2D2));	// false
System.out.println(Arrays.deepEquals(str2D, str2D2)) ; // true
```

<br/>

<br/>

### 배열을 List로 변환 - asList(Object... a)

`asList()`는 배열을 List에 담아서 반환한다. 매개변수의 타입이 가변인수라서 배열 생성 없이 저장할 요소들만 나열하는 것도 가능

```java
List list = Arrays.asList(new Integer[]{1,2,3,4,5});	// list = [1,2,3,4,5]
List list = Arrays.asList(1,2,3,4,5);		// list = [1,2,3,4,5]

list.add(6);	// UnsupportedOperationException 발생
```

`asList()`가 반환한 List의 **크기를 변경할 수 없기**에 추가 또는 삭제가 불가능하고 저장된 내용만 변경 가능

크기를 변경할 수 있는 List가 필요하다면 다음과 같이 하면 됨

```java
List list = new ArrayList(Arrays.asList(1,2,3,4,5));
```

<br/><br/><br/>

## 1.7 Comparator와 Comparable

Comparator와 Comparable은 모두 **컬렉션을 정렬하는데 필요한 메서드를 정의한 인터페이스**이다(정렬 기준을 제공)

Comparable을 구현하고 있는 클래스들은 **같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스**들이다. 

예들들어, Wrapper, String, Date, File클래스가 있고 기본적으로 **오름차순**으로 정렬되도록 구현되어 있다. 

```java
// java.util
public interface Comparator{
    int compare(Object o1, Object o2);	// o1, o2 두 객체를 비교

    
    // Comparator를 구현하는 클래스는 오버라이딩이 필요할 수도 있다는 것을 알리기 위해 재정의한것
    boolean equals(Object obj);			
}


// java.lang
public interface Comparable{
    public int compareTo(Object o);		// 주어진 객체(o)를 자신과 비교
}
```

<br/><br/>

### Integer 클래스의 일부

```java
public final class Integer extends Number implements Comparable{
    ...
    public int compareTo(Object o){
        return compareTo((Integer)o);
    }
    
    public int compareTo(Integer anotherInteger){
        int thisVal = this.value;
        int anotherValue = anotherInteger.value;
        
        // 비교하는 값이 크면 -1, 같으면 0, 작으면 1을 반환
        return (thisVal<anotherValue ? -1 : (thisVal==anthoerValue ? 0 : 1));
    }
}
```

이처럼 Comparable을 구현한 클래스들이 기본적으로 오름차순으로 정렬되어 있지만, 내림차순 혹은 다른 기준에 의해서 정렬되도록 하고 싶을때 Comparator을 구현해서 정렬기준을 제공할 수 있다.

```
Comparable - 기본 정렬기준을 구현하는데 사용
Comparator - 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용
```

<br/><br/>

#### 예제

```java
import java.util.*;
public class ComparatorEx {
    public static void main(String[] args) {
        String[] strArr = {"cat", "Dog", "lion", "tiger"};

        Arrays.sort(strArr);    // String의 Comparable 구현에 의한 정렬
        System.out.println("strArr="+Arrays.toString(strArr));

        
        // public static final Comparator CASE_INSENSITIVE_ORDER
        Arrays.sort(strArr,String.CASE_INSENSITIVE_ORDER); // 대소문자 구분안함
        System.out.println("strArr="+Arrays.toString(strArr));

        Arrays.sort(strArr,new Descending());   // 역순 정렬
        System.out.println("strArr="+Arrays.toString(strArr));


    }
}

class Descending implements Comparator{
    public int compare(Object o1, Object o2) {
        if( o1 instanceof Comparable && o2 instanceof Comparable){
            Comparable c1 = (Comparable)o1;
            Comparable c2 = (Comparable)o2;
            return c1.compareTo(c2) * -1; // -1을 곱해서 기본 정렬방식의 역으로 변경
        }
        return -1;
    }
}
/* 결과
strArr=[Dog, cat, lion, tiger]
strArr=[cat, Dog, lion, tiger]
strArr=[tiger, lion, cat, Dog]
*/
```

Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체(주로 Comparable을 구현한 클래스의 객체)에 구현된 내용에 따라 정렬된다.

```java
static void sort(Object[] a) // 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬
static void sort(Object[] a, Comparator c)	// 지정한 Comparator에 의한 정렬
```

<br/><br/><br/>

## 1.8 HashSet

**HashSet**은 Set인터페이스를 구현한 컬렉션이다.(순서 x, 중복 x)

`add`나 `addAll`메서드로 새로운 요소를 추가할때 중복된 값이 있으면 false를 반환한다.

<br/>

**순서를 유지**하려면, **LinkedHashSet**을 사용해야 한다.

> HashSet은 내부적으로 HashMap을 이용해 만들어졌으며, 해싱(hashing)을 이용해서 구현함

<br/>

#### 생성자

| 생성자                                         | 설명                                                 |
| ---------------------------------------------- | ---------------------------------------------------- |
| HashSet()                                      | HashSet객체를 생성한다                               |
| HashSet(Collection c)                          | 주어진 컬렉션을 포함하는 HashSet객체를 생성한다      |
| HashSet(int initialCapacity)                   | 주어진 값을 초기용량으로하는 HashSet객체를 생성한다. |
| HashSet(int initialCapacity, float loadFactor) | 초기용량과 load factor을 지정하는 생성자             |

> load factor는 컬렉션 클래스에 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것
>
> 이 값을 0.8로 지정하면, 저장공간의 80%가 채워졌을 때 용량이 두 배로 늘어난다. default는 0.75

<br/>

#### 메서드

| 메서드                            | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| boolean add(Object o)             | 새로운 객체를 저장                                           |
| boolean addAll(Collection c)      | 주어진 컬렉션에 저장된 모든 객체들을 추가한다.(합집합)       |
| void clear()                      | 저장된 모든 객체를 삭제한다.                                 |
| Object clone()                    | HashSet을 복제해서 반환한다.(얕은 복사)                      |
| boolean contains(Object o)        | 지정된 객체를 포함하고 있는지 알려준다.                      |
| boolean containsAll(Collection c) | 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다. |
| boolean isEmpty()                 | HashSet이 비어있는지 알려준다.                               |
| Iterator iterator()               | Iterator객체를 반환                                          |
| boolean remove(Object o)          | 지정된 객체를 HashSet에서 삭제한다.                          |
| boolean removeAll(Collection c)   | 컬렉션에 저장된 객체와  Collection의 차집합                  |
| boolean retainAll(Collection c)   | 컬렉션에 저장된 객체와  Collection의 교집합                  |
| int size()                        | 저장된 객체의 개수를 반환한다.                               |
| Object[] toArray()                | 저장된 객체들을 객체배열의 형태로 반환한다.                  |
| Object[] toArray(Object[] a)      | 저장된 객체들을 주어진 객체배열(a)에 담는다.                 |

<br/>

<br/>

**예제1**

```java
import java.util.*;

public class HashSetEx1 {
    public static void main(String[] args) {
        Object[] objArr = {"1", Integer.valueOf(1), "2","2","3","3","4","4","4"};
        Set set = new HashSet();

        for(int i=0; i< objArr.length;i++){
            set.add(objArr[i]);
        }
        System.out.println(set);
    }
}
/* 실행결과
[1, 1, 2, 3 ,4]
*/
```

결과를 보면 알 수 있듯이 add메서드는 객체를 추가할 때 HashSet에 이미 같은 객체가 있으면 중복으로 간주하고 저장하지 않는다. 그리고 false를 반환한다.

'1'이 두 번 출력되었는데, 둘 중 하나는 **String 인스턴스**이고 다른 하나는 **Integer인스턴스**로 **서로 다른 객체이므로 중복으로 간주하지 않는다**.  

<br>
<br>

**예제2**

1~50 사이의 숫자 중에서 25개를 골라서 5X5 크기의 빙고판을 만드는 예제

```java
import java.util.*;

public class Bingo {
    public static void main(String[] args) {
        Set set = new HashSet();
        int[][] board = new int[5][5];

        for (int i = 0; set.size() < 25; i++) {
            set.add((int) (Math.random() * 50) + 1 + "");
        }


        Iterator it = set.iterator();


        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                board[i][j] = Integer.parseInt((String) it.next());
                System.out.print((board[i][j] < 10 ? "  " : " ") + board[i][j]);
            }
            System.out.println();
        }
    }
}
/* 결과
 23 24 46 47 25
 49 28 30 31 32
 11 12 35 14 15
 39 18 19  1  2
  5  8 41 42 21
 */
```

위 코드에서 `next()`는 Object타입이므로 형변환해서 원래의 타입(String)으로 되돌려 놓음

<br/>
<br/>

**에제3**

```java
import java.util.*;

public class HashSetEx3 {
    public static void main(String[] args) {
        HashSet set = new HashSet();

        set.add("abc");
        set.add("abc");
        set.add(new Person("David", 10));
        set.add(new Person("David", 10));

        System.out.println(set); // [abc, David:10, David:10]
        
    }
}


class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String toString() {
        return name + ":" + age;
    }
}
```

위 코드는 이름과 나이가 같으면 같은 사람으로 인식하도록 하려는 의도로 작성했는데 실행결과를 보면 두 인스턴스의 name과 age가 같은에도 불구하고 서로 다른 것으로 인식하여 David:10이 두 번 출력되었다.

<br/>
<br/>

HashSet의 `add메서드`는 새로운 요소를 추가하기 전에 중복을 확인하기 위해 추가하려는 요소의 `equals()`와 `hashCode()`를 호출하기 때문에 `equals()`와 `hashCode()`를 목적에 맞게 오버라이딩 해야한다. 

그래서 Person클래스에서 두 인스턴스의 name과 age가 서로 같으면 true를 반환하도록 `equals()`를 오버라이딩함

`hashCode()`는 String클래스의 `hashCode()`를 이용해서 구현함

```java
class Person{
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public boolean equals(Object obj){
        if(obj instanceof Person){
            Person tmp = (Person)obj;
            return name.equals(tmp.name) &&  age==tmp.age;
        }
        return false;
    }

    public int hashCode() {
        return (name+age).hashCode();
    }

    public String toString() {
        return name + ":" + age;
    }
}
```

위의 코드를 JDK1.8부터 추가된 **java.util.Objects**클래스의 `hash()`를 이용해서 작성하는 것을 추천

```java
public int hashCode{
    return Objects.hash(name,age); // int hash(Objects... values)
}
```

<br/>
<br/>

#### 오버라이딩을 통해 작성된 hashCode()는 다음의 세 가지 조건을 만족해야 한다.

1. 실행중인 애플리케이션 내의 **동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int값을 반환**해야한다. 하지만, 실행시마다 동일한 int값을 반환할 필요는 없다(단, equals메서드의 구현에 사용된 멤버변수의 값이 바뀌지 않았다고 가정)

   ```java
   Person2 p = new Person2("David", 10);
   
   
   // hashCode1과 hashCode2는 일치해야함
   int hashCode1 = p.hashCode();
   int hashCode2 = p.hashCode();
   
   // 멤버변수 age를 변경한 후 hashCode는 달라도 된다.
   p.age = 20;
   int hashCode3 = p.hashCode();
   ```

<br/>

2. equals메서드를 이용한 비교에 의해서 **true를 얻은 두 객체**에 대해 각각 **hashCode()를 호출해서 얻은 결과는 반드시 같아야 한다.**

<br/>

3. **equals메서드**를 호출했을 때 **false를 반환하는 두 객체**는 **hashCode() 호출에 대해 같은 int값을 반환하는 경우가 있어도 괜찮**지만, hashing을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.

> 서로 다른 객체에 대해서 해시코드값이 중복되는 경우가 많아질수록 해싱을 사용하는 Hashtable, HashMap과 같은 컬렉션의 검색속도가 떨어진다.

<br/>
<br/>

**예제4**

HashSet에 저장된 객체들의 합집합(addAll), 교집합(retainAll), 차집합(removeAll)을 직접 구하기

```java
import java.util.*;

public class HashSetEx5 {
    public static void main(String[] args) {
        HashSet setA = new HashSet();
        HashSet setB = new HashSet();
        HashSet setHab = new HashSet();
        HashSet setKyo = new HashSet();
        HashSet setCha = new HashSet();

        setA.add("1");  setA.add("2");  setA.add("3");
        setA.add("4");  setA.add("5");
        System.out.println("A = "+setA);

        setB.add("4");   setB.add("5");   setB.add("6");
        setB.add("7");   setB.add("8");
        System.out.println("B = "+setB);

        
        
        // A ∩ B
        Iterator it = setB.iterator();
        while(it.hasNext()){
            Object tmp = it.next();
            if(setA.contains(tmp)){
                setKyo.add(tmp);
            }
        }
        
        // A - B
        it = setA.iterator();
        while(it.hasNext()){
            Object tmp = it.next();
            if(!setB.contains(tmp)){
                setCha.add(tmp);
            }
        }
        
        // A U B
        it = setA.iterator();
        while(it.hasNext()){
            setHab.add(it.next());
        }
        it = setB.iterator();
        while(it.hasNext()){
            setHab.add(it.next());
        }

        System.out.println("A ∩ B = "+setKyo);
        System.out.println("A U B = "+setHab);
        System.out.println("A - B"+setCha);
    }
}
```

<br/>
<br/>
<br/>

## 1.9 TreeSet

TreeSet은 **이진 탐색 트리**(Binary Search Tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스이다. 

TreeSet은 이진 탐색 트리의 성능을 향상시킨 **Red-Black tree**로 구현되어 있다.

```java
class TreeNode{
    TreeNode left;	// 왼쪽 자식노드
    Object element;	// 객체를 저장하기 위한 참조변수
    TreeNode right; // 오른쪽 자식노드
}
```

<br/>
<br/>

#### 이진 탐색 트리(binary serach tree)

- 모든 노드는 최대 두 개의 자식노드를 가질 수 있다.
- 왼쪽 자식노드의 값 < 부모노드의 값  && 오른쪽 자식노드의 값 > 부모노드의 값
- 노드의 추가 삭제에 시간이 걸린다.(순차적으로 저장하지 않으므로)
- 검색(범위검색)과 정렬에 유리하다.
- 중복된 값을 저장하지 못한다.

<br/>

#### 생성자

| 생성자                   | 설명                                                       |
| ------------------------ | ---------------------------------------------------------- |
| TreeSet()                | 기본생성자                                                 |
| TreeSet(Collection c)    | 주어진 컬렉션을 저장하는 TreeSet을 생성                    |
| TreeSet(Comparator comp) | 주어진 정렬조건으로 정렬하는 TreeSet을 생성                |
| TreeSet(SortedSet s)     | 주어진 SortedSet을 구현한 컬렉션을 저장하는 TreeSet을 생성 |

<br/>

#### 메서드

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean add(Object o)<br />boolean addAll(Collection c)      | 지정된 객체(o) 또는 Collection (c)의 객체들을 Collection에 추가 |
| Object ceiling(Object o)                                     | 지정된 객체와 같은 객체를 반환<br />없으면 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환, 없으면 null |
| Object floor(Object o)                                       | 지정된 객체와 같은 객체를 반환.<br />없으면 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환, 없으면 null |
| void clear()                                                 | 지정된 모든 객체를 삭제한다.                                 |
| Object clone()                                               | TreeSet을 복제하여 반환한다.                                 |
| Comparator comparator()                                      | TreeSe의 정렬기준(Comparator)를 반환한다.                    |
| boolean contains(Object o)<br />boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection의 객체들이 포함되어 있는지 확인한다. |
| NavigableSet descendingSet()                                 | TreeSet에 저장된 요소들을 역순으로 정렬해서 반환             |
| Object first()                                               | 정렬된 순서에서 첫 번째 객체를 반환한다.                     |
| Object last()                                                | 정렬된 순서에서 마지막 객체를 반환한다.                      |
| Object higher(Object o)                                      | 지정된 객체보다 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환, 없으면 null |
| Object lower(Object o)                                       | 지정된 객체보다 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환, 없으면 null |
| Object[] toArray()                                           | 지정된 객체를 객체배열로 반환                                |
| Object[] toArray(Object[] a)                                 | 지정된 객체를 주어진 객체배열에 저장하여 반환                |
| boolean isEmpty()                                            | TreeSet이 비어있는지 확인                                    |
| Iterator iterator()                                          | TreeSet의 Iterator를 반환                                    |
| Object pollFirst()                                           | TreeSet의 첫 번째 요소(제일 작은 값의 객체)를 제거 후 반환   |
| Object pollLast()                                            | TreeSet의 마지막 번째 요소(제일 큰 값의 객체)를 제거 후 반환 |
| boolean remove(Obejct o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean retainAll(Collection c)                              | 교집합                                                       |
| int size()                                                   | 저장된 객체의 개수를 반환                                    |
| Spliterator spliterator()                                    | TreeSet의 spliterator를 반환                                 |

<br/>

#### 범위 검색 메서드 - subSet(), headSet(), tailSet()

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| SortedSet headSet(Object toElement)                          | 지정된 객체보다 작은 값의 객체들을 반환한다.                 |
| SortedSet tailSet(Object fromElement)                        | 지정된 객체보다 큰 값의 객체들을 반환한다.                   |
| SortedSet subSet(Object fromElement, Object to Element)      | 범위 검색(fromElement와 toElement사이)의 결과를 반환한다.<br />(끝 범위인 toElement는 범위에 포함되지 않음) |
| NavigableSet headSet(Object toElement, <br />booelan inclusive) | 지정된 객체보다 작은 값의 객체들을 반환<br />inclusive가 true이면, 같은 값의 객체도 포함 |
| NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) | 범위검색(fromElement와 toElement사이)의 결과를 번환한다. inclusive가 각각 true면 그 값을 포함 |

<br/>
<br/>

#### 예제1 - subSet메서드

```java
import java.util.*;
public class TreeSetEx1 {
    public static void main(String[] args) {
        TreeSet set = new TreeSet();

        String from = "b";
        String to = "d";

        set.add("abc");         set.add("alien");    set.add("bat");
        set.add("car");         set.add("Car");      set.add("disc");
        set.add("dance");       set.add("dZZZZ");    set.add("dzzzz");
        set.add("elephant");    set.add("elevator"); set.add("fan");
        set.add("flower");

        System.out.println(set);
        System.out.println("range serach : from "+from+" to "+to);
        System.out.println("result1 : "+ set.subSet(from,to));
        System.out.println("result2 : "+ set.subSet(from,to + "zzz"));

    }
}
```

**결과**

```
[Car, abc, alien, bat, car, dZZZZ, dance, disc, dzzzz, elephant, elevator, fan, flower]
range serach : from b to d
result1 : [bat, car]
result2 : [bat, car, dZZZZ, dance, disc]
```

`subSet(from,to)`을 이용해서 범위검색을 할 때 시작범위는 포함 o, 끝 범위는 포함X

<br/>
<br/>

#### 예제 2 - headSet, tailSet 메서드

```java
import java.util.*;

public class TreeSetEx2 {
    public static void main(String[] args) {
        TreeSet set = new TreeSet<>();
        int[] score = {80,95,50,35,45,65,10,100};

        for(int i=0; i<score.length;i++)
            set.add(Integer.valueOf(score[i]));

        System.out.println("50보다 작은 값 : "+set.headSet(50));
        System.out.println("50보다 크거나 같은 값 : "+set.tailSet(50));
    }
}
```

**결과**

```
50보다 작은 값 : [10, 35, 45]
50보다 큰 값 : [50, 65, 80, 95, 100]
```

![image-20250115033906956](https://github.com/user-attachments/assets/986c841c-4ec4-4757-91ef-a2b219510633)

<br/>
<br/>
<br/>

## 1.10 HashMap과 Hashtable

> Hashtable은 HashMap의 구 버전으로 HashMap의 사용을 권함

### HashMap

- Hashing 기법으로 데이터를 저장, 데이터가 많아도 검색이 빠름

- Entry라는 내부 클래스를 정의하고, 다시 Entry타입의 배열을 선언하고 있다.

  ```java
  public class HashMap extends AbstractMap implements map, Cloneable, Serializable{
      trasient Entry[] table;
      		...
      static class Entry implements Map.Entry{ // Map.Entry는 Map인터페이스에 정의된 static inner interface
          final Object key;
          Object value;
      }
  }
  ```

  - key, value는 **서로 관련된 값**이기에 각각의 배열로 선언하는 것보다는 **하나의 클래스로 정의해서 하나의 배열로 다루**는 것이 **데이터 무결성**(integrity)적인 측면에서 더 바람직하기에 

  - 비객체지향적인 코드

    ```java
    Object[] key;
    Object[] value;
    ```

<br/>
<br/>

### HashMap의 생성자와 메서드

| 생성자/메서드                                                | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| HashMap()                                                    | HashMap 객체를 생성                                          |
| HashMap(int initialCapacity)                                 | 지정된 값을 초기용량으로 하는 HashMap객체를 생성             |
| HashMap(int initialCapacity, float loadFactor)               | 지정된 초기용량과 load factor의 HashMap객체를 생성           |
| HashMap(Map m)                                               | 지정된 Map의 모든 요소를 포함하는 HashMap을 생성             |
| void clear()                                                 | HashMap에 저장된 모든 객체를 제거                            |
| Object clone()                                               | 현재 HashMap을 복제해서 반환                                 |
| boolean containsKey(Object key)                              | HashMap에 지정된 키가 포함되어있는지 알려준다.               |
| boolean containsValue(Object value)                          | HashMap에 지정된 값이 포함되어있는지 알려준다.               |
| Set entrySet()                                               | HashMap에 저장된 키와 값을 Entry(ket와 값의 결합)의 형태로 Set에 저장해서 반환 |
| Object get(Object key)                                       | 지정된 key의 값을 반환 못찾으면 null반환                     |
| Object getOrDefault(Object key, Object defaultValue)         | 지정된 key의 값을 반환, key를 못찾으면 defaultVaule로 지정된 객체 반환 |
| boolean isEmpty()                                            | HashMap이 비어있는지 알려준다.                               |
| Set keySet()                                                 | HashMap에 저장된 모든 키가 저장된 Set반환                    |
| Object put(Object key, Object value)                         | 지정된 키와 값을 HashMap에 저장                              |
| void putAll(Map m)                                           | Map에 저장된 모든 요소를 HashMap에 저장                      |
| Object remove(Object key)                                    | HashMap에서 지정된 키로 지정된 값(객체)를 제거               |
| Object replace(Object key, Object value)                     | 지정된 키의 값을 지정된 객체로 대체                          |
| boolean replace(Object key, Object oldValue, Object newValue) | 지정된 키와 객체(oldValue)가 모두 일치하는 경우에만 새로운 객체(newValue)로 대체 |
| int size()                                                   | HashMap에 저장된 요소의 개수를 반환                          |
| Collection values()                                          | HashMap에 저장된 모든 값을 컬렉션 형태로 반환                |

<br/>
<br/>

### 예제1

```java
import java.util.*;

public class HashMapEx1 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("myId", "1234");
        map.put("asdf", "1111");
        map.put("asdf", "1234");	// 중복된 키로 이미 존재하는 기존의 값을 덮어씀

        Scanner s = new Scanner(System.in);

        while (true) {
            System.out.println("id와 password를 입력해주세요.");
            System.out.print("id :");
            String id = s.nextLine().trim();

            System.out.print("password :");
            String password = s.nextLine().trim();
            System.out.println();

            if (!map.containsKey(id)) {
                System.out.println("입력하신 id는 존재하지 않습니다. 다시 입력해주세요.");
                continue;
            }
            if (!map.get(id).equals(password)) {
                System.out.println("비밀번호가 일치하지 않습니다. 다시 입력해주세요.");
            } else {
                System.out.println("id와 비밀번호가 일치합니다.");
                break;
            }
        }
    }
}
```

**결과**

```
id와 password를 입력해주세요.
id :asdf
password :1111

비밀번호가 일치하지 않습니다. 다시 입력해주세요.
id와 password를 입력해주세요.
id :asdf
password :1234

id와 비밀번호가 일치합니다.
```

> Hashtable은 key나 value에 null을 허용하지 않지만, HashMap은 허용한다.
>
> > ex) HashMap은 `map.put(null, null)`, `map.get(null)` 가능 

<br/>
<br/>

### 예제2

키와 값을 읽어오기 예제

- `entrySet()`을 이용
- `keySet()`이나 `values()`를 이용

```java
import java.util.*;

public class HashMapEx2 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("김자바", Integer.valueOf(100));
        map.put("이자바", Integer.valueOf(100));
        map.put("강자바", Integer.valueOf(80));
        map.put("안자바", Integer.valueOf(90));

        
        // entrySet() 이용
        Set set = map.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();
            System.out.println("이름 : " + e.getKey() + ", 점수 : " + e.getValue());
        }

        
        // keySet() 이용
        set = map.keySet();
        System.out.println("참가자 명단 : " + set);

        
        // values() 이용
        Collection values = map.values();
        it = values.iterator();
        int total = 0;
        while (it.hasNext()) {
            Integer i = (Integer) it.next();
            total += i.intValue();
        }

        System.out.println("총점 : " + total);
        System.out.println("평균 : " + (float) total / set.size());
        System.out.println("최고점수 : " + Collections.max(values));
        System.out.println("최저점수 : " + Collections.min(values));
    }
}
```

<br/>
<br/>

### 예제3

HashMap은 데이터를 키와 값을 모두 Object타입으로 저장하기에 HashMap타입의 value로 HashMap을 다시 저장가능

이렇게 함으로써 하나의 키에 다시 복수의 데이터를 저장할 수있다.

> 2차원 배열 느낌의 예제

```java
import java.util.*;

public class HashMapEx3 {
    static HashMap phoneBook = new HashMap();

    static void addGroup(String groupName) {
        if (!phoneBook.containsKey(groupName))
            phoneBook.put(groupName, new HashMap());
    }

    static void addPhoneNo(String groupName, String name, String tel) {
        addGroup(groupName);
        HashMap group = (HashMap) phoneBook.get(groupName);
        group.put(tel, name);   // 이름은 중복될 수 있으니 전화번호를 key로
    }

    static void addPhoneNo(String name, String tel) {
        addPhoneNo("기타", name, tel);
    }

    static void printList() {
        Set set = phoneBook.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();

            Set subSet = ((HashMap) e.getValue()).entrySet();
            Iterator subit = subSet.iterator();

            System.out.println(" * " + e.getKey() + "[" + subSet.size() + "]");

            while (subit.hasNext()) {
                Map.Entry subE = (Map.Entry) subit.next();
                String telNo = (String) subE.getKey();
                String name = (String) subE.getValue();
                System.out.println(name + " " + telNo);
            }
            System.out.println();
        }
    }


    public static void main(String[] args) {
        addPhoneNo("친구", "이자바", "010-111-1111");
        addPhoneNo("친구", "김자바", "010-222-2222");
        addPhoneNo("친구", "김자바", "010-333-3333");
        addPhoneNo("회사", "김대리", "010-444-4444");
        addPhoneNo("회사", "김대리", "010-555-5555");
        addPhoneNo("회사", "박대리", "010-666-6666");
        addPhoneNo("회사", "이과장", "010-777-7777");
        addPhoneNo("세탁", "010-888-8888");

        printList();
    }

}
```

**결과**

```
 * 기타[1]
세탁 010-888-8888

 * 친구[3]
이자바 010-111-1111
김자바 010-222-2222
김자바 010-333-3333

 * 회사[4]
이과장 010-777-7777
김대리 010-444-4444
김대리 010-555-5555
박대리 010-666-6666
```

<br/>
<br/>

### 예제4

문자열 배열에 담긴 문자열을 하나씩 읽어서 HashMap에 키로 저장하고 값으로 1을 저장한다.

HashMap에 같은 문자열이 키로 저장되어 있는지 containsKey()로 확인하여 이미 저장되어 있는 문자열이면 값을 1증가시킨다.

그리고 그 결과를 printBar()를 이용해 그래프로 표현하는 예제

> 결과를 보면 HashMap과 같이 해싱을 구현한 컬렉션 클래스들은 저장순서를 유자ㅣ하지 안흔ㄴ 다는 것을 알 수 있다.

```java
import java.util.*;

public class HashMapEx4 {
    public static void main(String[] args) {
        String[] data = {"A", "K", "A", "K", "D", "K", "A", "K", "K", "K", "Z", "D"};

        HashMap map = new HashMap();

        for (int i = 0; i < data.length; i++) {
            if (map.containsKey(data[i])) {
                Integer value = (Integer) map.get(data[i]);
                map.put(data[i], Integer.valueOf(value.intValue() + 1));
            } else {
                map.put(data[i], Integer.valueOf(1));
            }
        }

        Iterator it = map.entrySet().iterator();

        while(it.hasNext()){
            Map.Entry entry = (Map.Entry)it.next();
            int value = (Integer) entry.getValue();
            System.out.println(entry.getKey() + " : "+ printBar('#', value) + " " +value);
        }
    }

    public static String printBar(char ch, int value) {
        char[] bar = new char[value];

        for (int i = 0; i < bar.length; i++)
            bar[i] = ch;

        return new String(bar); // String(char[] chArr)
    }
}
```

**결과**

```
A : ### 3
D : ## 2
Z : # 1
K : ###### 6
```

<br/>
<br/>
<br/>

## 1.11 TreeMap

이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다

TreeSet처럼, 데이터를 정렬(키)해서 저장하기 때문에 저장시간이 길다. (TreeSet은 TreeMap을 이용해서 구현되어 있음)

다수의 데이터에서 개별적인 검색은 TreeMap보다 HashMap이 빠르다. 

Map이 필요할 때 주로 **HashMap**을 사용하고, 정렬이나 범위검색이 필요한 경우에 **TreeMap**을 사용

<br/>
<br/>

### 메서드

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TreeMap()                                                    | TreeMap객체를 생성                                           |
| TreeMap(Comparator c)                                        | 지정된 Comparator를 기준으로 정렬하는 TreeMap객체를 생성     |
| TreeMap(Map m)                                               | 주어진 Map에 저장된 모든 요소를 포함하는 TreeMap을 생성      |
| TreeMap(SortedMap m)                                         | 주어진 SortedMap에 저장된 모든 요소를 포함하는 TreeMap을 생성 |
| Map.Entry ceilingEntry(Object key)                           | 지정된 key와 일치하거나 큰 것중 제일 작은 것의 Map.Entry를 반환, 없으면 null |
| Object ceilingKey(Object key)                                | 지정된 key와 일치하거나 큰 것중 제일 작은 것의 키를 반환, 없으면 null |
| void clear()                                                 | TreeMap에 저장된 모든 객체를 제거                            |
| Object clone()                                               | 현재 TreeMap을 복제해서 반환                                 |
| Comparator comparator()                                      | TreeMap의 정렬기준이 되는 Comparator를 반환 <br />Comparator가 지정되지 않았다면 null을 반환 |
| boolean containsKey(Object key)                              | TreeMap에 지정된 key가 포함되어있는지                        |
| boolean containsValue(Object value)                          | TreeMap에 지정된 value가 포함되어있는지                      |
| NavigableSet descendingKeySet()                              | TreeMap에 지정된 키를 역순으로 정렬해서 NavigableSet에 담아서 반환 |
| Set entrySet()                                               | TreeMap에 저장된 키와 값을 entry(키와 값의 결합)의 형태로 SET에 저장해서 반환 |
| Map.Entry firstEntry()                                       | TreeMap에 저장된 첫번째(가장 작은) Map.Entry를 반환          |
| Object firstKey()                                            | TreeMap에 저장된 첫번째 (가장 작은) key를 반환               |
| Map.Entry floorEntry(Object key)                             | 지정된 key와 일치하거나 작은 거중에서 제일 큰 키의 Map.Entry를 반환, 없으면 null |
| Object floorKey(Object key)                                  | 지정된 key와 일치하거나 작은 거중에서 제일 큰 키를 반환, 없으면 null |
| Object get(Object key)                                       | 지정된 key의 값을 반환                                       |
| SortedMap headMap(Object toKey)                              | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환(toKey는 미포함) |
| NavigableMap headMap(Object toKey, boolean inclusive)        | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환. inclusive의 값이 true면 toKey도 포함 |
| Map.Entry higherEntry(Object key)                            | 지정된 key보다 큰 키 중에서 제일 작은 키의 Map.Entry를 반환, 없으면 null |
| Object higherKey(Object key)                                 | 지정된 key보다 큰 키 중에서 제일 작은 키를 반환, 없으면 null |
| boolean isEmpty()                                            | TreeMap이 비었는지                                           |
| Set keySet()                                                 | TreeMap에 저장된 모든 키가 저장된 Set을 반환                 |
| Map.Entry lastEntry()                                        | TreeMap에 저장된 마지막 Map.Entry를 반환                     |
| Object lastKey()                                             | TreeMap에 저장된 마지막 키를 반환                            |
| Map.Entry lowerEntry(Object key)                             | 지정된 키보다 작은 키중 제일 큰 키의 쌍(Map.Entry)를 반환, 없으면 null |
| Object lowerKey(Object key)                                  | 지정된 키보다 작은 키중에서 제일 큰 키를 반환, 없으면 null   |
| NavigableSet navigableKeySet()                               | TreeMap의 모든 키가 담긴 NavigableSet을 반환                 |
| Map.Entry pollFirstEntry()                                   | TreeMap에서 제일 작은 키를 제거하면서 반환                   |
| Map.Entry pollLastEntry()                                    | TreeMap에서 제일 큰 키를 제거하면서 반환                     |
| Object put(Object key, Object value)                         | 지정된 key,value를 TreeMap에 저장                            |
| void putAll(Map map)                                         | Map에 저장된 모든 요소를 TreeMap에 저장                      |
| Object remove(Object key)                                    | TreeMap에서 지정된 키로 저장된 값을 제거                     |
| Object replace(Object k, Object v)                           | 기존의 키의 값을 지정된 값으로 변경                          |
| boolean replace(Object key, Object oldvalue, Object new value) | 기존의 키와 값을 새로운 값으로 변경<br />단, 기존의 갑소가 지정된 값이 일치해야함 |
| int size()                                                   | TreeMap에 저장된 요소의 개수를 반환                          |
| NavigableMap subMap(Object fromKey, boolean fromInclusive, Object toKey, boolean toInclusive) | 지정된 두 개의 키 사이에 있는 모든 요소들이 담긴 NavigableMap을 반환. Inclusvie 가 true면 각각 범위에 포함 |
| SortedMap subMap(Object fromKey, Object toKey)               | 지정된 두 개의 키 사이에 있는 모든 요소들이 담긴 SortedMap을 반환(toKey는 포함x) |
| SortedMap tailMap(Object fromKey)                            | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴  SortedMap을 반환 |
| NavigableMap tailMap(Object fromKey, boolean inclusive)      | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴 NavigableMap을 반환. inclusive가 true면 fromKey포함 |
| Collection values()                                          | TreeMap에 저장된 모든 값을 컬렉션의 형태로 반환              |

<br/>
<br/>

### 예제

TreeMap을 사용했기에 키가 오름차순으로 정렬됨

그리거 Comparator를 구현한 클래스와 Collections.sort를 이용해서 값에 대한 내림차순 정렬함

```java
import java.util.*;

public class TreeMapEx1 {
    public static void main(String[] args) {
        String[] data = {"A", "K", "A", "K", "D", "K", "A", "K", "K", "K", "Z", "D"};

        TreeMap map = new TreeMap();

        for (int i = 0; i < data.length; i++) {
            if (map.containsKey(data[i])) {
                Integer value = (Integer) map.get(data[i]);
                map.put(data[i], Integer.valueOf(value.intValue() + 1));
            } else {
                map.put(data[i], Integer.valueOf(1));
            }
        }

        System.out.println("= 기본정렬 =");
        Iterator it = map.entrySet().iterator();

        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = (Integer) entry.getValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value) + " " + value);
        }
        System.out.println();

        // map을 ArrayList로 변환한 다음에 Collections.sort()로 정렬
        Set set = map.entrySet();
        List list = new ArrayList(set); // ArrayList(Collection c)

        // static void sort(List list, Comparator c)
        Collections.sort(list, new ValueComparator());

        it = list.iterator();

        System.out.println("= 값의 크기가 큰 순서대로 정렬 = ");
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = (Integer) entry.getValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value) + " " + value);
        }

    }


    static class ValueComparator implements Comparator {
        @Override
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Map.Entry && o2 instanceof Map.Entry) {
                Map.Entry e1 = (Map.Entry) o1;
                Map.Entry e2 = (Map.Entry) o2;

                int v1 = (Integer) e1.getValue();
                int v2 = (Integer) e2.getValue();
                return v2 - v1;
            }
            return -1;
        }
    }

    public static String printBar(char ch, int value) {
        char[] bar = new char[value];

        for (int i = 0; i < bar.length; i++)
            bar[i] = ch;
        return new String(bar); // String(char[] chArr)
    }
}

```

**결과**

```
= 기본정렬 =
A : ### 3
D : ## 2
K : ###### 6
Z : # 1

= 값의 크기가 큰 순서대로 정렬 = 
K : ###### 6
A : ### 3
D : ## 2
Z : # 1
```

<br/>
<br/>
<br/>

## 1.12 Properties

HashMap의 구버전인 Hashtable을 상속받아 구현한 것으로 key와 value를 (String, String)로 저장하는 컬렉션 클래스이다.

주로 애플리케이션의 환경설정과 관련된 속성(property)을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.

### 메서드

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Properties()                                                 | Properites객체를 생성한다.                                   |
| Properties(Properties defaults)                              | 지정된 Properties에 저장된 목록을 가진 Properties 객체를 생성한다. |
| String getProperty(String key)                               | 지정된 키의 값을 반환한다.                                   |
| String getProperty(String key, String defaultValue)          | 지정된 키의 값을 반환한다. 키를 찾지 못하면 defaultValue 반환 |
| void list(PrintStream out)                                   | 지정된 PrintStream에 저장된 목록을 출력한다.                 |
| void list(PrintWriter out)                                   | 지정된 PrintWriter에 저장된 목록을 출력한다.                 |
| void load(InputStream inStream)                              | 지정된 InputStream으로부터 목록을 읽어서 저장한다.           |
| void load(Reader reader)                                     | 지정된 Reader으로부터 목록을 읽어서 저장한다.                |
| void loadFromXML(InputStream in)                             | 지정된 InputStream으로부터 XML문서를 읽어서, XML문서에 저장된 목록을 읽어다 담는다.(load & store) |
| Enumeration propertyNames()                                  | 목록의 모든 키가 담긴 Enumeration을 반환한다.                |
| void save(OutputStream out, String hedaer)                   | deprecated되었음, store()를 사용하자                         |
| Object setProperty(String key, String value)                 | 지정된 키와 값을 저장한다.                                   |
| void store(OutputStream out, String comments)                | 저장된 목록을 지정된 OutputStream에 출력(저장)한다.<br />comments는 목록에 대한 주석으로 저장된다. |
| void store(Writer wirter, String comments)                   | 저장된 목록을 지정된 Writer에 출력(저장)한다.<br />comments는 목록에 대한 주석으로 저장된다. |
| void storeToXML(OutputStream os, String comment)             | 저장된 목록을 지정된 출력스트림에 XML문서로 출력(저장)한다.<br />comments는 목록에 대한 주석으로 저장된다. |
| void storeToXML(OutputStream os, String comment, String encoding) | 저장된 목록을 지정된 출력스트림에 해당 인코딩의 XML문서로 출력(저장)한다.<br />comments는 목록에 대한 주석으로 저장된다. |
| Set stringPropertyNames()                                    | Properties에 저장되어 있는 모든 키를 Set에 담아서 반환한다.  |

<br/>
<br/>

### 예제1

```java
import java.util.*;


public class PropertiesEx1 {
    public static void main(String[] args) {
        Properties prop = new Properties();

        prop.setProperty("timeout", "30");
        prop.setProperty("language", "kr");
        prop.setProperty("size", "10");
        prop.setProperty("capacity", "10");

        Enumeration e = prop.propertyNames();


        while (e.hasMoreElements()) {
            String element = (String) e.nextElement();
            System.out.println(element + "=" + prop.getProperty(element));
        }
        System.out.println();
        prop.setProperty("size", "20");
        System.out.println("size=" + prop.getProperty("size"));
        System.out.println("capacity=" + prop.getProperty("capacity", "20"));
        System.out.println("loadfactor=" + prop.getProperty("loadfactor", "0.75"));

        System.out.println(prop);   // prop에 저장된 요소들을 출력
        prop.list(System.out);  // prop에 지정된 요소들을 화면(System.out)에 출력한다.
    }
}
```

**결과**

- 데이터를 저장하는데 사용되는 `Object setProperty(String key, String value)`는 단순히 Hashtable의 put메서드를 호출할 뿐이다. 그리고 기존에 같은 키로 저장된 값이 있는 경우 그값을 Object타입으로 반환, 없으면 null
- Properties는 컬렉션프레임웍 이전의 구버전이므로 Iterator가 아닌 **Enumeration**을 사용한다.
- list메서드를 이용하면 Properties에 저장된 모든 데이터를 화면또는 파일에 편하게 출력가능

```
capacity=10
size=10
timeout=30
language=kr

size=20
capacity=10
loadfactor=0.75			<- loadfactor라는 키가 없기 때문에 디폴트 값으로 지정한 0.85가 출력됨
{size=20, language=kr, timeout=30, capacity=10}
-- listing properties --
size=20
language=kr
timeout=30
capacity=10
```

<br/>
<br/>

### 예제2

```java
import java.util.*;
import java.io.*;

public class PropertiesEx2 {
    public static void main(String[] args) {

        Properties prop = new Properties();

        String inputFIle = "input.txt";
        try{
            prop.load(new FileInputStream(inputFIle));
        }catch (IOException e){
            System.out.println("지정된 파일을 찾을 수 없습니다.");
            System.exit(0);
        }

        String name = prop.getProperty("name");
        String[] data = prop.getProperty("data").split(",");
        int max = 0, min = 0;
        int sum = 0;

        for(int i=0; i<data.length; i++){
            int intValue = Integer.parseInt(data[i]);
            if(i==0) max = min = intValue;

            if(max<intValue)
                max = intValue;
            else if(min> intValue)
                min = intValue;

            sum += intValue;
        }
        System.out.println("이름 : "+name);
        System.out.println("최댓값 :"+max);
        System.out.println("최솟값 :"+min);
        System.out.println("합계 :"+sum);
        System.out.println("평균 :"+ (float)sum/data.length);
    }
}
```

**input.txt**

- 외부 파일의 형식
  - 라인단위로 키와 값이 `=`로 연결된 형태여야함
  - 주석라인은 첫 번째 문자가 `#`이어야 한다.
  - 정해진 규칙대로만 파일을 작성하면 `load()`를 호출하는 것만으로 쉽게 데이터를 읽어 올 수 있음

```
# 이것은 주석입니다.
# 여러 줄도 가능하고요.
name=Seong Namkung
data=9,1,5,2,8,13,26,11,35,1
```

**결과**

```
이름 : Seong Namkung
최댓값 :35
최솟값 :1
합계 :111
평균 :11.1
```

<br/>
<br/>

### 예제3

```java
import java.util.*;
import java.io.*;

public class PropertiesEx3 {
    public static void main(String[] args) {
        Properties prop = new Properties();

        prop.setProperty("timeout", "30");
        prop.setProperty("language", "한글");
        prop.setProperty("size", "10");
        prop.setProperty("capacity", "10");

        try {
            prop.store(new FileOutputStream("output.txt"), "Properties Example");
            prop.storeToXML(new FileOutputStream("output.xml"), "Properties Example");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 결과

Properties에 저장된 데이터를 `store()`와 `storeToXML()`을 이용해서 파일로 저장하는 예제

| 메서드         | 저장 형식   | 기본 인코딩 | 한글 처리 방식                       |
| -------------- | ----------- | ----------- | ------------------------------------ |
| `store()`      | 텍스트 파일 | ISO-8859-1  | 유니코드 이스케이프(`\uXXXX`)로 변환 |
| `storeToXML()` | XML 파일    | UTF-8       | 한글이 그대로 저장                   |

**output.txt**

```
#Properties Example
#Mon Jan 20 04:02:42 KST 2025
capacity=10
language=\uD55C\uAE00		<- 한글이 unicode로 바뀌어있다.
size=10
timeout=30
```

**output.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
<comment>Properties Example</comment>
<entry key="size">10</entry>
<entry key="language">한글</entry>	<- 한글이 그대로 저장되어 있다.
<entry key="timeout">30</entry>
<entry key="capacity">10</entry>
</properties>
```

<br/>
<br/>

### 예제4

시스템 속성을 가져오는 예제

System클래스의 `getProperties()`를 호출하면 시스템과 관련된 속성이 저장된 Properties를 가져올 수 있다.

```java
import java.util.*;

public class PropertiesEx4 {
    public static void main(String[] args) {
        Properties sysProp = System.getProperties();
        System.out.println("java.version :" + sysProp.getProperty("java.version"));
        System.out.println("user.langauge :" + sysProp.getProperty("user.language"));

        sysProp.list(System.out);
    }
}
```

**결과**

```
java.version :22.0.1
user.langauge :ko
-- listing properties --
java.specification.version=22
sun.cpu.isalist=amd64
... 중략 ...
java.class.version=66.0
```

<br/>
<br/>
<br/>

## 1.13 Collections

Collections는 컬렉션과 관련된 static 메서드를 제공한다.

### 1. 컬렉션 채우기, 복사, 정렬 , 검색 - fill(), copy(), sort(), binarySearch()

```java
Collections.fill(list, "defaultValue");	// 리스트의 모든 요소를 defaultValue로 채운다.
Collections.copy(destList, sourceList); // sourceList의 내용을 destList에 복사한다.
Collections.sort(list);		// list를 오름차순으로 정렬
Collections.sort(list, Comparator c);	// list를 Comparator정렬기준으로 저렬
int index = Collections.binarySearch(list, "value"); // 정렬된 list에서 value를 찾는다. 인덱스반환, 값없으면 음수
int index = Collections.binarySearch(list, "value", Comparator c);	// Comparaptor 정렬 기준
```

<br/>
<br/>

### 2. 컬렉션의 동기화 - synchronizedXXX()

Vector와 Hashtable과 같은 구버젼(JDK1.2이전)의 클래스들은 자체적으로 동기화 처리가 되어 있는데, 멀티 쓰레드 프로그래밍이 아닌 경우에는 성능이 떨어짐

그래서 새로 추가된 ArrayList, HashMap같은 컬렉션은 동기화를 자체적으로 하지않고 필요한 경우에만 java.util.Collections 클래스의 동기화 메서드를 이용해 동기화가 가능하게 변경함

```java
static Collection synchronizedCollection(Collection c)
static List	synchronizedList (List list)
static Set	synchronizedSet (Set s)
static Map	synchronizedMap (Map m)
static SortedSet synchronizedSortedSet (SortedSet s)
static SortedMap synchronizedSortedMap (SortedMap m)
```

**사용법**

```java
List syncList = Collections.synchronizedList(new ArrayList(...));
```

<br/>
<br/>

### 3. 변경불가(Unmodifiable) 컬렉션 만들기(readOnly) - unmodifiableXXX()

컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게(readOnly) 만들어야할 때가 있다.

주로 멀티 쓰레드 프로그래밍에서 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데, 이를 방지하기 위함이다.

```java
static Collection unmodifiableCollection(Collection c)
static List unmodifiableList (List list)
static Set unmodifiableSet (Set s)
static Map unmodifiableMap (Map m)
static NavigableSet unmodifiableNavigableSet (NavigableSet s)
static SortedSet unmodifiableSortedSet (SortedSet s)
static NavigableMap unmodifiableNavigableMap(NavigableMap m)
static SortedMap unmodifiableSortedMap (SortedMap m)
```

<br/>
<br/>

### 4. 싱글톤 컬렉션 만들기 - singletonXXX()

단 하나의 객체만을 저장하는 컬렉션을 만들 때 사용한다.

매개변수로 저장할 요소를 지정하면, 해당 요소를 저장하는 컬렉션을 반환한다. 그리고 반환된 컬렉션은 변경 불가

```java
static List singletonList(Object o)
static Set singleton(Object o)	// singletonSet이 아님
static Map singletonMap(Object key, Object value)
```

<br/>
<br/>

### 5. 한 종류의 객체만 저장하는 컬렉션 만들기 - checkedXXX()

컬렉션에 한 가지 타입의 객체만 저장 가능하게 만드는 메서드

하지만 실제로는 지네릭스를 많이 사용하고 있어서 활용도는 낮다.

그럼에도 사용하는 이유는 지네릭스가 JDK1.5부터 도입된 기능이여서 그 이전에 작성된 코드와의 호환성을 위한 것이다.

```java
static Collection checkedCollection(Collection c, Class type)
static List checkedList (List list, Class type)
static Set checkedSet (Set s, Class type)
static Map checkedMap (Map m, Class keyType, Class valueType)
static Queue checkedQueue (Queue queue, Class type)
static NavigableSet checkedNavigableSet (NavigableSet s, Class type)
static SortedSet checkedSortedSet (SortedSet s, Class type)
static NavigableMap checkedNavigableMap (NavigableMap m, Class keyType, Class valueType)
static SortedMap checkedSortedMap (SortedMap m, Class keyType, Class valueType)
```

**사용법**

```java
List list = new ArrayList();
List checkedList = checkedList(list, String.class);	// String 만 저장가능
checkedList.add("abc");	// OK
checkedList.add(new Integer(3));	//에러 ClassCastException 발생
```

<br/>
<br/>

### 추가적인 Collections의 메서드들 사용 예제

```java
import java.util.*;

public class CollectionsEx {
    public static void main(String[] args) {

        List list = new ArrayList();
        System.out.println(list); // []

        Collections.addAll(list, 1, 2, 3, 4, 5);
        System.out.println(list); // [1, 2, 3, 4, 5]

        Collections.rotate(list, 2); // 오른쪽으로 두 칸씩 이동
        System.out.println(list); // [4, 5, 1, 2, 3]

        Collections.swap(list, 0, 2); // 첫 번째와 세 번째를 교환(swap)
        System.out.println(list); // [1, 5, 4, 2, 3]

        Collections.shuffle(list);  // 지정된 원소의 위치를 임의로 변경
        System.out.println(list); // [5, 3, 4, 1, 2]

        Collections.sort(list, Collections.reverseOrder()); // 역순 정렬 reverse(list);와 같음
        System.out.println(list); // [5, 4, 3, 2, 1]

        Collections.sort(list);
        System.out.println(list); // [1, 2, 3, 4, 5]

        int idx = Collections.binarySearch(list, 3); // 3이 저장된 위치(index)를 반환
        System.out.println("index of 3 = " + idx); // index of 3 = 2

        System.out.println("max=" + Collections.max(list)); // max=5
        System.out.println("min=" + Collections.min(list)); // min=1
        System.out.println("min=" + Collections.max(list, Collections.reverseOrder())); // min=1

        Collections.fill(list, 9);   // list를 9로 채워놓음
        System.out.println("list=" + list); // list=[9, 9, 9, 9, 9]

        // list와 같은 크기의 새로운 list를 생성하고 2로 채운다. 단, 결과는 변경불가
        List newList = Collections.nCopies(list.size(), 2);
        System.out.println("newList=" + newList); // newList=[2, 2, 2, 2, 2]

        System.out.println(Collections.disjoint(list, newList)); // 공통요소가 없으면 true // true

        Collections.copy(list, newList);
        System.out.println("newList=" + newList); // newList=[2, 2, 2, 2, 2]
        System.out.println("list=" + list); // list=[2, 2, 2, 2, 2]

        Collections.replaceAll(list, 2, 1);
        System.out.println("list=" + list); // list=[1, 1, 1, 1, 1]

        Enumeration e = Collections.enumeration(list);
        ArrayList list2 = Collections.list(e);

        System.out.println("list2=" + list2); // list2=[1, 1, 1, 1, 1]
    }
}
```

<br/>
<br/>
<br/>
