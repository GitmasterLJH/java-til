# 1. Collections Framework

#### 용어

- **Collection** : 다수의 데이터(즉, 데이터 그룹)
- **Framework** : 표준화된 프로그램 방식
- **Collections Framework** : 데이터 그룹을 저장하는 클래스들을 표준화한 설계
- **Collection 클래스** : 다수의 데이터를 저장할 수 있는 클래스( Vector, Stack 등)

<br/>

<br/>

#### 장점

컬렉션 프레임웍은 컬렉션(data group)을 다루는 데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 상당히 덜어 준다.

인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

<br/>

<br/>

<br/>

## 1.1 컬렉션 프레임웍의 핵심 인터페이스

![image-20250108232916891](https://github.com/user-attachments/assets/833cc979-26df-493d-b6c8-b0341bc4b9ff)



> JDK1.5부터 Iterable인터페이스가 추가되고 이를 Collection 인터페이스가 상속받도록 변경되었으나 이것은 단지 인터페이스들의 공통적인 메서드인 iterator()를 뽑아서 중복을 제거한 것

<br/>

<br/>

| 인터페이스 | 특징                                                         | 구현 클래스                               |
| ---------- | ------------------------------------------------------------ | ----------------------------------------- |
| List       | 순서가 있는 데이터의 집합<br />데이터의 중복을 허용한다.     | ArrayList, LinkedList, Stack, Vector등    |
| Set        | 순서를 유지하지 않는  데이터의 집합<br />데이터의 중복을 허용하지 않는다. | HashSet, TreeSet 등                       |
| Map        | 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합<br />순서는 유지되지 않는다.<br />키는 중복을 허용 x , 값은 중복 허용 o | HashMap, TreeMap, Hashtable, Proterties등 |

<br/>

**Vector**나 **Hashtable**과 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다.

<br/>

<br/>

<br/>

### Collection 인터페이스

List와 Set의 조상인 Collection 인터페이스에 정의된 메서드

![image-20250108232945754](https://github.com/user-attachments/assets/92ee66fb-2e05-4274-8b98-e149f182275a)

> 책에서는 이해를 위해 지네릭스 E대신 Object로 표기함

<br/>

<br/>

<br/>

### List 인터페이스 - 순서 O, 중복 O

![image-20250108232955789](https://github.com/user-attachments/assets/390910df-6cda-4355-9183-85fbc17d9bd6)

List 인터페이스에 정의된 메서드

![image-20250108233002756](https://github.com/user-attachments/assets/752b0ddb-2f1f-4eb5-8625-8ea8d6f04fee)

<br/>

<br/>

<br/>

### Set 인터페이스 - 순서 X, 중복 X

![image-20250108233132436](https://github.com/user-attachments/assets/8fe4dc8b-8af4-4598-a170-f9d2c70bc64e)

Set 인터페이스의 메서드 : Collection 인터페이스와 동일

![image-20250108233238906](https://github.com/user-attachments/assets/3f3e5704-a3bc-4c36-8723-befac5b76213)
<br/>

<br/>

<br/>

### Map 인터페이스 - 순서 X, 중복(키 X, 값 O)

![image-20250108233408257](https://github.com/user-attachments/assets/9a15776a-c38c-4dac-9d2e-afc8eb8a4505)

Map 인터페이스의 메서드

![image-20250108233439565](https://github.com/user-attachments/assets/5d16e8ff-66c3-464f-9891-4267d6401e4c)

`Collection values()`

- Map인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환

`Set keySet()`

- 키(key)는 중복을 허용하지 않기 때문에 Set타입으로 반환

<br/>

<br/>

### Map.Entry 인터페이스

- Map.Entry인터페이스는 Map인터페이스의 내부 인터페이스이다.
- Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.
- Map인터페이스를 구현하는 클래스 에서는 Map.Entry 인터페이스도 함께 구현해야 한다.
- 맵에 저장되는 엔트리의 조작을 위한 메소드가 정의되어있다

```java
public interface Map{
	...
	public static interface Entry{
		Object getKey();
        Object getValue();
        Object setValue(Object value);
        boolean equals(Object o);
        int hashCode();
        ...
	}
}
```

<br/>

<br/>

<br/>

## 1.2 ArrayList

- ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다.
- Vector는 자체적으로 동기화처리가 되어 있으나 ArrayList는 그렇지 않다
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.

![image-20250109012854032](https://github.com/user-attachments/assets/c534b764-cda0-400a-b4cf-9217e7594f94) 

<br/>

ArrayList의 생성자와 메서드

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| ArrayList()                              | 크기가 10인 ArrayList를 생성                                 |
| ArrayList(Collection c)                  | 주어진  컬렉션이 저장된 ArrayList를 생성                     |
| ArrayList(int initialCapacity)           | 지정된 초기용량을 갖는 ArrayList를 생성                      |
| boolean add(Object o)                    | ArrayList의 마지막에 객체를 추가. 성공하면 true              |
| void add(int index, Object element)      | 지정된 위치(index)에 객체를 저장                             |
| boolean addAll(Collection c)             | 주어진 컬렉션의 모든 객체를 저장한다.                        |
| boolean addAll(int index, Collection c)  | 지정된 위치부터 주어진 컬렉션의 모든 객체를 저장한다.        |
| void clear()                             | ArrayList를 완전히 비운다.                                   |
| Object clone()                           | ArrayList를 복제한다.                                        |
| boolean contains(Object o)               | 지정된 객체(o)가 ArrayList에 포함되어 있는지 확인            |
| void ensureCapacity(int minCapacity)     | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.         |
| Object get(int index)                    | 지정된 위치(index)에 저장된 객체를 반환한다.                 |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치를 찾아서 반환한다.                 |
| boolean isEmpty()                        | ArrayList가 비어있는지 확인한다.                             |
| Iterator iterator()                      | ArrayList의 Iterator 객체를 반환                             |
| int lastIndexOf(Object o)                | 객체(o)가 저장된 위치를 끝부터 역방으로 검색해서 반환        |
| ListIterator listIterator()              | ArrayList의 ListIterator을 반환                              |
| ListIterator listIterator(int index)     | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환     |
| Object remove(int index)                 | 지정된 위치(index)에 있는 객체를 제거한다.                   |
| boolean remove(Object o)                 | 지정된 객체를 제거한다.                                      |
| boolean removeAll(Collection c)          | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다. |
| boolean retainAll(Collection c)          | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Object element)    | 주어진 객체(element)를 지정된 위치(index)에 저장한다.        |
| int size()                               | ArrayList에 저장된 객체의 개수를 반환한다.                   |
| voidsort(Comparator c)                   | 지정된 정렬기준(c)으로 ArrayList를 정렬                      |
| List subList(int fromIndex, int toIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.          |
| Object[] toArray()                       | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.        |
| Object[] toArray(Object[] a)             | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다. |
| void trimToSize()                        | 용량을 크기에 맞게 줄인다.(빈 공간 없앰)                     |

<br/>

<br/>

### ArrayListEx1

```java
import java.util.ArrayList;
import java.util.Collections;


public class ArrayListEx1 {

    public static void main(String[] args) {
        ArrayList list1 = new ArrayList(10);
        list1.add(Integer.valueOf(5));
        list1.add(Integer.valueOf(4));
        list1.add(Integer.valueOf(2));
        list1.add(Integer.valueOf(0));
        list1.add(Integer.valueOf(1));
        list1.add(Integer.valueOf(3));


        ArrayList list2 = new ArrayList<>(list1.subList(1,4));
        print(list1,list2);
        /*
        list1: [5, 4, 2, 0, 1, 3]
        list2: [4, 2, 0]
         */

        Collections.sort(list1);
        Collections.sort(list2); // Collections.sort(List l)
        print(list1, list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4]
         */

        System.out.println("list1.containsAll(list2):" +list1.containsAll(list2)); // true

        list2.add("B");
        list2.add("C");
        list2.add(3,"A");
        print(list1,list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4, A, B, C]
         */

        list2.set(3,"AA");
        print(list1,list2);
        /*
        list1: [0, 1, 2, 3, 4, 5]
        list2: [0, 2, 4, AA, B, C]
         */

        // list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제
        System.out.println("list1.retainAll(list2) :" + list1.retainAll(list2)); // true
        print(list1,list2);
        /*
        list1: [0, 2, 4]
        list2: [0, 2, 4, AA, B, C]
         */

        // list2에서 list1에 포함돈 객체들을 삭제한다.
        for(int i = list2.size()-1; i>=0; i--){
            if(list1.contains(list2.get(i)))
                list2.remove(i);
        }
        print(list1,list2);
        /*
        list1: [0, 2, 4]
        list2: [AA, B, C]
         */
    }


   static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1: "+list1);
        System.out.println("list2: "+list2);
        System.out.println();
    }
}
```

> Collections는 클래스

<br/>

<br/>

### ArrayListEx2

긴 문자열 데이터를 원하는 길이로 잘라서 ArrayList에 담은 다음 출력하는 예제

```java
import java.util.*;

public class ArrayListEx2 {
    public static void main(String[] args) {
        final int LIMIT = 10; // 자르고자 하는 글자의 개수
        String source = "0123456789abcdefghijABCDEFGHIJ!@#$%^&*()ZZZ";
        int length = source.length();

        List list = new ArrayList(length/LIMIT + 10); // 크기를 약간 여유 있게 잡음

        for(int i=0; i<length;i+=LIMIT){
            if(i+LIMIT < length)
                list.add(source.substring(i,i+LIMIT));
            else
                list.add(source.substring(i));
        }
        for(int i=0; i<list.size();i++){
            System.out.println(list.get(i));
        }
    }
}
```

<br/>

<br/>

### VectorEx1

Vector의 용량(capacity)과 크기(size)에 관한 예제

```java
import java.util.*;

public class VectorEx1 {
    public static void main(String[] args) {
        Vector v = new Vector(5); // 용량(capacity)이 5인 Vector를 생성한다.
        v.add("1");
        v.add("2");
        v.add("3");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :5
        */
        
        v.trimToSize(); // 빈 공간을 없앤다. (capacity와 size가 같아짐)
        System.out.println("=== After trimToSize() ===");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :3
        */

        v.ensureCapacity(6);
        System.out.println("=== After ensureCapacity(6) ===");
        print(v);
        /*
        [1, 2, 3]
        size  :3
        capacity :6
        */
        
        
        v.setSize(7);
        System.out.println("=== After setSize(7) ===");
        print(v);
        /*
        [1, 2, 3, null, null, null, null]
        size  :7
        capacity :12
        */

        v.clear();
        System.out.println("=== After clear ===");
        print(v);
        /*
        []
        size  :0
        capacity :12
        */
    }
    static void print(Vector v){
       System.out.println(v);
       System.out.println("size  :"+ v.size());
       System.out.println("capacity : "+v.capacity());
    }
}
```

#### 과정별 크기(size)와 용량(capacity)

<br/>

#### 1. capacity가 5인 Vector인스턴스 V 생성 후, 3개의 객체를 저장

```java
Vector v = new Vector(5);
v.add("1");
v.add("2");
v.add("3");
```

![image-20250109033425862](https://github.com/user-attachments/assets/1b461c89-9177-4d33-b880-592bb84a4b03)

<br/>

<br/>

#### 2. v.trimToSize()를 호출하여 v의 빈공간 없앰

- size와 capacity가 같아진다.
- 배열은 크기를 변경할 수 없기에 새로운 배열을 생성해서 그 주소값을 변수 v에 할당한다.
- 기존의 Vector인스턴스는 더 이상 사용 불가, 후에 **garbage collector**에 의해서 메모리에서 제거됨

```java
v.trimToSize();
```

![image-20250109033509023](https://github.com/user-attachments/assets/ec8b8106-a898-4cdf-bbe7-bfa00a187b5d)

<br/>

<br/>

#### 3. v의 capacity가 최소한 6이 되도록 한다.

- 만약 v의 capacity가 6이상이면 아무 일도 일어나지 않는다.
- 현재는 v의 capacity가 3이므로 크기가 6인 배열을 생성해서 v의 내용을 복사한다.

```java
v.ensureCapacity(6);
```

![image-20250109033642317](https://github.com/user-attachments/assets/3b5b9dc7-c367-48eb-9ac9-3850978fe3d0)

<br/>

<br/>

#### 4. v의 size가 7이 되도록 한다.

- 만약 v의 capacity가 충분하면 아무일도 안일어남
- 지금은 capacity가 6으로 부족하므로 새로운 인스턴스를 생성한다.
  - 자동적으로 기존의 크기보다 2배의 크기로 증가된다.(capacity = 12가 됨)

> 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 된다.

```java
v.setSize(7);
```

![image-20250109033742292](https://github.com/user-attachments/assets/ee88bc5c-f42d-44a9-8b5e-1551c5e1397a)

<br/>

<br/>

#### 5. v의 모든 요소를 삭제한다.

```java
v.clear();
```

![image-20250109033752377](https://github.com/user-attachments/assets/6308316c-7ace-435a-8ff7-82a9c7590964)

> Vector는 Object배열이기 때문에 실제로는 마지막 그림처럼 주소가 저장되어야 더 정확한 것이지만, 편의상 이전의 그림들은 간략하게 표현함

<br/>

<br/>

#### ArrayList나 Vector같이 배열을 이용한 자료구조 특징

- 데이터를 읽어오고 저장하는데 효율이 좋다.
- 용량을 변경해야할 때는 새로운 배열을 생성한후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야하기에 효율이 떨어진다.

따라서 처음 인스턴스를 생성할 때, 용량을 잘 설정해야함

<br/>

<br/>

### MyVector

Vector클래스의 실제코드를 바탕으로 이해하기 쉽게 재구성한 예제

```java
import java.util.*;

public class MyVector implements List {

    Object[] data = null; // 객체를 담기 위한 객체배열
    int capacity = 0; // 용량
    int size = 0; // 크기

    public MyVector(int capacity) {
        if (capacity < 0)
            throw new IllegalArgumentException("유효하지 않은 값입니다. :" + capacity);
        this.capacity = capacity;
        data = new Object[capacity];
    }

    public MyVector() {
        this(10);
    }


    public void ensureCapacity(int minCapacity) {

        if (minCapacity - data.length > 0)
            setCapacity(minCapacity);
    }

    public boolean add(Object obj) {
        ensureCapacity(size + 1);
        data[size++] = obj;
        return true;
    }

    public Object get(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        return data[index];
    }


    public Object remove(int index) {
        Object oldObj = null;

        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        oldObj = data[index];

        // 삭제하고자 하는 객체가 마지막 객체가 아닌경우
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        // 마지막 데이터를 null로 한다.
        data[size - 1] = null;
        size--;
        return oldObj;
    }


    public boolean remove(Object obj) {
        for (int i = 0; i < size; i++) {
            if (obj.equals(data[i])) {
                remove(i);
                return true;
            }
        }
        return false;
    }


    public void trimToSize() {
        setCapacity(size);
    }

    public void setCapacity(int capacity) {
        if (this.capacity == capacity) return;

        Object[] tmp = new Object[capacity];
        System.arraycopy(data, 0, tmp, 0, Math.min(size, capacity));
        size = Math.min(size, capacity);
        data = tmp;
        this.capacity = capacity;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            data[i] = null;
        }
        size = 0;
    }

    public Object[] toArray() {
        Object[] result = new Object[size];
        System.arraycopy(data,0,result,0,size);
        return result;
    }

    public boolean isEmpty() {
        return size==0;
    }


    public int capacity() {
        return capacity;
    }

    public int size() {
        return size;
    }

    public boolean contains(Object o) {
        for(int i=0; i<size;i++){
            if(o.equals(data[i]))
                return true;
        }
        return false;
    }

    public int indexOf(Object o){
        return indexOfRange(o,0,size);
    }

    int indexOfRange(Object o, int start, int end) {
        Object[] es = data;
        if (o == null) {
            for (int i = start; i < end; i++) {
                if (es[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = start; i < end; i++) {
                if (o.equals(es[i])) {
                    return i;
                }
            }
        }
        return -1;
    }

    public int lastIndexOf(Object o) {
        return lastIndexOfRange(o, 0, size);
    }

    int lastIndexOfRange(Object o, int start, int end) {
        Object[] es = data;
        if (o == null) {
            for (int i = end - 1; i >= start; i--) {
                if (es[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = end - 1; i >= start; i--) {
                if (o.equals(es[i])) {
                    return i;
                }
            }
        }
        return -1;
    }
    public Object set(int index, Object element) {
        if(index<0 || index>size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
        Object oldValue = data[index];
        data[index] = element;
        return oldValue;
    }

    public void add(int index, Object element) {
        if(index<0 || index>=size)
            throw new IndexOutOfBoundsException("범위를 벗어났습니다.");

        ensureCapacity(size+1);
        if(index!=size-1)
            System.arraycopy(data,index, data,index+1,size-index);
        data[index] = element;
        size++;

    }

    public String toString(){
        if (size == 0) 
            return "[]";
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        
        for (int i = 0; i < size; i++) {
            sb.append(data[i]);
            if (i < size - 1) // 마지막 요소가 아니면 쉼표 추가
                sb.append(", ");
        }
        sb.append(']');
        return sb.toString();
    }
// 아랫부분은 컴파일만 가능하도록 최소한으로 구현한것

    @Override
    public Iterator iterator() {
        return null;
    }

    @Override
    public Object[] toArray(Object[] a) {
        return new Object[0];
    }

    @Override
    public boolean containsAll(Collection c) {
        return false;
    }

    @Override
    public boolean addAll(Collection c) {
        return false;
    }

    @Override
    public boolean addAll(int index, Collection c) {
        return false;
    }

    @Override
    public boolean removeAll(Collection c) {
        return false;
    }

    @Override
    public boolean retainAll(Collection c) {
        return false;
    }

    @Override
    public ListIterator listIterator() {
        return null;
    }

    @Override
    public ListIterator listIterator(int index) {
        return null;
    }

    @Override
    public List subList(int fromIndex, int toIndex) {
        return List.of();
    }
}
```

<br/>

<br/>

#### MyVector클래스에서 0~4 값이 저장되어 있는 상태에서 `remove(2)` 호출 과정

![image-20250109233424356](https://github.com/user-attachments/assets/96574688-0fde-4c2e-b04f-beb4bb61c2be)

1. 삭제할 데이터의 아래에 있는 데이터를 한 칸 씩 위로 복사해서 삭제할 데이터를 덮어쓴다.

   ```java
   System.arraycopy(data, index+1, data, index, size-index-1) // data[3]에서 data[2]로 2개의 데이터를 복사
   ```

2. 데이터가 모두 한 칸씩 위로 이동하였으므로 마지막 데이터는 null로 변경

   ```java
   data[size-1] = null
   ```

3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 1 감소시킨다.

   ```java
   size--;
   ```

<br/>

#### 결론

배열에 객체를 **순차적으로 저장**하거나 객체를 **마지막에 저장된 것부터 삭제**하면 `System.arraycopy()`를 호출하지 않기 때문에 **효율적**이지만 배열의 **중간에 위치한 객체를 추가하거나 삭제**하는 경우 `System.arraycopy()`를 호출해서 데이터의 위치를 이동시켜야 하기 때문에 **효율적이지 못함**

<br/>

<br/>

<br/>



