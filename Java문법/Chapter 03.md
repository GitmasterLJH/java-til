# Chapter 03 연산자

### 1. 연산자(operator)

---

#### 1.1 연산자의  우선순위와 결합규칙

<img src="https://github.com/GitmasterLJH/java-til/assets/129172593/b778d484-2d2c-47ac-88c2-b60003497e2f" width="400px" height="300px">

**주의 해야할 연산자 우선순위 예**

- ` x << 2 + 1`  +연산후 <<
- ` data & 0xFF  == 0` ==연산후 &
- `x < -1 || x > 3 && x < 5 ` &&연산 수행후 ||

#### 1.2 산술 변환(usual arithmetic conversion)

```
산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
  1.두 연피연산자의 타입을 같게 일치시킨다.
  2.피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```



### 2. 단항 연산자

---

#### 2.1 증감 연산자 

- 전위형 : 값이 참조되기 전에 증가시킨다.
  - j = ++i;
- 후위형 : 값이 참조된 후에 증가시킨다.
  - j = i++;

#### 2.2 부호 연산자

- i = -10 이나 i= +10; 처럼 +,-를 붙인것
- boolean형과 char형을 제외한 기본형에만 사용가능



### 3. 산술 연산자

---

#### 3.1 사칙 연산

- 정수형 끼리의 연산의 결과는 int형이다. 
- 피연산자로 문자도 가능
  - 문자 2를 숫자로 변환법 : '2' - '0' -> (유니코드)50 - 48 -> 2  
- 상수 또는 리터럴 간의 연산은 컴파일시 컴파일러가 계산해서 그 결과로 대체
  - char c2 ='a'+1;  컴파일 후 -> char c2 = 'b';
- Math.round(3141.592) 의 결과는 3142 ,  소수점 첫째자리에서 반올림후 그 결과를 정수로 돌려줌

#### 3.2 나머지 연산자 %

**나누는 수가 음수인 경우**

- 피연산자의 부호를 모두 무시하고 , 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다

```java
 System.out.println(-10%8);   //-2
 System.out.println(10%-8);	  //2
 System.out.println(-10%-8);  //-2
```



### 4. 비교 연산자

---

#### 4.1 대소비교 연산자 < > <= >=

- booelan형, 참조형에 사용 불가능

#### 4.2 등가비교 연산자 == !=

- float타입과 double타입 비교할떄

  - double타입을 float타입으로 변환후 비교해야 함

  ```
  float  f = 0.1f;    // f에 0.10000000149011612로 저장됨
  double d = 0.1;     // d에 0.10000000000000001로 저장됨
  
  //float타입을 double타입으로 형변환 해도 값은 달라지지 않는다.
  ```

- 문자열의 비교

  - '=='대신 equals() 메서드를 사용

  - String은 클래스이므로 아래와 같이 new를 사용해서 객체를 생성해야함

    ```java
    String str =  new String("abc");  // String클래스의 객체를 생성
    String str = "abc";   // 위의 문장을 간단히 표현
    
    //String 클래스만 new를 사용하지 않고 간단히 쓸 수 있게 허용
    ```

  - str2와 abc의 내용이 같지만 서로 다른 객체라서 false인경우 

    ```java
    String str1 = "abc";
    String str2 = new String("abc");
    
    System.out.printf(" str2==\"abc\" ? %b\n",  str2=="abc");  //false
    ```

  - equalsIgnoreCase()를 사용하면 대소문자 구별하지 않고 비교 가능




### 5. 논리 연산자

---

#### 5.1 논리 연산자 - &&, ||, !

- 효율적인 연산
  - OR연산(||)
    - 좌측 피연산자가 true면 우측 피연산자의 값 평가x
  - AND연산(&&)
    - 좌측 피연산자가 false면 우측 피연산자의 값 평가x
- 논리 부정 연산자 !
  - 문자ch는 소문자가 아니다라는 조건
    - `ch < 'a' || ch > 'z'` <-------> `!('a' <= ch && ch <= 'z')` 

#### 5.2 비트 연산자

- 피연산자로 실수는 허용x , 정수(문자 포함)만 허용

- 종류
  - |, &, ^ , ~ , <<, >>
  
- 비트 전환 연산자~
  - 0은 1로 1은 0으로
  - 1의 보수 연산자 라고도 부름
  
- 쉬프트 연산자 << , >>
  ```
  x << n은 x*2^n의 결과와 같다.
  x >> n은 x/2^n의 결과와 같다.
  ```
  
  - 곱셈이나 나눗셈 연산자보다 속도가 빠르다. 하지만 가독성 떨어짐
  
- &, | 연산자

  - 0xAB | 0xF = 0xAF       ->마지막 4비트 'F'로 변경
  - 0xAB & 0xF = 0xB         ->마지막 4비트값 추출

### 6. 그 외의 연산자

---

#### 6.1 조건 연산자 ? :

- 조건식 ? 식1 : 식2

  ​			   참      거짓

- 두 피연산자의 타입이 다른 경우 산술 변환이 발생

#### 6.2 대입 연산자

-   X 	   =	    3

​     lvalue	       rvalue

- lvalue : 변수처럼 값을 변경할 수 있는 것이어야 한다,  rvalue : 모두 가능

#### 6.3 복합 대입 연산자

- ex) i +=3;      -->    i= i +3;

